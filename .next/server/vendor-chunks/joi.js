"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/joi";
exports.ids = ["vendor-chunks/joi"];
exports.modules = {

/***/ "(rsc)/./node_modules/joi/lib/annotate.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/annotate.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst internals = {\n    annotations: Symbol(\"annotations\")\n};\nexports.error = function(stripColorCodes) {\n    if (!this._original || typeof this._original !== \"object\") {\n        return this.details[0].message;\n    }\n    const redFgEscape = stripColorCodes ? \"\" : \"\\x1b[31m\";\n    const redBgEscape = stripColorCodes ? \"\" : \"\\x1b[41m\";\n    const endColor = stripColorCodes ? \"\" : \"\\x1b[0m\";\n    const obj = Clone(this._original);\n    for(let i = this.details.length - 1; i >= 0; --i){\n        const pos = i + 1;\n        const error = this.details[i];\n        const path = error.path;\n        let node = obj;\n        for(let j = 0;; ++j){\n            const seg = path[j];\n            if (Common.isSchema(node)) {\n                node = node.clone(); // joi schemas are not cloned by hoek, we have to take this extra step\n            }\n            if (j + 1 < path.length && typeof node[seg] !== \"string\") {\n                node = node[seg];\n            } else {\n                const refAnnotations = node[internals.annotations] || {\n                    errors: {},\n                    missing: {}\n                };\n                node[internals.annotations] = refAnnotations;\n                const cacheKey = seg || error.context.key;\n                if (node[seg] !== undefined) {\n                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];\n                    refAnnotations.errors[cacheKey].push(pos);\n                } else {\n                    refAnnotations.missing[cacheKey] = pos;\n                }\n                break;\n            }\n        }\n    }\n    const replacers = {\n        key: /_\\$key\\$_([, \\d]+)_\\$end\\$_\"/g,\n        missing: /\"_\\$miss\\$_([^|]+)\\|(\\d+)_\\$end\\$_\": \"__missing__\"/g,\n        arrayIndex: /\\s*\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\",?\\n(.*)/g,\n        specials: /\"\\[(NaN|Symbol.*|-?Infinity|function.*|\\(.*)]\"/g\n    };\n    let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1)=>`\" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2)=>`${redBgEscape}\"${$1}\"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2)=>`\\n${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1)=>$1);\n    message = `${message}\\n${redFgEscape}`;\n    for(let i = 0; i < this.details.length; ++i){\n        const pos = i + 1;\n        message = `${message}\\n[${pos}] ${this.details[i].message}`;\n    }\n    message = message + endColor;\n    return message;\n};\n// Inspired by json-stringify-safe\ninternals.safeStringify = function(obj, spaces) {\n    return JSON.stringify(obj, internals.serializer(), spaces);\n};\ninternals.serializer = function() {\n    const keys = [];\n    const stack = [];\n    const cycleReplacer = (key, value)=>{\n        if (stack[0] === value) {\n            return \"[Circular ~]\";\n        }\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n    };\n    return function(key, value) {\n        if (stack.length > 0) {\n            const thisPos = stack.indexOf(this);\n            if (~thisPos) {\n                stack.length = thisPos + 1;\n                keys.length = thisPos + 1;\n                keys[thisPos] = key;\n            } else {\n                stack.push(this);\n                keys.push(key);\n            }\n            if (~stack.indexOf(value)) {\n                value = cycleReplacer.call(this, key, value);\n            }\n        } else {\n            stack.push(value);\n        }\n        if (value) {\n            const annotations = value[internals.annotations];\n            if (annotations) {\n                if (Array.isArray(value)) {\n                    const annotated = [];\n                    for(let i = 0; i < value.length; ++i){\n                        if (annotations.errors[i]) {\n                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(\", \")}_$end$_`);\n                        }\n                        annotated.push(value[i]);\n                    }\n                    value = annotated;\n                } else {\n                    for(const errorKey in annotations.errors){\n                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(\", \")}_$end$_`] = value[errorKey];\n                        value[errorKey] = undefined;\n                    }\n                    for(const missingKey in annotations.missing){\n                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = \"__missing__\";\n                    }\n                }\n                return value;\n            }\n        }\n        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === \"function\" || typeof value === \"symbol\") {\n            return \"[\" + value.toString() + \"]\";\n        }\n        return value;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9hbm5vdGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXRCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBR3ZCLE1BQU1FLFlBQVk7SUFDZEMsYUFBYUMsT0FBTztBQUN4QjtBQUdBQyxhQUFhLEdBQUcsU0FBVUUsZUFBZTtJQUVyQyxJQUFJLENBQUMsSUFBSSxDQUFDQyxTQUFTLElBQ2YsT0FBTyxJQUFJLENBQUNBLFNBQVMsS0FBSyxVQUFVO1FBRXBDLE9BQU8sSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxDQUFDQyxPQUFPO0lBQ2xDO0lBRUEsTUFBTUMsY0FBY0osa0JBQWtCLEtBQUs7SUFDM0MsTUFBTUssY0FBY0wsa0JBQWtCLEtBQUs7SUFDM0MsTUFBTU0sV0FBV04sa0JBQWtCLEtBQUs7SUFFeEMsTUFBTU8sTUFBTWYsTUFBTSxJQUFJLENBQUNTLFNBQVM7SUFFaEMsSUFBSyxJQUFJTyxJQUFJLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHLEVBQUVBLEVBQUc7UUFDL0MsTUFBTUUsTUFBTUYsSUFBSTtRQUNoQixNQUFNVCxRQUFRLElBQUksQ0FBQ0csT0FBTyxDQUFDTSxFQUFFO1FBQzdCLE1BQU1HLE9BQU9aLE1BQU1ZLElBQUk7UUFDdkIsSUFBSUMsT0FBT0w7UUFDWCxJQUFLLElBQUlNLElBQUksSUFBSyxFQUFFQSxFQUFHO1lBQ25CLE1BQU1DLE1BQU1ILElBQUksQ0FBQ0UsRUFBRTtZQUVuQixJQUFJbkIsT0FBT3FCLFFBQVEsQ0FBQ0gsT0FBTztnQkFDdkJBLE9BQU9BLEtBQUtJLEtBQUssSUFBaUMsc0VBQXNFO1lBQzVIO1lBRUEsSUFBSUgsSUFBSSxJQUFJRixLQUFLRixNQUFNLElBQ25CLE9BQU9HLElBQUksQ0FBQ0UsSUFBSSxLQUFLLFVBQVU7Z0JBRS9CRixPQUFPQSxJQUFJLENBQUNFLElB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QUssQ0FBQ1UsU0FBUyxHQUFHM0I7b0JBQ3RCO29CQUVBLElBQUssTUFBTTRCLGNBQWN2RCxZQUFZdUIsT0FBTyxDQUFFO3dCQUMxQ3FCLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRVcsV0FBVyxDQUFDLEVBQUV2RCxZQUFZdUIsT0FBTyxDQUFDZ0MsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUc7b0JBQy9FO2dCQUNKO2dCQUVBLE9BQU9YO1lBQ1g7UUFDSjtRQUVBLElBQUlBLFVBQVVZLFlBQ1ZaLFVBQVUsQ0FBQ1ksWUFDWEMsT0FBT0MsS0FBSyxDQUFDZCxVQUNiLE9BQU9BLFVBQVUsY0FDakIsT0FBT0EsVUFBVSxVQUFVO1lBRTNCLE9BQU8sTUFBTUEsTUFBTWUsUUFBUSxLQUFLO1FBQ3BDO1FBRUEsT0FBT2Y7SUFDWDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9hbm5vdGF0ZS5qcz9lNzAyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBhbm5vdGF0aW9uczogU3ltYm9sKCdhbm5vdGF0aW9ucycpXG59O1xuXG5cbmV4cG9ydHMuZXJyb3IgPSBmdW5jdGlvbiAoc3RyaXBDb2xvckNvZGVzKSB7XG5cbiAgICBpZiAoIXRoaXMuX29yaWdpbmFsIHx8XG4gICAgICAgIHR5cGVvZiB0aGlzLl9vcmlnaW5hbCAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxzWzBdLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgY29uc3QgcmVkRmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzMxbSc7XG4gICAgY29uc3QgcmVkQmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzQxbSc7XG4gICAgY29uc3QgZW5kQ29sb3IgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzBtJztcblxuICAgIGNvbnN0IG9iaiA9IENsb25lKHRoaXMuX29yaWdpbmFsKTtcblxuICAgIGZvciAobGV0IGkgPSB0aGlzLmRldGFpbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgdG8gcHJvY2VzcyBkZWVwZXN0IGNoaWxkIGZpcnN0XG4gICAgICAgIGNvbnN0IHBvcyA9IGkgKyAxO1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuZGV0YWlsc1tpXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGVycm9yLnBhdGg7XG4gICAgICAgIGxldCBub2RlID0gb2JqO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IHBhdGhbal07XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jbG9uZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpvaSBzY2hlbWFzIGFyZSBub3QgY2xvbmVkIGJ5IGhvZWssIHdlIGhhdmUgdG8gdGFrZSB0aGlzIGV4dHJhIHN0ZXBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGogKyAxIDwgcGF0aC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZVtzZWddICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVbc2VnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZkFubm90YXRpb25zID0gbm9kZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdIHx8IHsgZXJyb3JzOiB7fSwgbWlzc2luZzoge30gfTtcbiAgICAgICAgICAgICAgICBub2RlW2ludGVybmFscy5hbm5vdGF0aW9uc10gPSByZWZBbm5vdGF0aW9ucztcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2VnIHx8IGVycm9yLmNvbnRleHQua2V5O1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVbc2VnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gPSByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLm1pc3NpbmdbY2FjaGVLZXldID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVwbGFjZXJzID0ge1xuICAgICAgICBrZXk6IC9fXFwka2V5XFwkXyhbLCBcXGRdKylfXFwkZW5kXFwkX1wiL2csXG4gICAgICAgIG1pc3Npbmc6IC9cIl9cXCRtaXNzXFwkXyhbXnxdKylcXHwoXFxkKylfXFwkZW5kXFwkX1wiOiBcIl9fbWlzc2luZ19fXCIvZyxcbiAgICAgICAgYXJyYXlJbmRleDogL1xccypcIl9cXCRpZHhcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIsP1xcbiguKikvZyxcbiAgICAgICAgc3BlY2lhbHM6IC9cIlxcWyhOYU58U3ltYm9sLip8LT9JbmZpbml0eXxmdW5jdGlvbi4qfFxcKC4qKV1cIi9nXG4gICAgfTtcblxuICAgIGxldCBtZXNzYWdlID0gaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkob2JqLCAyKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMua2V5LCAoJDAsICQxKSA9PiBgXCIgJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMubWlzc2luZywgKCQwLCAkMSwgJDIpID0+IGAke3JlZEJnRXNjYXBlfVwiJHskMX1cIiR7ZW5kQ29sb3J9JHtyZWRGZ0VzY2FwZX0gWyR7JDJ9XTogLS0gbWlzc2luZyAtLSR7ZW5kQ29sb3J9YClcbiAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLmFycmF5SW5kZXgsICgkMCwgJDEsICQyKSA9PiBgXFxuJHskMn0gJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuc3BlY2lhbHMsICgkMCwgJDEpID0+ICQxKTtcblxuICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbiR7cmVkRmdFc2NhcGV9YDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXRhaWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGkgKyAxO1xuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5bJHtwb3N9XSAke3RoaXMuZGV0YWlsc1tpXS5tZXNzYWdlfWA7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyBlbmRDb2xvcjtcblxuICAgIHJldHVybiBtZXNzYWdlO1xufTtcblxuXG4vLyBJbnNwaXJlZCBieSBqc29uLXN0cmluZ2lmeS1zYWZlXG5cbmludGVybmFscy5zYWZlU3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgc3BhY2VzKSB7XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBpbnRlcm5hbHMuc2VyaWFsaXplcigpLCBzcGFjZXMpO1xufTtcblxuXG5pbnRlcm5hbHMuc2VyaWFsaXplciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuXG4gICAgY29uc3QgY3ljbGVSZXBsYWNlciA9IChrZXksIHZhbHVlKSA9PiB7XG5cbiAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfl0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfi4nICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbignLicpICsgJ10nO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAofnRoaXNQb3MpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSB0aGlzUG9zICsgMTtcbiAgICAgICAgICAgICAgICBrZXlzLmxlbmd0aCA9IHRoaXNQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGtleXNbdGhpc1Bvc10gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjeWNsZVJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSB2YWx1ZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRlZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5lcnJvcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWQucHVzaChgXyRpZHgkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2ldLnNvcnQoKS5qb2luKCcsICcpfV8kZW5kJF9gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkLnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhbm5vdGF0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVycm9yS2V5IGluIGFubm90YXRpb25zLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYCR7ZXJyb3JLZXl9XyRrZXkkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2Vycm9yS2V5XS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYF0gPSB2YWx1ZVtlcnJvcktleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtlcnJvcktleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1pc3NpbmdLZXkgaW4gYW5ub3RhdGlvbnMubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYF8kbWlzcyRfJHttaXNzaW5nS2V5fXwke2Fubm90YXRpb25zLm1pc3NpbmdbbWlzc2luZ0tleV19XyRlbmQkX2BdID0gJ19fbWlzc2luZ19fJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAtSW5maW5pdHkgfHxcbiAgICAgICAgICAgIE51bWJlci5pc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdmFsdWUudG9TdHJpbmcoKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJDbG9uZSIsInJlcXVpcmUiLCJDb21tb24iLCJpbnRlcm5hbHMiLCJhbm5vdGF0aW9ucyIsIlN5bWJvbCIsImV4cG9ydHMiLCJlcnJvciIsInN0cmlwQ29sb3JDb2RlcyIsIl9vcmlnaW5hbCIsImRldGFpbHMiLCJtZXNzYWdlIiwicmVkRmdFc2NhcGUiLCJyZWRCZ0VzY2FwZSIsImVuZENvbG9yIiwib2JqIiwiaSIsImxlbmd0aCIsInBvcyIsInBhdGgiLCJub2RlIiwiaiIsInNlZyIsImlzU2NoZW1hIiwiY2xvbmUiLCJyZWZBbm5vdGF0aW9ucyIsImVycm9ycyIsIm1pc3NpbmciLCJjYWNoZUtleSIsImNvbnRleHQiLCJrZXkiLCJ1bmRlZmluZWQiLCJwdXNoIiwicmVwbGFjZXJzIiwiYXJyYXlJbmRleCIsInNwZWNpYWxzIiwic2FmZVN0cmluZ2lmeSIsInJlcGxhY2UiLCIkMCIsIiQxIiwiJDIiLCJzcGFjZXMiLCJKU09OIiwic3RyaW5naWZ5Iiwic2VyaWFsaXplciIsImtleXMiLCJzdGFjayIsImN5Y2xlUmVwbGFjZXIiLCJ2YWx1ZSIsInNsaWNlIiwiaW5kZXhPZiIsImpvaW4iLCJ0aGlzUG9zIiwiY2FsbCIsIkFycmF5IiwiaXNBcnJheSIsImFubm90YXRlZCIsInNvcnQiLCJlcnJvcktleSIsIm1pc3NpbmdLZXkiLCJJbmZpbml0eSIsIk51bWJlciIsImlzTmFOIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/annotate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/base.js":
/*!**************************************!*\
  !*** ./node_modules/joi/lib/base.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"(rsc)/./node_modules/@hapi/hoek/lib/deepEqual.js\");\nconst Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ \"(rsc)/./node_modules/@hapi/hoek/lib/merge.js\");\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/joi/lib/cache.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ./compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Extend = __webpack_require__(/*! ./extend */ \"(rsc)/./node_modules/joi/lib/extend.js\");\nconst Manifest = __webpack_require__(/*! ./manifest */ \"(rsc)/./node_modules/joi/lib/manifest.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\nconst Modify = __webpack_require__(/*! ./modify */ \"(rsc)/./node_modules/joi/lib/modify.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst Trace = __webpack_require__(/*! ./trace */ \"(rsc)/./node_modules/joi/lib/trace.js\");\nconst Validator = __webpack_require__(/*! ./validator */ \"(rsc)/./node_modules/joi/lib/validator.js\");\nconst Values = __webpack_require__(/*! ./values */ \"(rsc)/./node_modules/joi/lib/values.js\");\nconst internals = {};\ninternals.Base = class {\n    constructor(type){\n        // Naming: public, _private, $_extension, $_mutate{action}\n        this.type = type;\n        this.$_root = null;\n        this._definition = {};\n        this._reset();\n    }\n    _reset() {\n        this._ids = new Modify.Ids();\n        this._preferences = null;\n        this._refs = new Ref.Manager();\n        this._cache = null;\n        this._valids = null;\n        this._invalids = null;\n        this._flags = {};\n        this._rules = [];\n        this._singleRules = new Map(); // The rule options passed for non-multi rules\n        this.$_terms = {}; // Hash of arrays of immutable objects (extended by other types)\n        this.$_temp = {\n            ruleset: null,\n            whens: {} // Runtime cache of generated whens\n        };\n    }\n    // Manifest\n    describe() {\n        Assert(typeof Manifest.describe === \"function\", \"Manifest functionality disabled\");\n        return Manifest.describe(this);\n    }\n    // Rules\n    allow(...values) {\n        Common.verifyFlat(values, \"allow\");\n        return this._values(values, \"_valids\");\n    }\n    alter(targets) {\n        Assert(targets && typeof targets === \"object\" && !Array.isArray(targets), \"Invalid targets argument\");\n        Assert(!this._inRuleset(), \"Cannot set alterations inside a ruleset\");\n        const obj = this.clone();\n        obj.$_terms.alterations = obj.$_terms.alterations || [];\n        for(const target in targets){\n            const adjuster = targets[target];\n            Assert(typeof adjuster === \"function\", \"Alteration adjuster for\", target, \"must be a function\");\n            obj.$_terms.alterations.push({\n                target,\n                adjuster\n            });\n        }\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n    artifact(id) {\n        Assert(id !== undefined, \"Artifact cannot be undefined\");\n        Assert(!this._cache, \"Cannot set an artifact with a rule cache\");\n        return this.$_setFlag(\"artifact\", id);\n    }\n    cast(to) {\n        Assert(to === false || typeof to === \"string\", \"Invalid to value\");\n        Assert(to === false || this._definition.cast[to], \"Type\", this.type, \"does not support casting to\", to);\n        return this.$_setFlag(\"cast\", to === false ? undefined : to);\n    }\n    default(value, options) {\n        return this._default(\"default\", value, options);\n    }\n    description(desc) {\n        Assert(desc && typeof desc === \"string\", \"Description must be a non-empty string\");\n        return this.$_setFlag(\"description\", desc);\n    }\n    empty(schema) {\n        const obj = this.clone();\n        if (schema !== undefined) {\n            schema = obj.$_compile(schema, {\n                override: false\n            });\n        }\n        return obj.$_setFlag(\"empty\", schema, {\n            clone: false\n        });\n    }\n    error(err) {\n        Assert(err, \"Missing error\");\n        Assert(err instanceof Error || typeof err === \"function\", \"Must provide a valid Error object or a function\");\n        return this.$_setFlag(\"error\", err);\n    }\n    example(example, options = {}) {\n        Assert(example !== undefined, \"Missing example\");\n        Common.assertOptions(options, [\n            \"override\"\n        ]);\n        return this._inner(\"examples\", example, {\n            single: true,\n            override: options.override\n        });\n    }\n    external(method, description) {\n        if (typeof method === \"object\") {\n            Assert(!description, \"Cannot combine options with description\");\n            description = method.description;\n            method = method.method;\n        }\n        Assert(typeof method === \"function\", \"Method must be a function\");\n        Assert(description === undefined || description && typeof description === \"string\", \"Description must be a non-empty string\");\n        return this._inner(\"externals\", {\n            method,\n            description\n        }, {\n            single: true\n        });\n    }\n    failover(value, options) {\n        return this._default(\"failover\", value, options);\n    }\n    forbidden() {\n        return this.presence(\"forbidden\");\n    }\n    id(id) {\n        if (!id) {\n            return this.$_setFlag(\"id\", undefined);\n        }\n        Assert(typeof id === \"string\", \"id must be a non-empty string\");\n        Assert(/^[^\\.]+$/.test(id), \"id cannot contain period character\");\n        return this.$_setFlag(\"id\", id);\n    }\n    invalid(...values) {\n        return this._values(values, \"_invalids\");\n    }\n    label(name) {\n        Assert(name && typeof name === \"string\", \"Label name must be a non-empty string\");\n        return this.$_setFlag(\"label\", name);\n    }\n    meta(meta) {\n        Assert(meta !== undefined, \"Meta cannot be undefined\");\n        return this._inner(\"metas\", meta, {\n            single: true\n        });\n    }\n    note(...notes) {\n        Assert(notes.length, \"Missing notes\");\n        for (const note of notes){\n            Assert(note && typeof note === \"string\", \"Notes must be non-empty strings\");\n        }\n        return this._inner(\"notes\", notes);\n    }\n    only(mode = true) {\n        Assert(typeof mode === \"boolean\", \"Invalid mode:\", mode);\n        return this.$_setFlag(\"only\", mode);\n    }\n    optional() {\n        return this.presence(\"optional\");\n    }\n    prefs(prefs) {\n        Assert(prefs, \"Missing preferences\");\n        Assert(prefs.context === undefined, \"Cannot override context\");\n        Assert(prefs.externals === undefined, \"Cannot override externals\");\n        Assert(prefs.warnings === undefined, \"Cannot override warnings\");\n        Assert(prefs.debug === undefined, \"Cannot override debug\");\n        Common.checkPreferences(prefs);\n        const obj = this.clone();\n        obj._preferences = Common.preferences(obj._preferences, prefs);\n        return obj;\n    }\n    presence(mode) {\n        Assert([\n            \"optional\",\n            \"required\",\n            \"forbidden\"\n        ].includes(mode), \"Unknown presence mode\", mode);\n        return this.$_setFlag(\"presence\", mode);\n    }\n    raw(enabled = true) {\n        return this.$_setFlag(\"result\", enabled ? \"raw\" : undefined);\n    }\n    result(mode) {\n        Assert([\n            \"raw\",\n            \"strip\"\n        ].includes(mode), \"Unknown result mode\", mode);\n        return this.$_setFlag(\"result\", mode);\n    }\n    required() {\n        return this.presence(\"required\");\n    }\n    strict(enabled) {\n        const obj = this.clone();\n        const convert = enabled === undefined ? false : !enabled;\n        obj._preferences = Common.preferences(obj._preferences, {\n            convert\n        });\n        return obj;\n    }\n    strip(enabled = true) {\n        return this.$_setFlag(\"result\", enabled ? \"strip\" : undefined);\n    }\n    tag(...tags) {\n        Assert(tags.length, \"Missing tags\");\n        for (const tag of tags){\n            Assert(tag && typeof tag === \"string\", \"Tags must be non-empty strings\");\n        }\n        return this._inner(\"tags\", tags);\n    }\n    unit(name) {\n        Assert(name && typeof name === \"string\", \"Unit name must be a non-empty string\");\n        return this.$_setFlag(\"unit\", name);\n    }\n    valid(...values) {\n        Common.verifyFlat(values, \"valid\");\n        const obj = this.allow(...values);\n        obj.$_setFlag(\"only\", !!obj._valids, {\n            clone: false\n        });\n        return obj;\n    }\n    when(condition, options) {\n        const obj = this.clone();\n        if (!obj.$_terms.whens) {\n            obj.$_terms.whens = [];\n        }\n        const when = Compile.when(obj, condition, options);\n        if (![\n            \"any\",\n            \"link\"\n        ].includes(obj.type)) {\n            const conditions = when.is ? [\n                when\n            ] : when.switch;\n            for (const item of conditions){\n                Assert(!item.then || item.then.type === \"any\" || item.then.type === obj.type, \"Cannot combine\", obj.type, \"with\", item.then && item.then.type);\n                Assert(!item.otherwise || item.otherwise.type === \"any\" || item.otherwise.type === obj.type, \"Cannot combine\", obj.type, \"with\", item.otherwise && item.otherwise.type);\n            }\n        }\n        obj.$_terms.whens.push(when);\n        return obj.$_mutateRebuild();\n    }\n    // Helpers\n    cache(cache) {\n        Assert(!this._inRuleset(), \"Cannot set caching inside a ruleset\");\n        Assert(!this._cache, \"Cannot override schema cache\");\n        Assert(this._flags.artifact === undefined, \"Cannot cache a rule with an artifact\");\n        const obj = this.clone();\n        obj._cache = cache || Cache.provider.provision();\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n    clone() {\n        const obj = Object.create(Object.getPrototypeOf(this));\n        return this._assign(obj);\n    }\n    concat(source) {\n        Assert(Common.isSchema(source), \"Invalid schema object\");\n        Assert(this.type === \"any\" || source.type === \"any\" || source.type === this.type, \"Cannot merge type\", this.type, \"with another type:\", source.type);\n        Assert(!this._inRuleset(), \"Cannot concatenate onto a schema with open ruleset\");\n        Assert(!source._inRuleset(), \"Cannot concatenate a schema with open ruleset\");\n        let obj = this.clone();\n        if (this.type === \"any\" && source.type !== \"any\") {\n            // Change obj to match source type\n            const tmpObj = source.clone();\n            for (const key of Object.keys(obj)){\n                if (key !== \"type\") {\n                    tmpObj[key] = obj[key];\n                }\n            }\n            obj = tmpObj;\n        }\n        obj._ids.concat(source._ids);\n        obj._refs.register(source, Ref.toSibling);\n        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;\n        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);\n        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);\n        // Remove unique rules present in source\n        for (const name of source._singleRules.keys()){\n            if (obj._singleRules.has(name)) {\n                obj._rules = obj._rules.filter((target)=>target.keep || target.name !== name);\n                obj._singleRules.delete(name);\n            }\n        }\n        // Rules\n        for (const test of source._rules){\n            if (!source._definition.rules[test.method].multi) {\n                obj._singleRules.set(test.name, test);\n            }\n            obj._rules.push(test);\n        }\n        // Flags\n        if (obj._flags.empty && source._flags.empty) {\n            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        } else if (source._flags.empty) {\n            obj._flags.empty = source._flags.empty;\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        } else {\n            Merge(obj._flags, source._flags);\n        }\n        // Terms\n        for(const key in source.$_terms){\n            const terms = source.$_terms[key];\n            if (!terms) {\n                if (!obj.$_terms[key]) {\n                    obj.$_terms[key] = terms;\n                }\n                continue;\n            }\n            if (!obj.$_terms[key]) {\n                obj.$_terms[key] = terms.slice();\n                continue;\n            }\n            obj.$_terms[key] = obj.$_terms[key].concat(terms);\n        }\n        // Tracing\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [\n                this,\n                source\n            ]);\n        }\n        // Rebuild\n        return obj.$_mutateRebuild();\n    }\n    extend(options) {\n        Assert(!options.base, \"Cannot extend type with another base\");\n        return Extend.type(this, options);\n    }\n    extract(path) {\n        path = Array.isArray(path) ? path : path.split(\".\");\n        return this._ids.reach(path);\n    }\n    fork(paths, adjuster) {\n        Assert(!this._inRuleset(), \"Cannot fork inside a ruleset\");\n        let obj = this; // eslint-disable-line consistent-this\n        for (let path of [].concat(paths)){\n            path = Array.isArray(path) ? path : path.split(\".\");\n            obj = obj._ids.fork(path, adjuster, obj);\n        }\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n    rule(options) {\n        const def = this._definition;\n        Common.assertOptions(options, Object.keys(def.modifiers));\n        Assert(this.$_temp.ruleset !== false, \"Cannot apply rules to empty ruleset or the last rule added does not support rule properties\");\n        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;\n        Assert(start >= 0 && start < this._rules.length, \"Cannot apply rules to empty ruleset\");\n        const obj = this.clone();\n        for(let i = start; i < obj._rules.length; ++i){\n            const original = obj._rules[i];\n            const rule = Clone(original);\n            for(const name in options){\n                def.modifiers[name](rule, options[name]);\n                Assert(rule.name === original.name, \"Cannot change rule name\");\n            }\n            obj._rules[i] = rule;\n            if (obj._singleRules.get(rule.name) === original) {\n                obj._singleRules.set(rule.name, rule);\n            }\n        }\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n    get ruleset() {\n        Assert(!this._inRuleset(), \"Cannot start a new ruleset without closing the previous one\");\n        const obj = this.clone();\n        obj.$_temp.ruleset = obj._rules.length;\n        return obj;\n    }\n    get $() {\n        return this.ruleset;\n    }\n    tailor(targets) {\n        targets = [].concat(targets);\n        Assert(!this._inRuleset(), \"Cannot tailor inside a ruleset\");\n        let obj = this; // eslint-disable-line consistent-this\n        if (this.$_terms.alterations) {\n            for (const { target, adjuster } of this.$_terms.alterations){\n                if (targets.includes(target)) {\n                    obj = adjuster(obj);\n                    Assert(Common.isSchema(obj), \"Alteration adjuster for\", target, \"failed to return a schema object\");\n                }\n            }\n        }\n        obj = obj.$_modify({\n            each: (item)=>item.tailor(targets),\n            ref: false\n        });\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n    tracer() {\n        return Trace.location ? Trace.location(this) : this; // $lab:coverage:ignore$\n    }\n    validate(value, options) {\n        return Validator.entry(value, this, options);\n    }\n    validateAsync(value, options) {\n        return Validator.entryAsync(value, this, options);\n    }\n    // Extensions\n    $_addRule(options) {\n        // Normalize rule\n        if (typeof options === \"string\") {\n            options = {\n                name: options\n            };\n        }\n        Assert(options && typeof options === \"object\", \"Invalid options\");\n        Assert(options.name && typeof options.name === \"string\", \"Invalid rule name\");\n        for(const key in options){\n            Assert(key[0] !== \"_\", \"Cannot set private rule properties\");\n        }\n        const rule = Object.assign({}, options); // Shallow cloned\n        rule._resolve = [];\n        rule.method = rule.method || rule.name;\n        const definition = this._definition.rules[rule.method];\n        const args = rule.args;\n        Assert(definition, \"Unknown rule\", rule.method);\n        // Args\n        const obj = this.clone();\n        if (args) {\n            Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, \"Invalid rule definition for\", this.type, rule.name);\n            for(const key in args){\n                let arg = args[key];\n                if (definition.argsByName) {\n                    const resolver = definition.argsByName.get(key);\n                    if (resolver.ref && Common.isResolvable(arg)) {\n                        rule._resolve.push(key);\n                        obj.$_mutateRegister(arg);\n                    } else {\n                        if (resolver.normalize) {\n                            arg = resolver.normalize(arg);\n                            args[key] = arg;\n                        }\n                        if (resolver.assert) {\n                            const error = Common.validateArg(arg, key, resolver);\n                            Assert(!error, error, \"or reference\");\n                        }\n                    }\n                }\n                if (arg === undefined) {\n                    delete args[key];\n                    continue;\n                }\n                args[key] = arg;\n            }\n        }\n        // Unique rules\n        if (!definition.multi) {\n            obj._ruleRemove(rule.name, {\n                clone: false\n            });\n            obj._singleRules.set(rule.name, rule);\n        }\n        if (obj.$_temp.ruleset === false) {\n            obj.$_temp.ruleset = null;\n        }\n        if (definition.priority) {\n            obj._rules.unshift(rule);\n        } else {\n            obj._rules.push(rule);\n        }\n        return obj;\n    }\n    $_compile(schema, options) {\n        return Compile.schema(this.$_root, schema, options);\n    }\n    $_createError(code, value, local, state, prefs, options = {}) {\n        const flags = options.flags !== false ? this._flags : {};\n        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;\n        return new Errors.Report(code, value, local, flags, messages, state, prefs);\n    }\n    $_getFlag(name) {\n        return this._flags[name];\n    }\n    $_getRule(name) {\n        return this._singleRules.get(name);\n    }\n    $_mapLabels(path) {\n        path = Array.isArray(path) ? path : path.split(\".\");\n        return this._ids.labels(path);\n    }\n    $_match(value, state, prefs, overrides) {\n        prefs = Object.assign({}, prefs); // Shallow cloned\n        prefs.abortEarly = true;\n        prefs._externals = false;\n        state.snapshot();\n        const result = !Validator.validate(value, this, state, prefs, overrides).errors;\n        state.restore();\n        return result;\n    }\n    $_modify(options) {\n        Common.assertOptions(options, [\n            \"each\",\n            \"once\",\n            \"ref\",\n            \"schema\"\n        ]);\n        return Modify.schema(this, options) || this;\n    }\n    $_mutateRebuild() {\n        Assert(!this._inRuleset(), \"Cannot add this rule inside a ruleset\");\n        this._refs.reset();\n        this._ids.reset();\n        const each = (item, { source, name, path, key })=>{\n            const family = this._definition[source][name] && this._definition[source][name].register;\n            if (family !== false) {\n                this.$_mutateRegister(item, {\n                    family,\n                    key\n                });\n            }\n        };\n        this.$_modify({\n            each\n        });\n        if (this._definition.rebuild) {\n            this._definition.rebuild(this);\n        }\n        this.$_temp.ruleset = false;\n        return this;\n    }\n    $_mutateRegister(schema, { family, key } = {}) {\n        this._refs.register(schema, family);\n        this._ids.register(schema, {\n            key\n        });\n    }\n    $_property(name) {\n        return this._definition.properties[name];\n    }\n    $_reach(path) {\n        return this._ids.reach(path);\n    }\n    $_rootReferences() {\n        return this._refs.roots();\n    }\n    $_setFlag(name, value, options = {}) {\n        Assert(name[0] === \"_\" || !this._inRuleset(), \"Cannot set flag inside a ruleset\");\n        const flag = this._definition.flags[name] || {};\n        if (DeepEqual(value, flag.default)) {\n            value = undefined;\n        }\n        if (DeepEqual(value, this._flags[name])) {\n            return this;\n        }\n        const obj = options.clone !== false ? this.clone() : this;\n        if (value !== undefined) {\n            obj._flags[name] = value;\n            obj.$_mutateRegister(value);\n        } else {\n            delete obj._flags[name];\n        }\n        if (name[0] !== \"_\") {\n            obj.$_temp.ruleset = false;\n        }\n        return obj;\n    }\n    $_parent(method, ...args) {\n        return this[method][Common.symbols.parent].call(this, ...args);\n    }\n    $_validate(value, state, prefs) {\n        return Validator.validate(value, this, state, prefs);\n    }\n    // Internals\n    _assign(target) {\n        target.type = this.type;\n        target.$_root = this.$_root;\n        target.$_temp = Object.assign({}, this.$_temp);\n        target.$_temp.whens = {};\n        target._ids = this._ids.clone();\n        target._preferences = this._preferences;\n        target._valids = this._valids && this._valids.clone();\n        target._invalids = this._invalids && this._invalids.clone();\n        target._rules = this._rules.slice();\n        target._singleRules = Clone(this._singleRules, {\n            shallow: true\n        });\n        target._refs = this._refs.clone();\n        target._flags = Object.assign({}, this._flags);\n        target._cache = null;\n        target.$_terms = {};\n        for(const key in this.$_terms){\n            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;\n        }\n        // Backwards compatibility\n        target.$_super = {};\n        for(const override in this.$_super){\n            target.$_super[override] = this._super[override].bind(target);\n        }\n        return target;\n    }\n    _bare() {\n        const obj = this.clone();\n        obj._reset();\n        const terms = obj._definition.terms;\n        for(const name in terms){\n            const term = terms[name];\n            obj.$_terms[name] = term.init;\n        }\n        return obj.$_mutateRebuild();\n    }\n    _default(flag, value, options = {}) {\n        Common.assertOptions(options, \"literal\");\n        Assert(value !== undefined, \"Missing\", flag, \"value\");\n        Assert(typeof value === \"function\" || !options.literal, \"Only function value supports literal option\");\n        if (typeof value === \"function\" && options.literal) {\n            value = {\n                [Common.symbols.literal]: true,\n                literal: value\n            };\n        }\n        const obj = this.$_setFlag(flag, value);\n        return obj;\n    }\n    _generate(value, state, prefs) {\n        if (!this.$_terms.whens) {\n            return {\n                schema: this\n            };\n        }\n        // Collect matching whens\n        const whens = [];\n        const ids = [];\n        for(let i = 0; i < this.$_terms.whens.length; ++i){\n            const when = this.$_terms.whens[i];\n            if (when.concat) {\n                whens.push(when.concat);\n                ids.push(`${i}.concat`);\n                continue;\n            }\n            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;\n            const tests = when.is ? [\n                when\n            ] : when.switch;\n            const before = ids.length;\n            for(let j = 0; j < tests.length; ++j){\n                const { is, then, otherwise } = tests[j];\n                const baseId = `${i}${when.switch ? \".\" + j : \"\"}`;\n                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {\n                    if (then) {\n                        const localState = state.localize([\n                            ...state.path,\n                            `${baseId}.then`\n                        ], state.ancestors, state.schemas);\n                        const { schema: generated, id } = then._generate(value, localState, prefs);\n                        whens.push(generated);\n                        ids.push(`${baseId}.then${id ? `(${id})` : \"\"}`);\n                        break;\n                    }\n                } else if (otherwise) {\n                    const localState = state.localize([\n                        ...state.path,\n                        `${baseId}.otherwise`\n                    ], state.ancestors, state.schemas);\n                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);\n                    whens.push(generated);\n                    ids.push(`${baseId}.otherwise${id ? `(${id})` : \"\"}`);\n                    break;\n                }\n            }\n            if (when.break && ids.length > before) {\n                break;\n            }\n        }\n        // Check cache\n        const id = ids.join(\", \");\n        state.mainstay.tracer.debug(state, \"rule\", \"when\", id);\n        if (!id) {\n            return {\n                schema: this\n            };\n        }\n        if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {\n            return {\n                schema: this.$_temp.whens[id],\n                id\n            };\n        }\n        // Generate dynamic schema\n        let obj = this; // eslint-disable-line consistent-this\n        if (this._definition.generate) {\n            obj = this._definition.generate(this, value, state, prefs);\n        }\n        // Apply whens\n        for (const when of whens){\n            obj = obj.concat(when);\n        }\n        // Tracing\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [\n                this,\n                ...whens\n            ]);\n        }\n        // Cache result\n        this.$_temp.whens[id] = obj;\n        return {\n            schema: obj,\n            id\n        };\n    }\n    _inner(type, values, options = {}) {\n        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);\n        const obj = this.clone();\n        if (!obj.$_terms[type] || options.override) {\n            obj.$_terms[type] = [];\n        }\n        if (options.single) {\n            obj.$_terms[type].push(values);\n        } else {\n            obj.$_terms[type].push(...values);\n        }\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n    _inRuleset() {\n        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;\n    }\n    _ruleRemove(name, options = {}) {\n        if (!this._singleRules.has(name)) {\n            return this;\n        }\n        const obj = options.clone !== false ? this.clone() : this;\n        obj._singleRules.delete(name);\n        const filtered = [];\n        for(let i = 0; i < obj._rules.length; ++i){\n            const test = obj._rules[i];\n            if (test.name === name && !test.keep) {\n                if (obj._inRuleset() && i < obj.$_temp.ruleset) {\n                    --obj.$_temp.ruleset;\n                }\n                continue;\n            }\n            filtered.push(test);\n        }\n        obj._rules = filtered;\n        return obj;\n    }\n    _values(values, key) {\n        Common.verifyFlat(values, key.slice(1, -1));\n        const obj = this.clone();\n        const override = values[0] === Common.symbols.override;\n        if (override) {\n            values = values.slice(1);\n        }\n        if (!obj[key] && values.length) {\n            obj[key] = new Values();\n        } else if (override) {\n            obj[key] = values.length ? new Values() : null;\n            obj.$_mutateRebuild();\n        }\n        if (!obj[key]) {\n            return obj;\n        }\n        if (override) {\n            obj[key].override();\n        }\n        for (const value of values){\n            Assert(value !== undefined, \"Cannot call allow/valid/invalid with undefined\");\n            Assert(value !== Common.symbols.override, \"Override must be the first value\");\n            const other = key === \"_invalids\" ? \"_valids\" : \"_invalids\";\n            if (obj[other]) {\n                obj[other].remove(value);\n                if (!obj[other].length) {\n                    Assert(key === \"_valids\" || !obj._flags.only, \"Setting invalid value\", value, \"leaves schema rejecting all values due to previous valid rule\");\n                    obj[other] = null;\n                }\n            }\n            obj[key].add(value, obj._refs);\n        }\n        return obj;\n    }\n};\ninternals.Base.prototype[Common.symbols.any] = {\n    version: Common.version,\n    compile: Compile.compile,\n    root: \"$_root\"\n};\ninternals.Base.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects (must be on prototype)\n// Aliases\ninternals.Base.prototype.deny = internals.Base.prototype.invalid;\ninternals.Base.prototype.disallow = internals.Base.prototype.invalid;\ninternals.Base.prototype.equal = internals.Base.prototype.valid;\ninternals.Base.prototype.exist = internals.Base.prototype.required;\ninternals.Base.prototype.not = internals.Base.prototype.invalid;\ninternals.Base.prototype.options = internals.Base.prototype.prefs;\ninternals.Base.prototype.preferences = internals.Base.prototype.prefs;\nmodule.exports = new internals.Base();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2xFekYsVUFBVUMsSUFBSSxDQUFDNk8sU0FBUyxDQUFDVSxHQUFHLEdBQUd4UCxVQUFVQyxJQUFJLENBQUM2TyxTQUFTLENBQUMxSyxPQUFPO0FBQy9EcEUsVUFBVUMsSUFBSSxDQUFDNk8sU0FBUyxDQUFDL0wsT0FBTyxHQUFHL0MsVUFBVUMsSUFBSSxDQUFDNk8sU0FBUyxDQUFDaEssS0FBSztBQUNqRTlFLFVBQVVDLElBQUksQ0FBQzZPLFNBQVMsQ0FBQzFKLFdBQVcsR0FBR3BGLFVBQVVDLElBQUksQ0FBQzZPLFNBQVMsQ0FBQ2hLLEtBQUs7QUFHckUySyxPQUFPQyxPQUFPLEdBQUcsSUFBSTFQLFVBQVVDLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL2Jhc2UuanM/NGQwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL21lcmdlJyk7XG5cbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuY29uc3QgTWFuaWZlc3QgPSByZXF1aXJlKCcuL21hbmlmZXN0Jyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcbmNvbnN0IE1vZGlmeSA9IHJlcXVpcmUoJy4vbW9kaWZ5Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlJyk7XG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuY29uc3QgVmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuQmFzZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcblxuICAgICAgICAvLyBOYW1pbmc6IHB1YmxpYywgX3ByaXZhdGUsICRfZXh0ZW5zaW9uLCAkX211dGF0ZXthY3Rpb259XG5cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgICAgICB0aGlzLiRfcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSB7fTtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICB9XG5cbiAgICBfcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5faWRzID0gbmV3IE1vZGlmeS5JZHMoKTtcbiAgICAgICAgdGhpcy5fcHJlZmVyZW5jZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWZzID0gbmV3IFJlZi5NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl92YWxpZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2luZ2xlUnVsZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAvLyBUaGUgcnVsZSBvcHRpb25zIHBhc3NlZCBmb3Igbm9uLW11bHRpIHJ1bGVzXG5cbiAgICAgICAgdGhpcy4kX3Rlcm1zID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXNoIG9mIGFycmF5cyBvZiBpbW11dGFibGUgb2JqZWN0cyAoZXh0ZW5kZWQgYnkgb3RoZXIgdHlwZXMpXG5cbiAgICAgICAgdGhpcy4kX3RlbXAgPSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW50aW1lIHN0YXRlIChub3QgY2xvbmVkKVxuICAgICAgICAgICAgcnVsZXNldDogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGw6IHVzZSBsYXN0LCBmYWxzZTogZXJyb3IsIG51bWJlcjogc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgIHdoZW5zOiB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW50aW1lIGNhY2hlIG9mIGdlbmVyYXRlZCB3aGVuc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1hbmlmZXN0XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIE1hbmlmZXN0LmRlc2NyaWJlID09PSAnZnVuY3Rpb24nLCAnTWFuaWZlc3QgZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gTWFuaWZlc3QuZGVzY3JpYmUodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gUnVsZXNcblxuICAgIGFsbG93KC4uLnZhbHVlcykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ2FsbG93Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXModmFsdWVzLCAnX3ZhbGlkcycpO1xuICAgIH1cblxuICAgIGFsdGVyKHRhcmdldHMpIHtcblxuICAgICAgICBBc3NlcnQodGFyZ2V0cyAmJiB0eXBlb2YgdGFyZ2V0cyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0cyksICdJbnZhbGlkIHRhcmdldHMgYXJndW1lbnQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgYWx0ZXJhdGlvbnMgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMgPSBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucyB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgaW4gdGFyZ2V0cykge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZXIgPSB0YXJnZXRzW3RhcmdldF07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGFkanVzdGVyID09PSAnZnVuY3Rpb24nLCAnQWx0ZXJhdGlvbiBhZGp1c3RlciBmb3InLCB0YXJnZXQsICdtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zLnB1c2goeyB0YXJnZXQsIGFkanVzdGVyIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYXJ0aWZhY3QoaWQpIHtcblxuICAgICAgICBBc3NlcnQoaWQgIT09IHVuZGVmaW5lZCwgJ0FydGlmYWN0IGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9jYWNoZSwgJ0Nhbm5vdCBzZXQgYW4gYXJ0aWZhY3Qgd2l0aCBhIHJ1bGUgY2FjaGUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2FydGlmYWN0JywgaWQpO1xuICAgIH1cblxuICAgIGNhc3QodG8pIHtcblxuICAgICAgICBBc3NlcnQodG8gPT09IGZhbHNlIHx8IHR5cGVvZiB0byA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHRvIHZhbHVlJyk7XG4gICAgICAgIEFzc2VydCh0byA9PT0gZmFsc2UgfHwgdGhpcy5fZGVmaW5pdGlvbi5jYXN0W3RvXSwgJ1R5cGUnLCB0aGlzLnR5cGUsICdkb2VzIG5vdCBzdXBwb3J0IGNhc3RpbmcgdG8nLCB0byk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdjYXN0JywgdG8gPT09IGZhbHNlID8gdW5kZWZpbmVkIDogdG8pO1xuICAgIH1cblxuICAgIGRlZmF1bHQodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdCgnZGVmYXVsdCcsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbihkZXNjKSB7XG5cbiAgICAgICAgQXNzZXJ0KGRlc2MgJiYgdHlwZW9mIGRlc2MgPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Rlc2NyaXB0aW9uJywgZGVzYyk7XG4gICAgfVxuXG4gICAgZW1wdHkoc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NoZW1hID0gb2JqLiRfY29tcGlsZShzY2hlbWEsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX3NldEZsYWcoJ2VtcHR5Jywgc2NoZW1hLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBlcnJvcihlcnIpIHtcblxuICAgICAgICBBc3NlcnQoZXJyLCAnTWlzc2luZyBlcnJvcicpO1xuICAgICAgICBBc3NlcnQoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJywgJ011c3QgcHJvdmlkZSBhIHZhbGlkIEVycm9yIG9iamVjdCBvciBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdlcnJvcicsIGVycik7XG4gICAgfVxuXG4gICAgZXhhbXBsZShleGFtcGxlLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQoZXhhbXBsZSAhPT0gdW5kZWZpbmVkLCAnTWlzc2luZyBleGFtcGxlJyk7XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnb3ZlcnJpZGUnXSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdleGFtcGxlcycsIGV4YW1wbGUsIHsgc2luZ2xlOiB0cnVlLCBvdmVycmlkZTogb3B0aW9ucy5vdmVycmlkZSB9KTtcbiAgICB9XG5cbiAgICBleHRlcm5hbChtZXRob2QsIGRlc2NyaXB0aW9uKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBBc3NlcnQoIWRlc2NyaXB0aW9uLCAnQ2Fubm90IGNvbWJpbmUgb3B0aW9ucyB3aXRoIGRlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IG1ldGhvZC5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZC5tZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJywgJ01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgQXNzZXJ0KGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRpb24gJiYgdHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJywgJ0Rlc2NyaXB0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdleHRlcm5hbHMnLCB7IG1ldGhvZCwgZGVzY3JpcHRpb24gfSwgeyBzaW5nbGU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgZmFpbG92ZXIodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdCgnZmFpbG92ZXInLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZm9yYmlkZGVuKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdmb3JiaWRkZW4nKTtcbiAgICB9XG5cbiAgICBpZChpZCkge1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaWQnLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBpZCA9PT0gJ3N0cmluZycsICdpZCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICBBc3NlcnQoL15bXlxcLl0rJC8udGVzdChpZCksICdpZCBjYW5ub3QgY29udGFpbiBwZXJpb2QgY2hhcmFjdGVyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpZCcsIGlkKTtcbiAgICB9XG5cbiAgICBpbnZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXModmFsdWVzLCAnX2ludmFsaWRzJyk7XG4gICAgfVxuXG4gICAgbGFiZWwobmFtZSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ0xhYmVsIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2xhYmVsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgbWV0YShtZXRhKSB7XG5cbiAgICAgICAgQXNzZXJ0KG1ldGEgIT09IHVuZGVmaW5lZCwgJ01ldGEgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignbWV0YXMnLCBtZXRhLCB7IHNpbmdsZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBub3RlKC4uLm5vdGVzKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5vdGVzLmxlbmd0aCwgJ01pc3Npbmcgbm90ZXMnKTtcbiAgICAgICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVzKSB7XG4gICAgICAgICAgICBBc3NlcnQobm90ZSAmJiB0eXBlb2Ygbm90ZSA9PT0gJ3N0cmluZycsICdOb3RlcyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ25vdGVzJywgbm90ZXMpO1xuICAgIH1cblxuICAgIG9ubHkobW9kZSA9IHRydWUpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGUgPT09ICdib29sZWFuJywgJ0ludmFsaWQgbW9kZTonLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ29ubHknLCBtb2RlKTtcbiAgICB9XG5cbiAgICBvcHRpb25hbCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgnb3B0aW9uYWwnKTtcbiAgICB9XG5cbiAgICBwcmVmcyhwcmVmcykge1xuXG4gICAgICAgIEFzc2VydChwcmVmcywgJ01pc3NpbmcgcHJlZmVyZW5jZXMnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmNvbnRleHQgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBjb250ZXh0Jyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5leHRlcm5hbHMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBleHRlcm5hbHMnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLndhcm5pbmdzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgd2FybmluZ3MnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmRlYnVnID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgZGVidWcnKTtcblxuICAgICAgICBDb21tb24uY2hlY2tQcmVmZXJlbmNlcyhwcmVmcyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHByZWZzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBwcmVzZW5jZShtb2RlKSB7XG5cbiAgICAgICAgQXNzZXJ0KFsnb3B0aW9uYWwnLCAncmVxdWlyZWQnLCAnZm9yYmlkZGVuJ10uaW5jbHVkZXMobW9kZSksICdVbmtub3duIHByZXNlbmNlIG1vZGUnLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3ByZXNlbmNlJywgbW9kZSk7XG4gICAgfVxuXG4gICAgcmF3KGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBlbmFibGVkID8gJ3JhdycgOiB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJlc3VsdChtb2RlKSB7XG5cbiAgICAgICAgQXNzZXJ0KFsncmF3JywgJ3N0cmlwJ10uaW5jbHVkZXMobW9kZSksICdVbmtub3duIHJlc3VsdCBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBtb2RlKTtcbiAgICB9XG5cbiAgICByZXF1aXJlZCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgncmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBzdHJpY3QoZW5hYmxlZCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBjb252ZXJ0ID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAhZW5hYmxlZDtcbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IENvbW1vbi5wcmVmZXJlbmNlcyhvYmouX3ByZWZlcmVuY2VzLCB7IGNvbnZlcnQgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RyaXAoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIGVuYWJsZWQgPyAnc3RyaXAnIDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICB0YWcoLi4udGFncykge1xuXG4gICAgICAgIEFzc2VydCh0YWdzLmxlbmd0aCwgJ01pc3NpbmcgdGFncycpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICBBc3NlcnQodGFnICYmIHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnLCAnVGFncyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ3RhZ3MnLCB0YWdzKTtcbiAgICB9XG5cbiAgICB1bml0KG5hbWUpIHtcblxuICAgICAgICBBc3NlcnQobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdVbml0IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3VuaXQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICd2YWxpZCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuYWxsb3coLi4udmFsdWVzKTtcbiAgICAgICAgb2JqLiRfc2V0RmxhZygnb25seScsICEhb2JqLl92YWxpZHMsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHdoZW4oY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICghb2JqLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aGVuID0gQ29tcGlsZS53aGVuKG9iaiwgY29uZGl0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFbJ2FueScsICdsaW5rJ10uaW5jbHVkZXMob2JqLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIWl0ZW0udGhlbiB8fCBpdGVtLnRoZW4udHlwZSA9PT0gJ2FueScgfHwgaXRlbS50aGVuLnR5cGUgPT09IG9iai50eXBlLCAnQ2Fubm90IGNvbWJpbmUnLCBvYmoudHlwZSwgJ3dpdGgnLCBpdGVtLnRoZW4gJiYgaXRlbS50aGVuLnR5cGUpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghaXRlbS5vdGhlcndpc2UgfHwgaXRlbS5vdGhlcndpc2UudHlwZSA9PT0gJ2FueScgfHwgaXRlbS5vdGhlcndpc2UudHlwZSA9PT0gb2JqLnR5cGUsICdDYW5ub3QgY29tYmluZScsIG9iai50eXBlLCAnd2l0aCcsIGl0ZW0ub3RoZXJ3aXNlICYmIGl0ZW0ub3RoZXJ3aXNlLnR5cGUpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZXJtcy53aGVucy5wdXNoKHdoZW4pO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIC8vIEhlbHBlcnNcblxuICAgIGNhY2hlKGNhY2hlKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgY2FjaGluZyBpbnNpZGUgYSBydWxlc2V0Jyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5fY2FjaGUsICdDYW5ub3Qgb3ZlcnJpZGUgc2NoZW1hIGNhY2hlJyk7XG4gICAgICAgIEFzc2VydCh0aGlzLl9mbGFncy5hcnRpZmFjdCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhY2hlIGEgcnVsZSB3aXRoIGFuIGFydGlmYWN0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2NhY2hlID0gY2FjaGUgfHwgQ2FjaGUucHJvdmlkZXIucHJvdmlzaW9uKCk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihvYmopO1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSksICdJbnZhbGlkIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgQXNzZXJ0KHRoaXMudHlwZSA9PT0gJ2FueScgfHwgc291cmNlLnR5cGUgPT09ICdhbnknIHx8IHNvdXJjZS50eXBlID09PSB0aGlzLnR5cGUsICdDYW5ub3QgbWVyZ2UgdHlwZScsIHRoaXMudHlwZSwgJ3dpdGggYW5vdGhlciB0eXBlOicsIHNvdXJjZS50eXBlKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBjb25jYXRlbmF0ZSBvbnRvIGEgc2NoZW1hIHdpdGggb3BlbiBydWxlc2V0Jyk7XG4gICAgICAgIEFzc2VydCghc291cmNlLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBjb25jYXRlbmF0ZSBhIHNjaGVtYSB3aXRoIG9wZW4gcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2FueScgJiZcbiAgICAgICAgICAgIHNvdXJjZS50eXBlICE9PSAnYW55Jykge1xuXG4gICAgICAgICAgICAvLyBDaGFuZ2Ugb2JqIHRvIG1hdGNoIHNvdXJjZSB0eXBlXG5cbiAgICAgICAgICAgIGNvbnN0IHRtcE9iaiA9IHNvdXJjZS5jbG9uZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICB0bXBPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqID0gdG1wT2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9pZHMuY29uY2F0KHNvdXJjZS5faWRzKTtcbiAgICAgICAgb2JqLl9yZWZzLnJlZ2lzdGVyKHNvdXJjZSwgUmVmLnRvU2libGluZyk7XG5cbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IG9iai5fcHJlZmVyZW5jZXMgPyBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgc291cmNlLl9wcmVmZXJlbmNlcykgOiBzb3VyY2UuX3ByZWZlcmVuY2VzO1xuICAgICAgICBvYmouX3ZhbGlkcyA9IFZhbHVlcy5tZXJnZShvYmouX3ZhbGlkcywgc291cmNlLl92YWxpZHMsIHNvdXJjZS5faW52YWxpZHMpO1xuICAgICAgICBvYmouX2ludmFsaWRzID0gVmFsdWVzLm1lcmdlKG9iai5faW52YWxpZHMsIHNvdXJjZS5faW52YWxpZHMsIHNvdXJjZS5fdmFsaWRzKTtcblxuICAgICAgICAvLyBSZW1vdmUgdW5pcXVlIHJ1bGVzIHByZXNlbnQgaW4gc291cmNlXG5cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHNvdXJjZS5fc2luZ2xlUnVsZXMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAob2JqLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvYmouX3J1bGVzID0gb2JqLl9ydWxlcy5maWx0ZXIoKHRhcmdldCkgPT4gdGFyZ2V0LmtlZXAgfHwgdGFyZ2V0Lm5hbWUgIT09IG5hbWUpO1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVsZXNcblxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2Ygc291cmNlLl9ydWxlcykge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX2RlZmluaXRpb24ucnVsZXNbdGVzdC5tZXRob2RdLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQodGVzdC5uYW1lLCB0ZXN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9ydWxlcy5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmxhZ3NcblxuICAgICAgICBpZiAob2JqLl9mbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgc291cmNlLl9mbGFncy5lbXB0eSkge1xuXG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gb2JqLl9mbGFncy5lbXB0eS5jb25jYXQoc291cmNlLl9mbGFncy5lbXB0eSk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgTWVyZ2Uob2JqLl9mbGFncywgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5fZmxhZ3MuZW1wdHkpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3MuZW1wdHkgPSBzb3VyY2UuX2ZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVybXNcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UuJF90ZXJtcykge1xuICAgICAgICAgICAgY29uc3QgdGVybXMgPSBzb3VyY2UuJF90ZXJtc1trZXldO1xuICAgICAgICAgICAgaWYgKCF0ZXJtcykge1xuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gdGVybXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXNba2V5XSkge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zW2tleV0gPSB0ZXJtcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gb2JqLiRfdGVybXNba2V5XS5jb25jYXQodGVybXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2luZ1xuXG4gICAgICAgIGlmICh0aGlzLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLiRfcm9vdC5fdHJhY2VyLl9jb21iaW5lKG9iaiwgW3RoaXMsIHNvdXJjZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVidWlsZFxuXG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgZXh0ZW5kKG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYmFzZSwgJ0Nhbm5vdCBleHRlbmQgdHlwZSB3aXRoIGFub3RoZXIgYmFzZScpO1xuXG4gICAgICAgIHJldHVybiBFeHRlbmQudHlwZSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBleHRyYWN0KHBhdGgpIHtcblxuICAgICAgICBwYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHMucmVhY2gocGF0aCk7XG4gICAgfVxuXG4gICAgZm9yayhwYXRocywgYWRqdXN0ZXIpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGZvcmsgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgW10uY29uY2F0KHBhdGhzKSkge1xuICAgICAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgb2JqID0gb2JqLl9pZHMuZm9yayhwYXRoLCBhZGp1c3Rlciwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJ1bGUob3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZmluaXRpb247XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIE9iamVjdC5rZXlzKGRlZi5tb2RpZmllcnMpKTtcblxuICAgICAgICBBc3NlcnQodGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2UsICdDYW5ub3QgYXBwbHkgcnVsZXMgdG8gZW1wdHkgcnVsZXNldCBvciB0aGUgbGFzdCBydWxlIGFkZGVkIGRvZXMgbm90IHN1cHBvcnQgcnVsZSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy4kX3RlbXAucnVsZXNldCA9PT0gbnVsbCA/IHRoaXMuX3J1bGVzLmxlbmd0aCAtIDEgOiB0aGlzLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICBBc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMuX3J1bGVzLmxlbmd0aCwgJ0Nhbm5vdCBhcHBseSBydWxlcyB0byBlbXB0eSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG9iai5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gb2JqLl9ydWxlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBDbG9uZShvcmlnaW5hbCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVmLm1vZGlmaWVyc1tuYW1lXShydWxlLCBvcHRpb25zW25hbWVdKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQocnVsZS5uYW1lID09PSBvcmlnaW5hbC5uYW1lLCAnQ2Fubm90IGNoYW5nZSBydWxlIG5hbWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9ydWxlc1tpXSA9IHJ1bGU7XG5cbiAgICAgICAgICAgIGlmIChvYmouX3NpbmdsZVJ1bGVzLmdldChydWxlLm5hbWUpID09PSBvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBnZXQgcnVsZXNldCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHN0YXJ0IGEgbmV3IHJ1bGVzZXQgd2l0aG91dCBjbG9zaW5nIHRoZSBwcmV2aW91cyBvbmUnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IG9iai5fcnVsZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGdldCAkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzZXQ7XG4gICAgfVxuXG4gICAgdGFpbG9yKHRhcmdldHMpIHtcblxuICAgICAgICB0YXJnZXRzID0gW10uY29uY2F0KHRhcmdldHMpO1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgdGFpbG9yIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG5cbiAgICAgICAgaWYgKHRoaXMuJF90ZXJtcy5hbHRlcmF0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgYWRqdXN0ZXIgfSBvZiB0aGlzLiRfdGVybXMuYWx0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGFkanVzdGVyKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEob2JqKSwgJ0FsdGVyYXRpb24gYWRqdXN0ZXIgZm9yJywgdGFyZ2V0LCAnZmFpbGVkIHRvIHJldHVybiBhIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBvYmouJF9tb2RpZnkoeyBlYWNoOiAoaXRlbSkgPT4gaXRlbS50YWlsb3IodGFyZ2V0cyksIHJlZjogZmFsc2UgfSk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIHRyYWNlcigpIHtcblxuICAgICAgICByZXR1cm4gVHJhY2UubG9jYXRpb24gPyBUcmFjZS5sb2NhdGlvbih0aGlzKSA6IHRoaXM7ICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIH1cblxuICAgIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci5lbnRyeSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVBc3luYyh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBWYWxpZGF0b3IuZW50cnlBc3luYyh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9uc1xuXG4gICAgJF9hZGRSdWxlKG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBOb3JtYWxpemUgcnVsZVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9ucycpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5uYW1lICYmIHR5cGVvZiBvcHRpb25zLm5hbWUgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBydWxlIG5hbWUnKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBBc3NlcnQoa2V5WzBdICE9PSAnXycsICdDYW5ub3Qgc2V0IHByaXZhdGUgcnVsZSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBydWxlID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBydWxlLl9yZXNvbHZlID0gW107XG4gICAgICAgIHJ1bGUubWV0aG9kID0gcnVsZS5tZXRob2QgfHwgcnVsZS5uYW1lO1xuXG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLl9kZWZpbml0aW9uLnJ1bGVzW3J1bGUubWV0aG9kXTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJ1bGUuYXJncztcblxuICAgICAgICBBc3NlcnQoZGVmaW5pdGlvbiwgJ1Vua25vd24gcnVsZScsIHJ1bGUubWV0aG9kKTtcblxuICAgICAgICAvLyBBcmdzXG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICBBc3NlcnQoT2JqZWN0LmtleXMoYXJncykubGVuZ3RoID09PSAxIHx8IE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA9PT0gdGhpcy5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm5hbWVdLmFyZ3MubGVuZ3RoLCAnSW52YWxpZCBydWxlIGRlZmluaXRpb24gZm9yJywgdGhpcy50eXBlLCBydWxlLm5hbWUpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmFyZ3NCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBkZWZpbml0aW9uLmFyZ3NCeU5hbWUuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyLnJlZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmlzUmVzb2x2YWJsZShhcmcpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuX3Jlc29sdmUucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSByZXNvbHZlci5ub3JtYWxpemUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5hc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IENvbW1vbi52YWxpZGF0ZUFyZyhhcmcsIGtleSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCghZXJyb3IsIGVycm9yLCAnb3IgcmVmZXJlbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJnc1trZXldID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5pcXVlIHJ1bGVzXG5cbiAgICAgICAgaWYgKCFkZWZpbml0aW9uLm11bHRpKSB7XG4gICAgICAgICAgICBvYmouX3J1bGVSZW1vdmUocnVsZS5uYW1lLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLiRfdGVtcC5ydWxlc2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnVuc2hpZnQocnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouX3J1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgICRfY29tcGlsZShzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gQ29tcGlsZS5zY2hlbWEodGhpcy4kX3Jvb3QsIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgJF9jcmVhdGVFcnJvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIHN0YXRlLCBwcmVmcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRpb25zLmZsYWdzICE9PSBmYWxzZSA/IHRoaXMuX2ZsYWdzIDoge307XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcyA/IE1lc3NhZ2VzLm1lcmdlKHRoaXMuX2RlZmluaXRpb24ubWVzc2FnZXMsIG9wdGlvbnMubWVzc2FnZXMpIDogdGhpcy5fZGVmaW5pdGlvbi5tZXNzYWdlcztcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcnMuUmVwb3J0KGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgICRfZ2V0RmxhZyhuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzW25hbWVdO1xuICAgIH1cblxuICAgICRfZ2V0UnVsZShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZVJ1bGVzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAkX21hcExhYmVscyhwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5faWRzLmxhYmVscyhwYXRoKTtcbiAgICB9XG5cbiAgICAkX21hdGNoKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcykge1xuXG4gICAgICAgIHByZWZzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJlZnMpOyAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBwcmVmcy5hYm9ydEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgcHJlZnMuX2V4dGVybmFscyA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXRlLnNuYXBzaG90KCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICFWYWxpZGF0b3IudmFsaWRhdGUodmFsdWUsIHRoaXMsIHN0YXRlLCBwcmVmcywgb3ZlcnJpZGVzKS5lcnJvcnM7XG4gICAgICAgIHN0YXRlLnJlc3RvcmUoKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgICRfbW9kaWZ5KG9wdGlvbnMpIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2VhY2gnLCAnb25jZScsICdyZWYnLCAnc2NoZW1hJ10pO1xuICAgICAgICByZXR1cm4gTW9kaWZ5LnNjaGVtYSh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIH1cblxuICAgICRfbXV0YXRlUmVidWlsZCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGFkZCB0aGlzIHJ1bGUgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIHRoaXMuX3JlZnMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5faWRzLnJlc2V0KCk7XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pID0+IHtcblxuICAgICAgICAgICAgY29uc3QgZmFtaWx5ID0gdGhpcy5fZGVmaW5pdGlvbltzb3VyY2VdW25hbWVdICYmIHRoaXMuX2RlZmluaXRpb25bc291cmNlXVtuYW1lXS5yZWdpc3RlcjtcbiAgICAgICAgICAgIGlmIChmYW1pbHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kX211dGF0ZVJlZ2lzdGVyKGl0ZW0sIHsgZmFtaWx5LCBrZXkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy4kX21vZGlmeSh7IGVhY2ggfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluaXRpb24ucmVidWlsZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVmaW5pdGlvbi5yZWJ1aWxkKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAkX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSwgeyBmYW1pbHksIGtleSB9ID0ge30pIHtcblxuICAgICAgICB0aGlzLl9yZWZzLnJlZ2lzdGVyKHNjaGVtYSwgZmFtaWx5KTtcbiAgICAgICAgdGhpcy5faWRzLnJlZ2lzdGVyKHNjaGVtYSwgeyBrZXkgfSk7XG4gICAgfVxuXG4gICAgJF9wcm9wZXJ0eShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24ucHJvcGVydGllc1tuYW1lXTtcbiAgICB9XG5cbiAgICAkX3JlYWNoKHBhdGgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5faWRzLnJlYWNoKHBhdGgpO1xuICAgIH1cblxuICAgICRfcm9vdFJlZmVyZW5jZXMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZnMucm9vdHMoKTtcbiAgICB9XG5cbiAgICAkX3NldEZsYWcobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lWzBdID09PSAnXycgfHwgIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHNldCBmbGFnIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBmbGFnID0gdGhpcy5fZGVmaW5pdGlvbi5mbGFnc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgaWYgKERlZXBFcXVhbCh2YWx1ZSwgZmxhZy5kZWZhdWx0KSkge1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRGVlcEVxdWFsKHZhbHVlLCB0aGlzLl9mbGFnc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqLl9mbGFnc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAkX3BhcmVudChtZXRob2QsIC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdW0NvbW1vbi5zeW1ib2xzLnBhcmVudF0uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICAkX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCB0aGlzLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIC8vIEludGVybmFsc1xuXG4gICAgX2Fzc2lnbih0YXJnZXQpIHtcblxuICAgICAgICB0YXJnZXQudHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgICB0YXJnZXQuJF9yb290ID0gdGhpcy4kX3Jvb3Q7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVtcCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJF90ZW1wKTtcbiAgICAgICAgdGFyZ2V0LiRfdGVtcC53aGVucyA9IHt9O1xuXG4gICAgICAgIHRhcmdldC5faWRzID0gdGhpcy5faWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fcHJlZmVyZW5jZXMgPSB0aGlzLl9wcmVmZXJlbmNlcztcbiAgICAgICAgdGFyZ2V0Ll92YWxpZHMgPSB0aGlzLl92YWxpZHMgJiYgdGhpcy5fdmFsaWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5faW52YWxpZHMgPSB0aGlzLl9pbnZhbGlkcyAmJiB0aGlzLl9pbnZhbGlkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX3J1bGVzID0gdGhpcy5fcnVsZXMuc2xpY2UoKTtcbiAgICAgICAgdGFyZ2V0Ll9zaW5nbGVSdWxlcyA9IENsb25lKHRoaXMuX3NpbmdsZVJ1bGVzLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIHRhcmdldC5fcmVmcyA9IHRoaXMuX3JlZnMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9mbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ZsYWdzKTtcbiAgICAgICAgdGFyZ2V0Ll9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGFyZ2V0LiRfdGVybXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kX3Rlcm1zKSB7XG4gICAgICAgICAgICB0YXJnZXQuJF90ZXJtc1trZXldID0gdGhpcy4kX3Rlcm1zW2tleV0gPyB0aGlzLiRfdGVybXNba2V5XS5zbGljZSgpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgdGFyZ2V0LiRfc3VwZXIgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBpbiB0aGlzLiRfc3VwZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC4kX3N1cGVyW292ZXJyaWRlXSA9IHRoaXMuX3N1cGVyW292ZXJyaWRlXS5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIF9iYXJlKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9yZXNldCgpO1xuXG4gICAgICAgIGNvbnN0IHRlcm1zID0gb2JqLl9kZWZpbml0aW9uLnRlcm1zO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGVybXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtc1tuYW1lXTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW25hbWVdID0gdGVybS5pbml0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBfZGVmYXVsdChmbGFnLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgJ2xpdGVyYWwnKTtcblxuICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ01pc3NpbmcnLCBmbGFnLCAndmFsdWUnKTtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhb3B0aW9ucy5saXRlcmFsLCAnT25seSBmdW5jdGlvbiB2YWx1ZSBzdXBwb3J0cyBsaXRlcmFsIG9wdGlvbicpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIG9wdGlvbnMubGl0ZXJhbCkge1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF06IHRydWUsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbDogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfc2V0RmxhZyhmbGFnLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xsZWN0IG1hdGNoaW5nIHdoZW5zXG5cbiAgICAgICAgY29uc3Qgd2hlbnMgPSBbXTtcbiAgICAgICAgY29uc3QgaWRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4kX3Rlcm1zLndoZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB3aGVuID0gdGhpcy4kX3Rlcm1zLndoZW5zW2ldO1xuXG4gICAgICAgICAgICBpZiAod2hlbi5jb25jYXQpIHtcbiAgICAgICAgICAgICAgICB3aGVucy5wdXNoKHdoZW4uY29uY2F0KTtcbiAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtpfS5jb25jYXRgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB3aGVuLnJlZiA/IHdoZW4ucmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcykgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gaWRzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXMsIHRoZW4sIG90aGVyd2lzZSB9ID0gdGVzdHNbal07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlSWQgPSBgJHtpfSR7d2hlbi5zd2l0Y2ggPyAnLicgKyBqIDogJyd9YDtcbiAgICAgICAgICAgICAgICBpZiAoaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7YmFzZUlkfS5pc2ApLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgYCR7YmFzZUlkfS50aGVuYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYTogZ2VuZXJhdGVkLCBpZCB9ID0gdGhlbi5fZ2VuZXJhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2Jhc2VJZH0udGhlbiR7aWQgPyBgKCR7aWR9KWAgOiAnJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGAke2Jhc2VJZH0ub3RoZXJ3aXNlYF0sIHN0YXRlLmFuY2VzdG9ycywgc3RhdGUuc2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hOiBnZW5lcmF0ZWQsIGlkIH0gPSBvdGhlcndpc2UuX2dlbmVyYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIHdoZW5zLnB1c2goZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7YmFzZUlkfS5vdGhlcndpc2Uke2lkID8gYCgke2lkfSlgIDogJyd9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdoZW4uYnJlYWsgJiZcbiAgICAgICAgICAgICAgICBpZHMubGVuZ3RoID4gYmVmb3JlKSB7ICAgICAgICAgIC8vIFNvbWV0aGluZyBtYXRjaGVkXG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGNhY2hlXG5cbiAgICAgICAgY29uc3QgaWQgPSBpZHMuam9pbignLCAnKTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAncnVsZScsICd3aGVuJywgaWQpO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS50cmFjZXIuYWN0aXZlICYmXG4gICAgICAgICAgICB0aGlzLiRfdGVtcC53aGVuc1tpZF0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzLiRfdGVtcC53aGVuc1tpZF0sIGlkIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBkeW5hbWljIHNjaGVtYVxuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLl9kZWZpbml0aW9uLmdlbmVyYXRlKHRoaXMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgd2hlbnNcblxuICAgICAgICBmb3IgKGNvbnN0IHdoZW4gb2Ygd2hlbnMpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQod2hlbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjaW5nXG5cbiAgICAgICAgaWYgKHRoaXMuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJF9yb290Ll90cmFjZXIuX2NvbWJpbmUob2JqLCBbdGhpcywgLi4ud2hlbnNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhY2hlIHJlc3VsdFxuXG4gICAgICAgIHRoaXMuJF90ZW1wLndoZW5zW2lkXSA9IG9iajtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBvYmosIGlkIH07XG4gICAgfVxuXG4gICAgX2lubmVyKHR5cGUsIHZhbHVlcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgYENhbm5vdCBzZXQgJHt0eXBlfSBpbnNpZGUgYSBydWxlc2V0YCk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW3R5cGVdIHx8XG4gICAgICAgICAgICBvcHRpb25zLm92ZXJyaWRlKSB7XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zaW5nbGUpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2godmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zW3R5cGVdLnB1c2goLi4udmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9pblJ1bGVzZXQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IG51bGwgJiYgdGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3J1bGVSZW1vdmUobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gb3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgPyB0aGlzLmNsb25lKCkgOiB0aGlzO1xuXG4gICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdGVzdCA9IG9iai5fcnVsZXNbaV07XG4gICAgICAgICAgICBpZiAodGVzdC5uYW1lID09PSBuYW1lICYmXG4gICAgICAgICAgICAgICAgIXRlc3Qua2VlcCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iai5faW5SdWxlc2V0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA8IG9iai4kX3RlbXAucnVsZXNldCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC0tb2JqLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9ydWxlcyA9IGZpbHRlcmVkO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF92YWx1ZXModmFsdWVzLCBrZXkpIHtcblxuICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsIGtleS5zbGljZSgxLCAtMSkpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBvdmVycmlkZSA9IHZhbHVlc1swXSA9PT0gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGU7XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvYmpba2V5XSAmJlxuICAgICAgICAgICAgdmFsdWVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBvYmpba2V5XSA9IG5ldyBWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZXMubGVuZ3RoID8gbmV3IFZhbHVlcygpIDogbnVsbDtcbiAgICAgICAgICAgIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG9ialtrZXldLm92ZXJyaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBhbGxvdy92YWxpZC9pbnZhbGlkIHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLCAnT3ZlcnJpZGUgbXVzdCBiZSB0aGUgZmlyc3QgdmFsdWUnKTtcblxuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBrZXkgPT09ICdfaW52YWxpZHMnID8gJ192YWxpZHMnIDogJ19pbnZhbGlkcyc7XG4gICAgICAgICAgICBpZiAob2JqW290aGVyXSkge1xuICAgICAgICAgICAgICAgIG9ialtvdGhlcl0ucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9ialtvdGhlcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXkgPT09ICdfdmFsaWRzJyB8fCAhb2JqLl9mbGFncy5vbmx5LCAnU2V0dGluZyBpbnZhbGlkIHZhbHVlJywgdmFsdWUsICdsZWF2ZXMgc2NoZW1hIHJlamVjdGluZyBhbGwgdmFsdWVzIGR1ZSB0byBwcmV2aW91cyB2YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIG9ialtvdGhlcl0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqW2tleV0uYWRkKHZhbHVlLCBvYmouX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5hbnldID0ge1xuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNvbXBpbGU6IENvbXBpbGUuY29tcGlsZSxcbiAgICByb290OiAnJF9yb290J1xufTtcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzIChtdXN0IGJlIG9uIHByb3RvdHlwZSlcblxuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5kZW55ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZGlzYWxsb3cgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5lcXVhbCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5leGlzdCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5yZXF1aXJlZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5ub3QgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5vcHRpb25zID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZlcmVuY2VzID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnByZWZzO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5CYXNlKCk7XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkNsb25lIiwiRGVlcEVxdWFsIiwiTWVyZ2UiLCJDYWNoZSIsIkNvbW1vbiIsIkNvbXBpbGUiLCJFcnJvcnMiLCJFeHRlbmQiLCJNYW5pZmVzdCIsIk1lc3NhZ2VzIiwiTW9kaWZ5IiwiUmVmIiwiVHJhY2UiLCJWYWxpZGF0b3IiLCJWYWx1ZXMiLCJpbnRlcm5hbHMiLCJCYXNlIiwiY29uc3RydWN0b3IiLCJ0eXBlIiwiJF9yb290IiwiX2RlZmluaXRpb24iLCJfcmVzZXQiLCJfaWRzIiwiSWRzIiwiX3ByZWZlcmVuY2VzIiwiX3JlZnMiLCJNYW5hZ2VyIiwiX2NhY2hlIiwiX3ZhbGlkcyIsIl9pbnZhbGlkcyIsIl9mbGFncyIsIl9ydWxlcyIsIl9zaW5nbGVSdWxlcyIsIk1hcCIsIiRfdGVybXMiLCIkX3RlbXAiLCJydWxlc2V0Iiwid2hlbnMiLCJkZXNjcmliZSIsImFsbG93IiwidmFsdWVzIiwidmVyaWZ5RmxhdCIsIl92YWx1ZXMiLCJhbHRlciIsInRhcmdldHMiLCJBcnJheSIsImlzQXJyYXkiLCJfaW5SdWxlc2V0Iiwib2JqIiwiY2xvbmUiLCJhbHRlcmF0aW9ucyIsInRhcmdldCIsImFkanVzdGVyIiwicHVzaCIsImFydGlmYWN0IiwiaWQiLCJ1bmRlZmluZWQiLCIkX3NldEZsYWciLCJjYXN0IiwidG8iLCJkZWZhdWx0IiwidmFsdWUiLCJvcHRpb25zIiwiX2RlZmF1bHQiLCJkZXNjcmlwdGlvbiIsImRlc2MiLCJlbXB0eSIsInNjaGVtYSIsIiRfY29tcGlsZSIsIm92ZXJyaWRlIiwiZXJyb3IiLCJlcnIiLCJFcnJvciIsImV4YW1wbGUiLCJhc3NlcnRPcHRpb25zIiwiX2lubmVyIiwic2luZ2xlIiwiZXh0ZXJuYWwiLCJtZXRob2QiLCJmYWlsb3ZlciIsImZvcmJpZGRlbiIsInByZXNlbmNlIiwidGVzdCIsImludmFsaWQiLCJsYWJlbCIsIm5hbWUiLCJtZXRhIiwibm90ZSIsIm5vdGVzIiwibGVuZ3RoIiwib25seSIsIm1vZGUiLCJvcHRpb25hbCIsInByZWZzIiwiY29udGV4dCIsImV4dGVybmFscyIsIndhcm5pbmdzIiwiZGVidWciLCJjaGVja1ByZWZlcmVuY2VzIiwicHJlZmVyZW5jZXMiLCJpbmNsdWRlcyIsInJhdyIsImVuYWJsZWQiLCJyZXN1bHQiLCJyZXF1aXJlZCIsInN0cmljdCIsImNvbnZlcnQiLCJzdHJpcCIsInRhZyIsInRhZ3MiLCJ1bml0IiwidmFsaWQiLCJ3aGVuIiwiY29uZGl0aW9uIiwiY29uZGl0aW9ucyIsImlzIiwic3dpdGNoIiwiaXRlbSIsInRoZW4iLCJvdGhlcndpc2UiLCIkX211dGF0ZVJlYnVpbGQiLCJjYWNoZSIsInByb3ZpZGVyIiwicHJvdmlzaW9uIiwiT2JqZWN0IiwiY3JlYXRlIiwiZ2V0UHJvdG90eXBlT2YiLCJfYXNzaWduIiwiY29uY2F0Iiwic291cmNlIiwiaXNTY2hlbWEiLCJ0bXBPYmoiLCJrZXkiLCJrZXlzIiwicmVnaXN0ZXIiLCJ0b1NpYmxpbmciLCJtZXJnZSIsImhhcyIsImZpbHRlciIsImtlZXAiLCJkZWxldGUiLCJydWxlcyIsIm11bHRpIiwic2V0IiwiZmxhZ3MiLCJhc3NpZ24iLCJ0ZXJtcyIsInNsaWNlIiwiX3RyYWNlciIsIl9jb21iaW5lIiwiZXh0ZW5kIiwiYmFzZSIsImV4dHJhY3QiLCJwYXRoIiwic3BsaXQiLCJyZWFjaCIsImZvcmsiLCJwYXRocyIsInJ1bGUiLCJkZWYiLCJtb2RpZmllcnMiLCJzdGFydCIsImkiLCJvcmlnaW5hbCIsImdldCIsIiQiLCJ0YWlsb3IiLCIkX21vZGlmeSIsImVhY2giLCJyZWYiLCJ0cmFjZXIiLCJsb2NhdGlvbiIsInZhbGlkYXRlIiwiZW50cnkiLCJ2YWxpZGF0ZUFzeW5jIiwiZW50cnlBc3luYyIsIiRfYWRkUnVsZSIsIl9yZXNvbHZlIiwiZGVmaW5pdGlvbiIsImFyZ3MiLCJhcmciLCJhcmdzQnlOYW1lIiwicmVzb2x2ZXIiLCJpc1Jlc29sdmFibGUiLCIkX211dGF0ZVJlZ2lzdGVyIiwibm9ybWFsaXplIiwiYXNzZXJ0IiwidmFsaWRhdGVBcmciLCJfcnVsZVJlbW92ZSIsInByaW9yaXR5IiwidW5zaGlmdCIsIiRfY3JlYXRlRXJyb3IiLCJjb2RlIiwibG9jYWwiLCJzdGF0ZSIsIm1lc3NhZ2VzIiwiUmVwb3J0IiwiJF9nZXRGbGFnIiwiJF9nZXRSdWxlIiwiJF9tYXBMYWJlbHMiLCJsYWJlbHMiLCIkX21hdGNoIiwib3ZlcnJpZGVzIiwiYWJvcnRFYXJseSIsIl9leHRlcm5hbHMiLCJzbmFwc2hvdCIsImVycm9ycyIsInJlc3RvcmUiLCJyZXNldCIsImZhbWlseSIsInJlYnVpbGQiLCIkX3Byb3BlcnR5IiwicHJvcGVydGllcyIsIiRfcmVhY2giLCIkX3Jvb3RSZWZlcmVuY2VzIiwicm9vdHMiLCJmbGFnIiwiJF9wYXJlbnQiLCJzeW1ib2xzIiwicGFyZW50IiwiY2FsbCIsIiRfdmFsaWRhdGUiLCJzaGFsbG93IiwiJF9zdXBlciIsIl9zdXBlciIsImJpbmQiLCJfYmFyZSIsInRlcm0iLCJpbml0IiwibGl0ZXJhbCIsIl9nZW5lcmF0ZSIsImlkcyIsImlucHV0IiwicmVzb2x2ZSIsInRlc3RzIiwiYmVmb3JlIiwiaiIsImJhc2VJZCIsIm5lc3QiLCJsb2NhbFN0YXRlIiwibG9jYWxpemUiLCJhbmNlc3RvcnMiLCJzY2hlbWFzIiwiZ2VuZXJhdGVkIiwiYnJlYWsiLCJqb2luIiwibWFpbnN0YXkiLCJhY3RpdmUiLCJnZW5lcmF0ZSIsImZpbHRlcmVkIiwib3RoZXIiLCJyZW1vdmUiLCJhZGQiLCJwcm90b3R5cGUiLCJhbnkiLCJ2ZXJzaW9uIiwiY29tcGlsZSIsInJvb3QiLCJpc0ltbXV0YWJsZSIsImRlbnkiLCJkaXNhbGxvdyIsImVxdWFsIiwiZXhpc3QiLCJub3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/cache.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/cache.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst internals = {\n    max: 1000,\n    supported: new Set([\n        \"undefined\",\n        \"boolean\",\n        \"number\",\n        \"string\"\n    ])\n};\nexports.provider = {\n    provision (options) {\n        return new internals.Cache(options);\n    }\n};\n// Least Recently Used (LRU) Cache\ninternals.Cache = class {\n    constructor(options = {}){\n        Common.assertOptions(options, [\n            \"max\"\n        ]);\n        Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), \"Invalid max cache size\");\n        this._max = options.max || internals.max;\n        this._map = new Map(); // Map of nodes by key\n        this._list = new internals.List(); // List of nodes (most recently used in head)\n    }\n    get length() {\n        return this._map.size;\n    }\n    set(key, value) {\n        if (key !== null && !internals.supported.has(typeof key)) {\n            return;\n        }\n        let node = this._map.get(key);\n        if (node) {\n            node.value = value;\n            this._list.first(node);\n            return;\n        }\n        node = this._list.unshift({\n            key,\n            value\n        });\n        this._map.set(key, node);\n        this._compact();\n    }\n    get(key) {\n        const node = this._map.get(key);\n        if (node) {\n            this._list.first(node);\n            return Clone(node.value);\n        }\n    }\n    _compact() {\n        if (this._map.size > this._max) {\n            const node = this._list.pop();\n            this._map.delete(node.key);\n        }\n    }\n};\ninternals.List = class {\n    constructor(){\n        this.tail = null;\n        this.head = null;\n    }\n    unshift(node) {\n        node.next = null;\n        node.prev = this.head;\n        if (this.head) {\n            this.head.next = node;\n        }\n        this.head = node;\n        if (!this.tail) {\n            this.tail = node;\n        }\n        return node;\n    }\n    first(node) {\n        if (node === this.head) {\n            return;\n        }\n        this._remove(node);\n        this.unshift(node);\n    }\n    pop() {\n        return this._remove(this.tail);\n    }\n    _remove(node) {\n        const { next, prev } = node;\n        next.prev = prev;\n        if (prev) {\n            prev.next = next;\n        }\n        if (node === this.tail) {\n            this.tail = next;\n        }\n        node.prev = null;\n        node.next = null;\n        return node;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBRXRCLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDO0FBR3ZCLE1BQU1HLFlBQVk7SUFDZEMsS0FBSztJQUNMQyxXQUFXLElBQUlDLElBQUk7UUFBQztRQUFhO1FBQVc7UUFBVTtLQUFTO0FBQ25FO0FBR0FDLGdCQUFnQixHQUFHO0lBRWZFLFdBQVVDLE9BQU87UUFFYixPQUFPLElBQUlQLFVBQVVRLEtBQUssQ0FBQ0Q7SUFDL0I7QUFDSjtBQUdBLGtDQUFrQztBQUVsQ1AsVUFBVVEsS0FBSyxHQUFHO0lBRWRDLFlBQVlGLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFFdEJSLE9BQU9XLGFBQWEsQ0FBQ0gsU0FBUztZQUFDO1NBQU07UUFDckNYLE9BQU9XLFFBQVFOLEdBQUcsS0FBS1UsYUFBYUosUUFBUU4sR0FBRyxJQUFJTSxRQUFRTixHQUFHLEdBQUcsS0FBS1csU0FBU0wsUUFBUU4sR0FBRyxHQUFHO1FBRTdGLElBQUksQ0FBQ1ksSUFBSSxHQUFHTixRQUFRTixHQUFHLElBQUlELFVBQVVDLEdBQUc7UUFFeEMsSUFBSSxDQUFDYSxJQUFJLEdBQUcsSUFBSUMsT0FBZ0Msc0JBQXNCO1FBQ3RFLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUloQixVQUFVaUIsSUFBSSxJQUFpQiw2Q0FBNkM7SUFDakc7SUFFQSxJQUFJQyxTQUFTO1FBRVQsT0FBTyxJQUFJLENBQUNKLElBQUksQ0FBQ0ssSUFBSTtJQUN6QjtJQUVBQyxJQUFJQyxHQUFHLEVBQUVDLEtBQUssRUFBRTtRQUVaLElBQUlELFFBQVEsUUFDUixDQUFDckIsVUFBVUUsU0FBUyxDQUFDcUIsR0FBRyxDQUFDLE9BQU9GLE1BQU07WUFFdEM7UUFDSjtRQUVBLElBQUlHLE9BQU8sSUFBSSxDQUFDVixJQUFJLENBQUNXLEdBQUcsQ0FBQ0o7UUFDekIsSUFBSUcsTUFBTTtZQUNOQSxLQUFLRixLQUFLLEdBQUdBO1lBQ2IsSUFBSSxDQUFDTixLQUFLLENBQUNVLEtBQUssQ0FBQ0Y7WUFDakI7UUFDSjtRQUVBQSxPQUFPLElBQUksQ0FBQ1IsS0FBSyxDQUFDVyxPQUFPLENBQUM7WUFBRU47WUFBS0M7UUFBTTtRQUN2QyxJQUFJLENBQUNSLElBQUksQ0FBQ00sR0FBRyxDQUFDQyxLQUFLRztRQUNuQixJQUFJLENBQUNJLFFBQVE7SUFDakI7SUFFQUgsSUFBSUosR0FBRyxFQUFFO1FBRUwsTUFBTUcsT0FBTyxJQUFJLENBQUNWLElBQUksQ0FBQ1csR0FBRyxDQUFDSjtRQUMzQixJQUFJRyxNQUFNO1lBQ04sSUFBSSxDQUFDUixLQUFLLENBQUNVLEtBQUssQ0FBQ0Y7WUFDakIsT0FBTzFCLE1BQU0wQixLQUFLRixLQUFLO1FBQzNCO0lBQ0o7SUFFQU0sV0FBVztRQUVQLElBQUksSUFBSSxDQUFDZCxJQUFJLENBQUNLLElBQUksR0FBRyxJQUFJLENBQUNOLElBQUksRUFBRTtZQUM1QixNQUFNVyxPQUFPLElBQUksQ0FBQ1IsS0FBSyxDQUFDYSxHQUFHO1lBQzNCLElBQUksQ0FBQ2YsSUFBSSxDQUFDZ0IsTUFBTSxDQUFDTixLQUFLSCxHQUFHO1FBQzdCO0lBQ0o7QUFDSjtBQUdBckIsVUFBVWlCLElBQUksR0FBRztJQUViUixhQUFjO1FBRVYsSUFBSSxDQUFDc0IsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7SUFFQUwsUUFBUUgsSUFBSSxFQUFFO1FBRVZBLEtBQUtTLElBQUksR0FBRztRQUNaVCxLQUFLVSxJQUFJLEdBQUcsSUFBSSxDQUFDRixJQUFJO1FBRXJCLElBQUksSUFBSSxDQUFDQSxJQUFJLEVBQUU7WUFDWCxJQUFJLENBQUNBLElBQUksQ0FBQ0MsSUFBSSxHQUFHVDtRQUNyQjtRQUVBLElBQUksQ0FBQ1EsSUFBSSxHQUFHUjtRQUVaLElBQUksQ0FBQyxJQUFJLENBQUNPLElBQUksRUFBRTtZQUNaLElBQUksQ0FBQ0EsSUFBSSxHQUFHUDtRQUNoQjtRQUVBLE9BQU9BO0lBQ1g7SUFFQUUsTUFBTUYsSUFBSSxFQUFFO1FBRVIsSUFBSUEsU0FBUyxJQUFJLENBQUNRLElBQUksRUFBRTtZQUNwQjtRQUNKO1FBRUEsSUFBSSxDQUFDRyxPQUFPLENBQUNYO1FBQ2IsSUFBSSxDQUFDRyxPQUFPLENBQUNIO0lBQ2pCO0lBRUFLLE1BQU07UUFFRixPQUFPLElBQUksQ0FBQ00sT0FBTyxDQUFDLElBQUksQ0FBQ0osSUFBSTtJQUNqQztJQUVBSSxRQUFRWCxJQUFJLEVBQUU7UUFFVixNQUFNLEVBQUVTLElBQUksRUFBRUMsSUFBSSxFQUFFLEdBQUdWO1FBRXZCUyxLQUFLQyxJQUFJLEdBQUdBO1FBRVosSUFBSUEsTUFBTTtZQUNOQSxLQUFLRCxJQUFJLEdBQUdBO1FBQ2hCO1FBRUEsSUFBSVQsU0FBUyxJQUFJLENBQUNPLElBQUksRUFBRTtZQUNwQixJQUFJLENBQUNBLElBQUksR0FBR0U7UUFDaEI7UUFFQVQsS0FBS1UsSUFBSSxHQUFHO1FBQ1pWLEtBQUtTLElBQUksR0FBRztRQUVaLE9BQU9UO0lBQ1g7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY2FjaGUuanM/YjFjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtYXg6IDEwMDAsXG4gICAgc3VwcG9ydGVkOiBuZXcgU2V0KFsndW5kZWZpbmVkJywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddKVxufTtcblxuXG5leHBvcnRzLnByb3ZpZGVyID0ge1xuXG4gICAgcHJvdmlzaW9uKG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5DYWNoZShvcHRpb25zKTtcbiAgICB9XG59O1xuXG5cbi8vIExlYXN0IFJlY2VudGx5IFVzZWQgKExSVSkgQ2FjaGVcblxuaW50ZXJuYWxzLkNhY2hlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydtYXgnXSk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm1heCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4ICYmIG9wdGlvbnMubWF4ID4gMCAmJiBpc0Zpbml0ZShvcHRpb25zLm1heCksICdJbnZhbGlkIG1heCBjYWNoZSBzaXplJyk7XG5cbiAgICAgICAgdGhpcy5fbWF4ID0gb3B0aW9ucy5tYXggfHwgaW50ZXJuYWxzLm1heDtcblxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXAgb2Ygbm9kZXMgYnkga2V5XG4gICAgICAgIHRoaXMuX2xpc3QgPSBuZXcgaW50ZXJuYWxzLkxpc3QoKTsgICAgICAgICAgICAgIC8vIExpc3Qgb2Ygbm9kZXMgKG1vc3QgcmVjZW50bHkgdXNlZCBpbiBoZWFkKVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgIWludGVybmFscy5zdXBwb3J0ZWQuaGFzKHR5cGVvZiBrZXkpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fbGlzdC5maXJzdChub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSB0aGlzLl9saXN0LnVuc2hpZnQoeyBrZXksIHZhbHVlIH0pO1xuICAgICAgICB0aGlzLl9tYXAuc2V0KGtleSwgbm9kZSk7XG4gICAgICAgIHRoaXMuX2NvbXBhY3QoKTtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3QuZmlyc3Qobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUobm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY29tcGFjdCgpIHtcblxuICAgICAgICBpZiAodGhpcy5fbWFwLnNpemUgPiB0aGlzLl9tYXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9saXN0LnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShub2RlLmtleSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5MaXN0ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB9XG5cbiAgICB1bnNoaWZ0KG5vZGUpIHtcblxuICAgICAgICBub2RlLm5leHQgPSBudWxsO1xuICAgICAgICBub2RlLnByZXYgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkLm5leHQgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcblxuICAgICAgICBpZiAoIXRoaXMudGFpbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGZpcnN0KG5vZGUpIHtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XG4gICAgICAgIHRoaXMudW5zaGlmdChub2RlKTtcbiAgICB9XG5cbiAgICBwb3AoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZSh0aGlzLnRhaWwpO1xuICAgIH1cblxuICAgIF9yZW1vdmUobm9kZSkge1xuXG4gICAgICAgIGNvbnN0IHsgbmV4dCwgcHJldiB9ID0gbm9kZTtcblxuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuXG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucHJldiA9IG51bGw7XG4gICAgICAgIG5vZGUubmV4dCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJBc3NlcnQiLCJyZXF1aXJlIiwiQ2xvbmUiLCJDb21tb24iLCJpbnRlcm5hbHMiLCJtYXgiLCJzdXBwb3J0ZWQiLCJTZXQiLCJleHBvcnRzIiwicHJvdmlkZXIiLCJwcm92aXNpb24iLCJvcHRpb25zIiwiQ2FjaGUiLCJjb25zdHJ1Y3RvciIsImFzc2VydE9wdGlvbnMiLCJ1bmRlZmluZWQiLCJpc0Zpbml0ZSIsIl9tYXgiLCJfbWFwIiwiTWFwIiwiX2xpc3QiLCJMaXN0IiwibGVuZ3RoIiwic2l6ZSIsInNldCIsImtleSIsInZhbHVlIiwiaGFzIiwibm9kZSIsImdldCIsImZpcnN0IiwidW5zaGlmdCIsIl9jb21wYWN0IiwicG9wIiwiZGVsZXRlIiwidGFpbCIsImhlYWQiLCJuZXh0IiwicHJldiIsIl9yZW1vdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/common.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/common.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst AssertError = __webpack_require__(/*! @hapi/hoek/lib/error */ \"(rsc)/./node_modules/@hapi/hoek/lib/error.js\");\nconst Pkg = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/joi/package.json\");\nlet Messages;\nlet Schemas;\nconst internals = {\n    isoDate: /^(?:[-+]\\d{2})?(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/\n};\nexports.version = Pkg.version;\nexports.defaults = {\n    abortEarly: true,\n    allowUnknown: false,\n    artifacts: false,\n    cache: true,\n    context: null,\n    convert: true,\n    dateFormat: \"iso\",\n    errors: {\n        escapeHtml: false,\n        label: \"path\",\n        language: null,\n        render: true,\n        stack: false,\n        wrap: {\n            label: '\"',\n            array: \"[]\"\n        }\n    },\n    externals: true,\n    messages: {},\n    nonEnumerables: false,\n    noDefaults: false,\n    presence: \"optional\",\n    skipFunctions: false,\n    stripUnknown: false,\n    warnings: false\n};\nexports.symbols = {\n    any: Symbol.for(\"@hapi/joi/schema\"),\n    arraySingle: Symbol(\"arraySingle\"),\n    deepDefault: Symbol(\"deepDefault\"),\n    errors: Symbol(\"errors\"),\n    literal: Symbol(\"literal\"),\n    override: Symbol(\"override\"),\n    parent: Symbol(\"parent\"),\n    prefs: Symbol(\"prefs\"),\n    ref: Symbol(\"ref\"),\n    template: Symbol(\"template\"),\n    values: Symbol(\"values\")\n};\nexports.assertOptions = function(options, keys, name = \"Options\") {\n    Assert(options && typeof options === \"object\" && !Array.isArray(options), \"Options must be of type object\");\n    const unknownKeys = Object.keys(options).filter((k)=>!keys.includes(k));\n    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);\n};\nexports.checkPreferences = function(prefs) {\n    Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/joi/lib/schemas.js\");\n    const result = Schemas.preferences.validate(prefs);\n    if (result.error) {\n        throw new AssertError([\n            result.error.details[0].message\n        ]);\n    }\n};\nexports.compare = function(a, b, operator) {\n    switch(operator){\n        case \"=\":\n            return a === b;\n        case \">\":\n            return a > b;\n        case \"<\":\n            return a < b;\n        case \">=\":\n            return a >= b;\n        case \"<=\":\n            return a <= b;\n    }\n};\nexports[\"default\"] = function(value, defaultValue) {\n    return value === undefined ? defaultValue : value;\n};\nexports.isIsoDate = function(date) {\n    return internals.isoDate.test(date);\n};\nexports.isNumber = function(value) {\n    return typeof value === \"number\" && !isNaN(value);\n};\nexports.isResolvable = function(obj) {\n    if (!obj) {\n        return false;\n    }\n    return obj[exports.symbols.ref] || obj[exports.symbols.template];\n};\nexports.isSchema = function(schema, options = {}) {\n    const any = schema && schema[exports.symbols.any];\n    if (!any) {\n        return false;\n    }\n    Assert(options.legacy || any.version === exports.version, \"Cannot mix different versions of joi schemas\");\n    return true;\n};\nexports.isValues = function(obj) {\n    return obj[exports.symbols.values];\n};\nexports.limit = function(value) {\n    return Number.isSafeInteger(value) && value >= 0;\n};\nexports.preferences = function(target, source) {\n    Messages = Messages || __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\n    target = target || {};\n    source = source || {};\n    const merged = Object.assign({}, target, source);\n    if (source.errors && target.errors) {\n        merged.errors = Object.assign({}, target.errors, source.errors);\n        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);\n    }\n    if (source.messages) {\n        merged.messages = Messages.compile(source.messages, target.messages);\n    }\n    delete merged[exports.symbols.prefs];\n    return merged;\n};\nexports.tryWithPath = function(fn, key, options = {}) {\n    try {\n        return fn();\n    } catch (err) {\n        if (err.path !== undefined) {\n            err.path = key + \".\" + err.path;\n        } else {\n            err.path = key;\n        }\n        if (options.append) {\n            err.message = `${err.message} (${err.path})`;\n        }\n        throw err;\n    }\n};\nexports.validateArg = function(value, label, { assert, message }) {\n    if (exports.isSchema(assert)) {\n        const result = assert.validate(value);\n        if (!result.error) {\n            return;\n        }\n        return result.error.message;\n    } else if (!assert(value)) {\n        return label ? `${label} ${message}` : message;\n    }\n};\nexports.verifyFlat = function(args, method) {\n    for (const arg of args){\n        Assert(!Array.isArray(arg), \"Method no longer accepts array arguments:\", method);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQztBQUU1QixNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQztBQUVwQixJQUFJRztBQUNKLElBQUlDO0FBR0osTUFBTUMsWUFBWTtJQUNkQyxTQUFTO0FBQ2I7QUFHQUMsZUFBZSxHQUFHTCxJQUFJTSxPQUFPO0FBRzdCRCxnQkFBZ0IsR0FBRztJQUNmRyxZQUFZO0lBQ1pDLGNBQWM7SUFDZEMsV0FBVztJQUNYQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxZQUFZO0lBQ1pDLFFBQVE7UUFDSkMsWUFBWTtRQUNaQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLE1BQU07WUFDRkosT0FBTztZQUNQSyxPQUFPO1FBQ1g7SUFDSjtJQUNBQyxXQUFXO0lBQ1hDLFVBQVUsQ0FBQztJQUNYQyxnQkFBZ0I7SUFDaEJDLFlBQVk7SUFDWkMsVUFBVTtJQUNWQyxlQUFlO0lBQ2ZDLGNBQWM7SUFDZEMsVUFBVTtBQUNkO0FBR0F6QixlQUFlLEdBQUc7SUFDZDJCLEtBQUtDLE9BQU9DLEdBQUcsQ0FBQztJQUNoQkMsYUFBYUYsT0FBTztJQUNwQkcsYUFBYUgsT0FBTztJQUNwQmxCLFFBQVFrQixPQUFPO0lBQ2ZJLFNBQVNKLE9BQU87SUFDaEJLLFVBQVVMLE9BQU87SUFDakJNLFFBQVFOLE9BQU87SUFDZk8sT0FBT1AsT0FBTztJQUNkUSxLQUFLUixPQUFPO0lBQ1pTLFVBQVVULE9BQU87SUFDakJVLFFBQVFWLE9BQU87QUFDbkI7QUFHQTVCLHFCQUFxQixHQUFHLFNBQVV3QyxPQUFPLEVBQUVDLElBQUksRUFBRUMsT0FBTyxTQUFTO0lBRTdEbEQsT0FBT2dELFdBQVcsT0FBT0EsWUFBWSxZQUFZLENBQUNHLE1BQU1DLE9BQU8sQ0FB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RUEsTUFBTSxDQUFDLEVBQUU2QyxRQUFRLENBQUMsR0FBR0E7SUFDM0M7QUFDSjtBQUdBekQsa0JBQWtCLEdBQUcsU0FBVThGLElBQUksRUFBRUMsTUFBTTtJQUV2QyxLQUFLLE1BQU1DLE9BQU9GLEtBQU07UUFDcEJ0RyxPQUFPLENBQUNtRCxNQUFNQyxPQUFPLENBQUNvRCxNQUFNLDZDQUE2Q0Q7SUFDN0U7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvY29tbW9uLmpzPzJjNzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IEFzc2VydEVycm9yID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXJyb3InKTtcblxuY29uc3QgUGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbmxldCBNZXNzYWdlcztcbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBpc29EYXRlOiAvXig/OlstK11cXGR7Mn0pPyg/OlxcZHs0fSg/IVxcZHsyfVxcYikpKD86KC0/KSg/Oig/OjBbMS05XXwxWzAtMl0pKD86XFwxKD86WzEyXVxcZHwwWzEtOV18M1swMV0pKT98Vyg/OlswLTRdXFxkfDVbMC0yXSkoPzotP1sxLTddKT98KD86MDBbMS05XXwwWzEtOV1cXGR8WzEyXVxcZHsyfXwzKD86WzAtNV1cXGR8NlsxLTZdKSkpKD8hW1RdJHxbVF1bXFxkXStaJCkoPzpbVFxcc10oPzooPzooPzpbMDFdXFxkfDJbMC0zXSkoPzooOj8pWzAtNV1cXGQpP3wyNFxcOj8wMCkoPzpbLixdXFxkKyg/ITopKT8pKD86XFwyWzAtNV1cXGQoPzpbLixdXFxkKyk/KT8oPzpbWl18KD86WystXSkoPzpbMDFdXFxkfDJbMC0zXSkoPzo6P1swLTVdXFxkKT8pPyk/KT8kL1xufTtcblxuXG5leHBvcnRzLnZlcnNpb24gPSBQa2cudmVyc2lvbjtcblxuXG5leHBvcnRzLmRlZmF1bHRzID0ge1xuICAgIGFib3J0RWFybHk6IHRydWUsXG4gICAgYWxsb3dVbmtub3duOiBmYWxzZSxcbiAgICBhcnRpZmFjdHM6IGZhbHNlLFxuICAgIGNhY2hlOiB0cnVlLFxuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgY29udmVydDogdHJ1ZSxcbiAgICBkYXRlRm9ybWF0OiAnaXNvJyxcbiAgICBlcnJvcnM6IHtcbiAgICAgICAgZXNjYXBlSHRtbDogZmFsc2UsXG4gICAgICAgIGxhYmVsOiAncGF0aCcsXG4gICAgICAgIGxhbmd1YWdlOiBudWxsLFxuICAgICAgICByZW5kZXI6IHRydWUsXG4gICAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgICAgd3JhcDoge1xuICAgICAgICAgICAgbGFiZWw6ICdcIicsXG4gICAgICAgICAgICBhcnJheTogJ1tdJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBleHRlcm5hbHM6IHRydWUsXG4gICAgbWVzc2FnZXM6IHt9LFxuICAgIG5vbkVudW1lcmFibGVzOiBmYWxzZSxcbiAgICBub0RlZmF1bHRzOiBmYWxzZSxcbiAgICBwcmVzZW5jZTogJ29wdGlvbmFsJyxcbiAgICBza2lwRnVuY3Rpb25zOiBmYWxzZSxcbiAgICBzdHJpcFVua25vd246IGZhbHNlLFxuICAgIHdhcm5pbmdzOiBmYWxzZVxufTtcblxuXG5leHBvcnRzLnN5bWJvbHMgPSB7XG4gICAgYW55OiBTeW1ib2wuZm9yKCdAaGFwaS9qb2kvc2NoZW1hJyksICAgICAgICAgICAgLy8gVXNlZCB0byBpbnRlcm5hbGx5IGlkZW50aWZ5IGFueS1iYXNlZCB0eXBlcyAoc2hhcmVkIHdpdGggb3RoZXIgam9pIHZlcnNpb25zKVxuICAgIGFycmF5U2luZ2xlOiBTeW1ib2woJ2FycmF5U2luZ2xlJyksXG4gICAgZGVlcERlZmF1bHQ6IFN5bWJvbCgnZGVlcERlZmF1bHQnKSxcbiAgICBlcnJvcnM6IFN5bWJvbCgnZXJyb3JzJyksXG4gICAgbGl0ZXJhbDogU3ltYm9sKCdsaXRlcmFsJyksXG4gICAgb3ZlcnJpZGU6IFN5bWJvbCgnb3ZlcnJpZGUnKSxcbiAgICBwYXJlbnQ6IFN5bWJvbCgncGFyZW50JyksXG4gICAgcHJlZnM6IFN5bWJvbCgncHJlZnMnKSxcbiAgICByZWY6IFN5bWJvbCgncmVmJyksXG4gICAgdGVtcGxhdGU6IFN5bWJvbCgndGVtcGxhdGUnKSxcbiAgICB2YWx1ZXM6IFN5bWJvbCgndmFsdWVzJylcbn07XG5cblxuZXhwb3J0cy5hc3NlcnRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIGtleXMsIG5hbWUgPSAnT3B0aW9ucycpIHtcblxuICAgIEFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSwgJ09wdGlvbnMgbXVzdCBiZSBvZiB0eXBlIG9iamVjdCcpO1xuICAgIGNvbnN0IHVua25vd25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrKSA9PiAha2V5cy5pbmNsdWRlcyhrKSk7XG4gICAgQXNzZXJ0KHVua25vd25LZXlzLmxlbmd0aCA9PT0gMCwgYCR7bmFtZX0gY29udGFpbiB1bmtub3duIGtleXM6ICR7dW5rbm93bktleXN9YCk7XG59O1xuXG5cbmV4cG9ydHMuY2hlY2tQcmVmZXJlbmNlcyA9IGZ1bmN0aW9uIChwcmVmcykge1xuXG4gICAgU2NoZW1hcyA9IFNjaGVtYXMgfHwgcmVxdWlyZSgnLi9zY2hlbWFzJyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBTY2hlbWFzLnByZWZlcmVuY2VzLnZhbGlkYXRlKHByZWZzKTtcblxuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydEVycm9yKFtyZXN1bHQuZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlXSk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYiwgb3BlcmF0b3IpIHtcblxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPSc6IHJldHVybiBhID09PSBiO1xuICAgICAgICBjYXNlICc+JzogcmV0dXJuIGEgPiBiO1xuICAgICAgICBjYXNlICc8JzogcmV0dXJuIGEgPCBiO1xuICAgICAgICBjYXNlICc+PSc6IHJldHVybiBhID49IGI7XG4gICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIGEgPD0gYjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufTtcblxuXG5leHBvcnRzLmlzSXNvRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmlzb0RhdGUudGVzdChkYXRlKTtcbn07XG5cblxuZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy5pc1Jlc29sdmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialtleHBvcnRzLnN5bWJvbHMucmVmXSB8fCBvYmpbZXhwb3J0cy5zeW1ib2xzLnRlbXBsYXRlXTtcbn07XG5cblxuZXhwb3J0cy5pc1NjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hICYmIHNjaGVtYVtleHBvcnRzLnN5bWJvbHMuYW55XTtcbiAgICBpZiAoIWFueSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgQXNzZXJ0KG9wdGlvbnMubGVnYWN5IHx8IGFueS52ZXJzaW9uID09PSBleHBvcnRzLnZlcnNpb24sICdDYW5ub3QgbWl4IGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBqb2kgc2NoZW1hcycpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5leHBvcnRzLmlzVmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgcmV0dXJuIG9ialtleHBvcnRzLnN5bWJvbHMudmFsdWVzXTtcbn07XG5cblxuZXhwb3J0cy5saW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwO1xufTtcblxuXG5leHBvcnRzLnByZWZlcmVuY2VzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cbiAgICBNZXNzYWdlcyA9IE1lc3NhZ2VzIHx8IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgICBzb3VyY2UgPSBzb3VyY2UgfHwge307XG5cbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZS5lcnJvcnMgJiZcbiAgICAgICAgdGFyZ2V0LmVycm9ycykge1xuXG4gICAgICAgIG1lcmdlZC5lcnJvcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQuZXJyb3JzLCBzb3VyY2UuZXJyb3JzKTtcbiAgICAgICAgbWVyZ2VkLmVycm9ycy53cmFwID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LmVycm9ycy53cmFwLCBzb3VyY2UuZXJyb3JzLndyYXApO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UubWVzc2FnZXMpIHtcbiAgICAgICAgbWVyZ2VkLm1lc3NhZ2VzID0gTWVzc2FnZXMuY29tcGlsZShzb3VyY2UubWVzc2FnZXMsIHRhcmdldC5tZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG1lcmdlZFtleHBvcnRzLnN5bWJvbHMucHJlZnNdO1xuICAgIHJldHVybiBtZXJnZWQ7XG59O1xuXG5cbmV4cG9ydHMudHJ5V2l0aFBhdGggPSBmdW5jdGlvbiAoZm4sIGtleSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyLnBhdGggPSBrZXkgKyAnLicgKyBlcnIucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVyci5wYXRoID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwZW5kKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAoJHtlcnIucGF0aH0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMudmFsaWRhdGVBcmcgPSBmdW5jdGlvbiAodmFsdWUsIGxhYmVsLCB7IGFzc2VydCwgbWVzc2FnZSB9KSB7XG5cbiAgICBpZiAoZXhwb3J0cy5pc1NjaGVtYShhc3NlcnQpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzc2VydC52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmICghcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhc3NlcnQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBsYWJlbCA/IGAke2xhYmVsfSAke21lc3NhZ2V9YCA6IG1lc3NhZ2U7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnZlcmlmeUZsYXQgPSBmdW5jdGlvbiAoYXJncywgbWV0aG9kKSB7XG5cbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgIEFzc2VydCghQXJyYXkuaXNBcnJheShhcmcpLCAnTWV0aG9kIG5vIGxvbmdlciBhY2NlcHRzIGFycmF5IGFyZ3VtZW50czonLCBtZXRob2QpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkFzc2VydEVycm9yIiwiUGtnIiwiTWVzc2FnZXMiLCJTY2hlbWFzIiwiaW50ZXJuYWxzIiwiaXNvRGF0ZSIsImV4cG9ydHMiLCJ2ZXJzaW9uIiwiZGVmYXVsdHMiLCJhYm9ydEVhcmx5IiwiYWxsb3dVbmtub3duIiwiYXJ0aWZhY3RzIiwiY2FjaGUiLCJjb250ZXh0IiwiY29udmVydCIsImRhdGVGb3JtYXQiLCJlcnJvcnMiLCJlc2NhcGVIdG1sIiwibGFiZWwiLCJsYW5ndWFnZSIsInJlbmRlciIsInN0YWNrIiwid3JhcCIsImFycmF5IiwiZXh0ZXJuYWxzIiwibWVzc2FnZXMiLCJub25FbnVtZXJhYmxlcyIsIm5vRGVmYXVsdHMiLCJwcmVzZW5jZSIsInNraXBGdW5jdGlvbnMiLCJzdHJpcFVua25vd24iLCJ3YXJuaW5ncyIsInN5bWJvbHMiLCJhbnkiLCJTeW1ib2wiLCJmb3IiLCJhcnJheVNpbmdsZSIsImRlZXBEZWZhdWx0IiwibGl0ZXJhbCIsIm92ZXJyaWRlIiwicGFyZW50IiwicHJlZnMiLCJyZWYiLCJ0ZW1wbGF0ZSIsInZhbHVlcyIsImFzc2VydE9wdGlvbnMiLCJvcHRpb25zIiwia2V5cyIsIm5hbWUiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmtub3duS2V5cyIsIk9iamVjdCIsImZpbHRlciIsImsiLCJpbmNsdWRlcyIsImxlbmd0aCIsImNoZWNrUHJlZmVyZW5jZXMiLCJyZXN1bHQiLCJwcmVmZXJlbmNlcyIsInZhbGlkYXRlIiwiZXJyb3IiLCJkZXRhaWxzIiwibWVzc2FnZSIsImNvbXBhcmUiLCJhIiwiYiIsIm9wZXJhdG9yIiwiZGVmYXVsdCIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwidW5kZWZpbmVkIiwiaXNJc29EYXRlIiwiZGF0ZSIsInRlc3QiLCJpc051bWJlciIsImlzTmFOIiwiaXNSZXNvbHZhYmxlIiwib2JqIiwiaXNTY2hlbWEiLCJzY2hlbWEiLCJsZWdhY3kiLCJpc1ZhbHVlcyIsImxpbWl0IiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsInRhcmdldCIsInNvdXJjZSIsIm1lcmdlZCIsImFzc2lnbiIsImNvbXBpbGUiLCJ0cnlXaXRoUGF0aCIsImZuIiwia2V5IiwiZXJyIiwicGF0aCIsImFwcGVuZCIsInZhbGlkYXRlQXJnIiwiYXNzZXJ0IiwidmVyaWZ5RmxhdCIsImFyZ3MiLCJtZXRob2QiLCJhcmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/compile.js":
/*!*****************************************!*\
  !*** ./node_modules/joi/lib/compile.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst internals = {};\nexports.schema = function(Joi, config, options = {}) {\n    Common.assertOptions(options, [\n        \"appendPath\",\n        \"override\"\n    ]);\n    try {\n        return internals.schema(Joi, config, options);\n    } catch (err) {\n        if (options.appendPath && err.path !== undefined) {\n            err.message = `${err.message} (${err.path})`;\n        }\n        throw err;\n    }\n};\ninternals.schema = function(Joi, config, options) {\n    Assert(config !== undefined, \"Invalid undefined schema\");\n    if (Array.isArray(config)) {\n        Assert(config.length, \"Invalid empty array schema\");\n        if (config.length === 1) {\n            config = config[0];\n        }\n    }\n    const valid = (base, ...values)=>{\n        if (options.override !== false) {\n            return base.valid(Joi.override, ...values);\n        }\n        return base.valid(...values);\n    };\n    if (internals.simple(config)) {\n        return valid(Joi, config);\n    }\n    if (typeof config === \"function\") {\n        return Joi.custom(config);\n    }\n    Assert(typeof config === \"object\", \"Invalid schema content:\", typeof config);\n    if (Common.isResolvable(config)) {\n        return valid(Joi, config);\n    }\n    if (Common.isSchema(config)) {\n        return config;\n    }\n    if (Array.isArray(config)) {\n        for (const item of config){\n            if (!internals.simple(item)) {\n                return Joi.alternatives().try(...config);\n            }\n        }\n        return valid(Joi, ...config);\n    }\n    if (config instanceof RegExp) {\n        return Joi.string().regex(config);\n    }\n    if (config instanceof Date) {\n        return valid(Joi.date(), config);\n    }\n    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), \"Schema can only contain plain objects\");\n    return Joi.object().keys(config);\n};\nexports.ref = function(id, options) {\n    return Ref.isRef(id) ? id : Ref.create(id, options);\n};\nexports.compile = function(root, schema, options = {}) {\n    Common.assertOptions(options, [\n        \"legacy\"\n    ]);\n    // Compiled by any supported version\n    const any = schema && schema[Common.symbols.any];\n    if (any) {\n        Assert(options.legacy || any.version === Common.version, \"Cannot mix different versions of joi schemas:\", any.version, Common.version);\n        return schema;\n    }\n    // Uncompiled root\n    if (typeof schema !== \"object\" || !options.legacy) {\n        return exports.schema(root, schema, {\n            appendPath: true\n        }); // Will error if schema contains other versions\n    }\n    // Scan schema for compiled parts\n    const compiler = internals.walk(schema);\n    if (!compiler) {\n        return exports.schema(root, schema, {\n            appendPath: true\n        });\n    }\n    return compiler.compile(compiler.root, schema);\n};\ninternals.walk = function(schema) {\n    if (typeof schema !== \"object\") {\n        return null;\n    }\n    if (Array.isArray(schema)) {\n        for (const item of schema){\n            const compiler = internals.walk(item);\n            if (compiler) {\n                return compiler;\n            }\n        }\n        return null;\n    }\n    const any = schema[Common.symbols.any];\n    if (any) {\n        return {\n            root: schema[any.root],\n            compile: any.compile\n        };\n    }\n    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), \"Schema can only contain plain objects\");\n    for(const key in schema){\n        const compiler = internals.walk(schema[key]);\n        if (compiler) {\n            return compiler;\n        }\n    }\n    return null;\n};\ninternals.simple = function(value) {\n    return value === null || [\n        \"boolean\",\n        \"string\",\n        \"number\"\n    ].includes(typeof value);\n};\nexports.when = function(schema, condition, options) {\n    if (options === undefined) {\n        Assert(condition && typeof condition === \"object\", \"Missing options\");\n        options = condition;\n        condition = Ref.create(\".\");\n    }\n    if (Array.isArray(options)) {\n        options = {\n            switch: options\n        };\n    }\n    Common.assertOptions(options, [\n        \"is\",\n        \"not\",\n        \"then\",\n        \"otherwise\",\n        \"switch\",\n        \"break\"\n    ]);\n    // Schema condition\n    if (Common.isSchema(condition)) {\n        Assert(options.is === undefined, '\"is\" can not be used with a schema condition');\n        Assert(options.not === undefined, '\"not\" can not be used with a schema condition');\n        Assert(options.switch === undefined, '\"switch\" can not be used with a schema condition');\n        return internals.condition(schema, {\n            is: condition,\n            then: options.then,\n            otherwise: options.otherwise,\n            break: options.break\n        });\n    }\n    // Single condition\n    Assert(Ref.isRef(condition) || typeof condition === \"string\", \"Invalid condition:\", condition);\n    Assert(options.not === undefined || options.is === undefined, 'Cannot combine \"is\" with \"not\"');\n    if (options.switch === undefined) {\n        let rule = options;\n        if (options.not !== undefined) {\n            rule = {\n                is: options.not,\n                then: options.otherwise,\n                otherwise: options.then,\n                break: options.break\n            };\n        }\n        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, \"\").required();\n        Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of \"then\", \"otherwise\", or \"switch\"');\n        Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, \"Cannot specify then, otherwise, and break all together\");\n        if (options.is !== undefined && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {\n            is = is.required(); // Only apply required if this wasn't already a schema or a ref\n        }\n        return internals.condition(schema, {\n            ref: exports.ref(condition),\n            is,\n            then: rule.then,\n            otherwise: rule.otherwise,\n            break: rule.break\n        });\n    }\n    // Switch statement\n    Assert(Array.isArray(options.switch), '\"switch\" must be an array');\n    Assert(options.is === undefined, 'Cannot combine \"switch\" with \"is\"');\n    Assert(options.not === undefined, 'Cannot combine \"switch\" with \"not\"');\n    Assert(options.then === undefined, 'Cannot combine \"switch\" with \"then\"');\n    const rule = {\n        ref: exports.ref(condition),\n        switch: [],\n        break: options.break\n    };\n    for(let i = 0; i < options.switch.length; ++i){\n        const test = options.switch[i];\n        const last = i === options.switch.length - 1;\n        Common.assertOptions(test, last ? [\n            \"is\",\n            \"then\",\n            \"otherwise\"\n        ] : [\n            \"is\",\n            \"then\"\n        ]);\n        Assert(test.is !== undefined, 'Switch statement missing \"is\"');\n        Assert(test.then !== undefined, 'Switch statement missing \"then\"');\n        const item = {\n            is: schema.$_compile(test.is),\n            then: schema.$_compile(test.then)\n        };\n        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {\n            item.is = item.is.required(); // Only apply required if this wasn't already a schema or a ref\n        }\n        if (last) {\n            Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify \"otherwise\" inside and outside a \"switch\"');\n            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;\n            if (otherwise !== undefined) {\n                Assert(rule.break === undefined, \"Cannot specify both otherwise and break\");\n                item.otherwise = schema.$_compile(otherwise);\n            }\n        }\n        rule.switch.push(item);\n    }\n    return rule;\n};\ninternals.condition = function(schema, condition) {\n    for (const key of [\n        \"then\",\n        \"otherwise\"\n    ]){\n        if (condition[key] === undefined) {\n            delete condition[key];\n        } else {\n            condition[key] = schema.$_compile(condition[key]);\n        }\n    }\n    return condition;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9jb21waWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFFdkIsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUUsTUFBTUYsbUJBQU9BLENBQUM7QUFHcEIsTUFBTUcsWUFBWSxDQUFDO0FBR25CQyxjQUFjLEdBQUcsU0FBVUUsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBRWhEUCxPQUFPUSxhQUFhLENBQUNELFNBQVM7UUFBQztRQUFjO0tBQVc7SUFFeEQsSUFBSTtRQUNBLE9BQU9MLFVBQVVFLE1BQU0sQ0FBQ0MsS0FBS0MsUUFBUUM7SUFDekMsRUFDQSxPQUFPRSxLQUFLO1FBQ1IsSUFBSUYsUUFBUUcsVUFBVSxJQUNsQkQsSUFBSUUsSUFBSSxLQUFLQyxXQUFXO1lBRXhCSCxJQUFJSSxPQUFPLEdBQUcsQ0FBQyxFQUFFSixJQUFJSSxPQUFPLENBQUMsRUFBRSxFQUFFSixJQUFJRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2hEO1FBRUEsTUFBTUY7SUFDVjtBQUNKO0FBR0FQLFVBQVVFLE1BQU0sR0FBRyxTQUFVQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsT0FBTztJQUU3Q1QsT0FBT1EsV0FBV00sV0FBVztJQUU3QixJQUFJRSxNQUFNQyxPQUFPLENBQUNULFNBQVM7UUFDdkJSLE9BQU9RLE9BQU9VLE1BQU0sRUFBRTtRQUV0QixJQUFJVixPQUFPVSxNQUFNLEtBQUssR0FBRztZQUNyQlYsU0FBU0EsTUFBTSxDQUFDLEVBQUU7UUFDdEI7SUFDSjtJQUVBLE1BQU1XLFFBQVEsQ0FBQ0MsTUFBTSxHQUFHQztRQUVwQixJQUFJWixRQUFRYSxRQUFRLEtBQUssT0FBTztZQUM1QixPQUFPRixLQUFLRCxLQUFLLENBQUNaLElBQUllLFFBQVEsS0FBS0Q7UUFDdkM7UUFFQSxPQUFPRCxLQUFLRCxLQUFLLElBQUlFO0lBQ3pCO0lBRUEsSUFBSWpCLFVBQVVtQixNQUFNLENBQUNmLFNBQVM7UUFDMUIsT0FBT1csTUFBTVosS0FBS0M7SUFDdEI7SUFFQSxJQUFJLE9BQU9BLFdBQVcsWUFBWTtRQUM5QixPQUFPRCxJQUFJaUIsTUFBTSxDQUFDaEI7SUFDdEI7SUFFQVIsT0FBTyxPQUFPUSxXQUFXLFVBQVUsMkJBQTJCLE9BQU9BO0lBRXJFLElBQUlOLE9BQU91QixZQUFZLENBQUNqQixTQUFTO1FBQzdCLE9BQU9XLE1BQU1aLEtBQUtDO0lBQ3RCO0lBRUEsSUFBSU4sT0FBT3dCLFFBQVEsQ0FBQ2xCLFNBQVM7UUFDekIsT0FBT0E7SUFDWDtJQUVBLElBQUlRLE1BQU1DLE9BQU8sQ0FBQ1QsU0FBUztRQUN2QixLQUFLLE1BQU1tQixRQUFRbkIsT0FBUTtZQUN2QixJQUFJLENBQUNKLFVBQVVtQixNQUFNLENBQUNJLE9BQU87Z0JBQ3pCLE9BQU9wQixJQUFJcUIsWUFBWSxHQUFHQyxHQUFHLElBQUlyQjtZQUNyQztRQUNKO1FBRUEsT0FBT1csTUFBTVosUUFBUUM7SUFDekI7SUFFQSxJQUFJQSxrQkFBa0JzQixRQUFRO1FBQzFCLE9BQU92QixJQUFJd0IsTUFBTSxHQUFHQyxLQUFLLENBQUN4QjtJQUM5QjtJQUVBLElBQUlBLGtCQUFrQnlCLE1BQU07UUFDeEIsT0FBT2QsTUFBTVosSUFBSTJCLElBQUksSUFBSTFCO0lBQzdCO0lBRUFSLE9BQU9tQyxPQUFPQyxjQUFjLENBQUM1QixZQUFZMkIsT0FBT0MsY0FBYyxDQUFDLENBQUMsSUFBSTtJQUVwRSxPQUFPN0IsSUFBSThCLE1BQU0sR0FBR0MsSUFBSSxDQUFDOUI7QUFDN0I7QUFHQUgsV0FBVyxHQUFHLFNBQVVtQyxFQUFFLEVBQUUvQixPQUFPO0lBRS9CLE9BQU9OLElBQUlzQyxLQUFLLENBQUNELE1BQU1BLEtBQUtyQyxJQUFJdUMsTUFBTSxDQUFDRixJQUFJL0I7QUFDL0M7QUFHQUosZUFBZSxHQUFHLFNBQVV1QyxJQUFJLEVBQUV0QyxNQUFNLEVBQUVHLFVBQVUsQ0FBQyxDQUFDO0lBRWxEUCxPQUFPUSxhQUFhLENBQUNELFNBQVM7UUFBQztLQUFTO0lBRXhDLG9DQUFvQztJQUVwQyxNQUFNb0MsTUFBTXZDLFVBQVVBLE1BQU0sQ0FBQ0osT0FBTzRDLE9BQU8sQ0FBQ0QsR0FBRyxDQUFDO0lBQ2hELElBQUlBLEtBQUs7UUFDTDdDLE9BQU9TLFFBQVFzQyxNQUFNLElBQUlGLElBQUlHLE9BQU8sS0FBSzlDLE9BQU84QyxPQUFPLEVBQUUsaURBQWlESCxJQUFJRyxPQUFPLEVBQUU5QyxPQUFPOEMsT0FBTztRQUNySSxPQUFPMUM7SUFDWDtJQUVBLGtCQUFrQjtJQUVsQixJQUFJLE9BQU9BLFdBQVcsWUFDbEIsQ0FBQ0csUUFBUXNDLE1BQU0sRUFBRTtRQUVqQixPQUFPMUMsUUFBUUMsTUFBTSxDQUFDc0MsTUFBTXRDLFFBQVE7WUFBRU0sWUFBWTtRQUFLLElBQWEsK0NBQStDO0lBQ3ZIO0lBRUEsaUNBQWlDO0lBRWpDLE1BQU1xQyxXQUFXN0MsVUFBVThDLElBQUksQ0FBQzVDO0lBQ2hDLElBQUksQ0FBQzJDLFVBQVU7UUFDWCxPQUFPNUMsUUFBUUMsTUFBTSxDQUFDc0MsTUFBTXRDLFFBQVE7WUFBRU0sWUFBWTtRQUFLO0lBQzNEO0lBRUEsT0FBT3FDLFNBQVNOLE9BQU8sQ0FBQ00sU0FBU0wsSUFBSSxFQUFFdEM7QUFDM0M7QUFHQUYsVUFBVThDLElBQUksR0FBRyxTQUFVNUMsTUFBTTtJQUU3QixJQUFJLE9BQU9BLFdBQVcsVUFBVTtRQUM1QixPQUFPO0lBQ1g7SUFFQSxJQUFJVSxNQUFNQyxPQUFPLENBQUNYLFNBQVM7UUFDdkIsS0FBSyxNQUFNcUIsUUFBUXJCLE9BQVE7WUFDdkIsTUFBTTJDLFdBQVc3QyxVQUFVOEMsSUFBSSxDQUFDdkI7WUFDaEMsSUFBSXNCLFVBQVU7Z0JBQ1YsT0FBT0E7WUFDWDtRQUNKO1FBRUEsT0FBTztJQUNYO0lBRUEsTUFBTUosTUFBTXZDLE1BQU0sQ0FBQ0osT0FBTzRDLE9BQU8sQ0FBQ0QsR0FBRyxDQUFDO0lBQ3RDLElBQUlBLEtBQUs7UUFDTCxPQUFPO1lBQUVELE1BQU10QyxNQUFNLENBQUN1QyxJQUFJRCxJQUFJLENBQUM7WUFBRUQsU0FBU0UsSUFBSUYsT0FBTztRQUFDO0lBQzFEO0lBRUEzQyxPQUFPbUMsT0FBT0MsY0FBYyxDQUFDOUIsWUFBWTZCLE9BQU9DLGNBQWMsQ0FBQyxDQUFDLElBQUk7SUFFcEUsSUFBSyxNQUFNZSxPQUFPN0MsT0FBUTtRQUN0QixNQUFNMkMsV0FBVzdDLFVBQVU4QyxJQUFJLENBQUM1QyxNQUFNLENBQUM2QyxJQUFJO1FBQzNDLElBQUlGLFVBQVU7WUFDVixPQUFPQTtRQUNYO0lBQ0o7SUFFQSxPQUFPO0FBQ1g7QUFHQTdDLFVBQVVtQixNQUFNLEdBQUcsU0FBVTZCLEtBQUs7SUFFOUIsT0FBT0EsVUFBVSxRQUFRO1FBQUM7UUFBVztRQUFVO0tBQVMsQ0FBQ0MsUUFBUSxDQUFDLE9BQU9EO0FBQzdFO0FBR0EvQyxZQUFZLEdBQUcsU0FBVUMsTUFBTSxFQUFFaUQsU0FBUyxFQUFFOUMsT0FBTztJQUUvQyxJQUFJQSxZQUFZSyxXQUFXO1FBQ3ZCZCxPQUFPdUQsYUFBYSxPQUFPQSxjQUFjLFVBQVU7UUFFbkQ5QyxVQUFVOEM7UUFDVkEsWUFBWXBELElBQUl1QyxNQUFNLENBQUM7SUFDM0I7SUFFQSxJQUFJMUIsTUFBTUMsT0FBTyxDQUFDUixVQUFVO1FBQ3hCQSxVQUFVO1lBQUUrQyxRQUFRL0M7UUFBUTtJQUNoQztJQUVBUCxPQUFPUSxhQUFhLENBQUNELFNBQVM7UUFBQztRQUFNO1FBQU87UUFBUTtRQUFhO1FBQVU7S0FBUTtJQUVuRixtQkFBbUI7SUFFbkIsSUFBSVAsT0FBT3dCLFFBQVEsQ0FBQzZCLFlBQVk7UUFDNUJ2RCxPQUFPUyxRQUFRZ0QsRUFBRSxLQUFLM0MsV0FBVztRQUNqQ2QsT0FBT1MsUUFBUWlELEdBQUcsS0FBSzVDLFdBQVc7UUFDbENkLE9BQU9TLFFBQVErQyxNQUFNLEtBQUsxQyxXQUFXO1FBRXJDLE9BQU9WLFVBQVVtRCxTQUFTLENBQUNqRCxRQUFRO1lBQUVtRCxJQUFJRjtZQUFXSSxNQUFNbEQsUUFBUWtELElBQUk7WUFBRUMsV0FBV25ELFFBQVFtRCxTQUFTO1lBQUVDLE9BQU9wRCxRQUFRb0QsS0FBSztRQUFDO0lBQy9IO0lBRUEsbUJBQW1CO0lBRW5CN0QsT0FBT0csSUFBSXNDLEtBQUssQ0FBQ2MsY0FBYyxPQUFPQSxjQUFjLFVBQVUsc0JBQXNCQTtJQUNwRnZELE9BQU9TLFFBQVFpRCxHQUFHLEtBQUs1QyxhQUFhTCxRQUFRZ0QsRUFBRSxLQUFLM0MsV0FBVztJQUU5RCxJQUFJTCxRQUFRK0MsTUFBTSxLQUFLMUMsV0FBVztRQUM5QixJQUFJZ0QsT0FBT3JEO1FBQ1gsSUFBSUEsUUFBUWlELEdBQUcsS0FBSzVDLFdBQVc7WUFDM0JnRCxPQUFPO2dCQUFFTCxJQUFJaEQsUUFBUWlELEdBQUc7Z0JBQUVDLE1BQU1sRCxRQUFRbUQsU0FBUztnQkFBRUEsV0FBV25ELFFBQVFrRCxJQUFJO2dCQUFFRSxPQUFPcEQsUUFBUW9ELEtBQUs7WUFBQztRQUNyRztRQUVBLElBQUlKLEtBQUtLLEtBQUtMLEVBQUUsS0FBSzNDLFlBQVlSLE9BQU95RCxTQUFTLENBQUNELEtBQUtMLEVBQUUsSUFBSW5ELE9BQU8wRCxNQUFNLENBQUNDLE9BQU8sQ0FBQyxNQUFNLE9BQU8sR0FBRyxJQUFJQyxRQUFRO1FBQy9HbEUsT0FBTzhELEtBQUtILElBQUksS0FBSzdDLGFBQWFnRCxLQUFLRixTQUFTLEtBQUs5QyxXQUFXO1FBQ2hFZCxPQUFPOEQsS0FBS0QsS0FBSyxLQUFLL0MsYUFBYWdELEtBQUtILElBQUksS0FBSzdDLGFBQWFnRCxLQUFLRixTQUFTLEtBQUs5QyxXQUFXO1FBRTVGLElBQUlMLFFBQVFnRCxFQUFFLEtBQUszQyxhQUNmLENBQUNYLElBQUlzQyxLQUFLLENBQUNoQyxRQUFRZ0QsRUFBRSxLQUNyQixDQUFDdkQsT0FBT3dCLFFBQVEsQ0FBQ2pCLFFBQVFnRCxFQUFFLEdBQUc7WUFFOUJBLEtBQUtBLEdBQUdTLFFBQVEsSUFBd0IsK0RBQStEO1FBQzNHO1FBRUEsT0FBTzlELFVBQVVtRCxTQUFTLENBQUNqRCxRQUFRO1lBQUVpQyxLQUFLbEMsUUFBUWtDLEdBQUcsQ0FBQ2dCO1lBQVlFO1lBQUlFLE1BQU1HLEtBQUtILElBQUk7WUFBRUMsV0FBV0UsS0FBS0YsU0FBUztZQUFFQyxPQUFPQyxLQUFLRCxLQUFLO1FBQUM7SUFDeEk7SUFFQSxtQkFBbUI7SUFFbkI3RCxPQUFPZ0IsTUFBTUMsT0FBTyxDQUFDUixRQUFRK0MsTUFBTSxHQUFHO0lBQ3RDeEQsT0FBT1MsUUFBUWdELEVBQUUsS0FBSzNDLFdBQVc7SUFDakNkLE9BQU9TLFFBQVFpRCxHQUFHLEtBQUs1QyxXQUFXO0lBQ2xDZCxPQUFPUyxRQUFRa0QsSUFBSSxLQUFLN0MsV0FBVztJQUVuQyxNQUFNZ0QsT0FBTztRQUNUdkIsS0FBS2xDLFFBQVFrQyxHQUFHLENBQUNnQjtRQUNqQkMsUUFBUSxFQUFFO1FBQ1ZLLE9BQU9wRCxRQUFRb0QsS0FBSztJQUN4QjtJQUVBLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJMUQsUUFBUStDLE1BQU0sQ0FBQ3RDLE1BQU0sRUFBRSxFQUFFaUQsRUFBRztRQUM1QyxNQUFNQyxPQUFPM0QsUUFBUStDLE1BQU0sQ0FBQ1csRUFBRTtRQUM5QixNQUFNRSxPQUFPRixNQUFNMUQsUUFBUStDLE1BQU0sQ0FBQ3RDLE1BQU0sR0FBRztRQUUzQ2hCLE9BQU9RLGFBQWEsQ0FBQzBELE1BQU1DLE9BQU87WUFBQztZQUFNO1lBQVE7U0FBWSxHQUFHO1lBQUM7WUFBTTtTQUFPO1FBRTlFckUsT0FBT29FLEtBQUtYLEVBQUUsS0FBSzNDLFdBQVc7UUFDOUJkLE9BQU9vRSxLQUFLVCxJQUFJLEtBQUs3QyxXQUFXO1FBRWhDLE1BQU1hLE9BQU87WUFDVDhCLElBQUluRCxPQUFPeUQsU0FBUyxDQUFDSyxLQUFLWCxFQUFFO1lBQzVCRSxNQUFNckQsT0FBT3lELFNBQVMsQ0FBQ0ssS0FBS1QsSUFBSTtRQUNwQztRQUVBLElBQUksQ0FBQ3hELElBQUlzQyxLQUFLLENBQUMyQixLQUFLWCxFQUFFLEtBQ2xCLENBQUN2RCxPQUFPd0IsUUFBUSxDQUFDMEMsS0FBS1gsRUFBRSxHQUFHO1lBRTNCOUIsS0FBSzhCLEVBQUUsR0FBRzlCLEtBQUs4QixFQUFFLENBQUNTLFFBQVEsSUFBYywrREFBK0Q7UUFDM0c7UUFFQSxJQUFJRyxNQUFNO1lBQ05yRSxPQUFPUyxRQUFRbUQsU0FBUyxLQUFLOUMsYUFBYXNELEtBQUtSLFNBQVMsS0FBSzlDLFdBQVc7WUFDeEUsTUFBTThDLFlBQVluRCxRQUFRbUQsU0FBUyxLQUFLOUMsWUFBWUwsUUFBUW1ELFNBQVMsR0FBR1EsS0FBS1IsU0FBUztZQUN0RixJQUFJQSxjQUFjOUMsV0FBVztnQkFDekJkLE9BQU84RCxLQUFLRCxLQUFLLEtBQUsvQyxXQUFXO2dCQUNqQ2EsS0FBS2lDLFNBQVMsR0FBR3RELE9BQU95RCxTQUFTLENBQUNIO1lBQ3RDO1FBQ0o7UUFFQUUsS0FBS04sTUFBTSxDQUFDYyxJQUFJLENBQUMzQztJQUNyQjtJQUVBLE9BQU9tQztBQUNYO0FBR0ExRCxVQUFVbUQsU0FBUyxHQUFHLFNBQVVqRCxNQUFNLEVBQUVpRCxTQUFTO0lBRTdDLEtBQUssTUFBTUosT0FBTztRQUFDO1FBQVE7S0FBWSxDQUFFO1FBQ3JDLElBQUlJLFNBQVMsQ0FBQ0osSUFBSSxLQUFLckMsV0FBVztZQUM5QixPQUFPeUMsU0FBUyxDQUFDSixJQUFJO1FBQ3pCLE9BQ0s7WUFDREksU0FBUyxDQUFDSixJQUFJLEdBQUc3QyxPQUFPeUQsU0FBUyxDQUFDUixTQUFTLENBQUNKLElBQUk7UUFDcEQ7SUFDSjtJQUVBLE9BQU9JO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL2NvbXBpbGUuanM/NGFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnNjaGVtYSA9IGZ1bmN0aW9uIChKb2ksIGNvbmZpZywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FwcGVuZFBhdGgnLCAnb3ZlcnJpZGUnXSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNjaGVtYShKb2ksIGNvbmZpZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwZW5kUGF0aCAmJlxuICAgICAgICAgICAgZXJyLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAoJHtlcnIucGF0aH0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWEgPSBmdW5jdGlvbiAoSm9pLCBjb25maWcsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChjb25maWcgIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgdW5kZWZpbmVkIHNjaGVtYScpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICBBc3NlcnQoY29uZmlnLmxlbmd0aCwgJ0ludmFsaWQgZW1wdHkgYXJyYXkgc2NoZW1hJyk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZ1swXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gKGJhc2UsIC4uLnZhbHVlcykgPT4ge1xuXG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UudmFsaWQoSm9pLm92ZXJyaWRlLCAuLi52YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2UudmFsaWQoLi4udmFsdWVzKTtcbiAgICB9O1xuXG4gICAgaWYgKGludGVybmFscy5zaW1wbGUoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBKb2kuY3VzdG9tKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzY2hlbWEgY29udGVudDonLCB0eXBlb2YgY29uZmlnKTtcblxuICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnNpbXBsZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKb2kuYWx0ZXJuYXRpdmVzKCkudHJ5KC4uLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCAuLi5jb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIEpvaS5zdHJpbmcoKS5yZWdleChjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2kuZGF0ZSgpLCBjb25maWcpO1xuICAgIH1cblxuICAgIEFzc2VydChPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uZmlnKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSwgJ1NjaGVtYSBjYW4gb25seSBjb250YWluIHBsYWluIG9iamVjdHMnKTtcblxuICAgIHJldHVybiBKb2kub2JqZWN0KCkua2V5cyhjb25maWcpO1xufTtcblxuXG5leHBvcnRzLnJlZiA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIFJlZi5pc1JlZihpZCkgPyBpZCA6IFJlZi5jcmVhdGUoaWQsIG9wdGlvbnMpO1xufTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAocm9vdCwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnbGVnYWN5J10pO1xuXG4gICAgLy8gQ29tcGlsZWQgYnkgYW55IHN1cHBvcnRlZCB2ZXJzaW9uXG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWEgJiYgc2NoZW1hW0NvbW1vbi5zeW1ib2xzLmFueV07XG4gICAgaWYgKGFueSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5sZWdhY3kgfHwgYW55LnZlcnNpb24gPT09IENvbW1vbi52ZXJzaW9uLCAnQ2Fubm90IG1peCBkaWZmZXJlbnQgdmVyc2lvbnMgb2Ygam9pIHNjaGVtYXM6JywgYW55LnZlcnNpb24sIENvbW1vbi52ZXJzaW9uKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICAvLyBVbmNvbXBpbGVkIHJvb3RcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhb3B0aW9ucy5sZWdhY3kpIHtcblxuICAgICAgICByZXR1cm4gZXhwb3J0cy5zY2hlbWEocm9vdCwgc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7ICAgICAgICAgIC8vIFdpbGwgZXJyb3IgaWYgc2NoZW1hIGNvbnRhaW5zIG90aGVyIHZlcnNpb25zXG4gICAgfVxuXG4gICAgLy8gU2NhbiBzY2hlbWEgZm9yIGNvbXBpbGVkIHBhcnRzXG5cbiAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKHNjaGVtYSk7XG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zY2hlbWEocm9vdCwgc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGUoY29tcGlsZXIucm9vdCwgc2NoZW1hKTtcbn07XG5cblxuaW50ZXJuYWxzLndhbGsgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hW0NvbW1vbi5zeW1ib2xzLmFueV07XG4gICAgaWYgKGFueSkge1xuICAgICAgICByZXR1cm4geyByb290OiBzY2hlbWFbYW55LnJvb3RdLCBjb21waWxlOiBhbnkuY29tcGlsZSB9O1xuICAgIH1cblxuICAgIEFzc2VydChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2NoZW1hKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSwgJ1NjaGVtYSBjYW4gb25seSBjb250YWluIHBsYWluIG9iamVjdHMnKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKHNjaGVtYVtrZXldKTtcbiAgICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuaW50ZXJuYWxzLnNpbXBsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IFsnYm9vbGVhbicsICdzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy53aGVuID0gZnVuY3Rpb24gKHNjaGVtYSwgY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEFzc2VydChjb25kaXRpb24gJiYgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ29iamVjdCcsICdNaXNzaW5nIG9wdGlvbnMnKTtcblxuICAgICAgICBvcHRpb25zID0gY29uZGl0aW9uO1xuICAgICAgICBjb25kaXRpb24gPSBSZWYuY3JlYXRlKCcuJyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgc3dpdGNoOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpcycsICdub3QnLCAndGhlbicsICdvdGhlcndpc2UnLCAnc3dpdGNoJywgJ2JyZWFrJ10pO1xuXG4gICAgLy8gU2NoZW1hIGNvbmRpdGlvblxuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShjb25kaXRpb24pKSB7XG4gICAgICAgIEFzc2VydChvcHRpb25zLmlzID09PSB1bmRlZmluZWQsICdcImlzXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkLCAnXCJub3RcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuc3dpdGNoID09PSB1bmRlZmluZWQsICdcInN3aXRjaFwiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY29uZGl0aW9uKHNjaGVtYSwgeyBpczogY29uZGl0aW9uLCB0aGVuOiBvcHRpb25zLnRoZW4sIG90aGVyd2lzZTogb3B0aW9ucy5vdGhlcndpc2UsIGJyZWFrOiBvcHRpb25zLmJyZWFrIH0pO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBjb25kaXRpb25cblxuICAgIEFzc2VydChSZWYuaXNSZWYoY29uZGl0aW9uKSB8fCB0eXBlb2YgY29uZGl0aW9uID09PSAnc3RyaW5nJywgJ0ludmFsaWQgY29uZGl0aW9uOicsIGNvbmRpdGlvbik7XG4gICAgQXNzZXJ0KG9wdGlvbnMubm90ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJpc1wiIHdpdGggXCJub3RcIicpO1xuXG4gICAgaWYgKG9wdGlvbnMuc3dpdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5ub3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVsZSA9IHsgaXM6IG9wdGlvbnMubm90LCB0aGVuOiBvcHRpb25zLm90aGVyd2lzZSwgb3RoZXJ3aXNlOiBvcHRpb25zLnRoZW4sIGJyZWFrOiBvcHRpb25zLmJyZWFrIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXMgPSBydWxlLmlzICE9PSB1bmRlZmluZWQgPyBzY2hlbWEuJF9jb21waWxlKHJ1bGUuaXMpIDogc2NoZW1hLiRfcm9vdC5pbnZhbGlkKG51bGwsIGZhbHNlLCAwLCAnJykucmVxdWlyZWQoKTtcbiAgICAgICAgQXNzZXJ0KHJ1bGUudGhlbiAhPT0gdW5kZWZpbmVkIHx8IHJ1bGUub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQsICdvcHRpb25zIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgXCJ0aGVuXCIsIFwib3RoZXJ3aXNlXCIsIG9yIFwic3dpdGNoXCInKTtcbiAgICAgICAgQXNzZXJ0KHJ1bGUuYnJlYWsgPT09IHVuZGVmaW5lZCB8fCBydWxlLnRoZW4gPT09IHVuZGVmaW5lZCB8fCBydWxlLm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgdGhlbiwgb3RoZXJ3aXNlLCBhbmQgYnJlYWsgYWxsIHRvZ2V0aGVyJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIVJlZi5pc1JlZihvcHRpb25zLmlzKSAmJlxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYShvcHRpb25zLmlzKSkge1xuXG4gICAgICAgICAgICBpcyA9IGlzLnJlcXVpcmVkKCk7ICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSByZXF1aXJlZCBpZiB0aGlzIHdhc24ndCBhbHJlYWR5IGEgc2NoZW1hIG9yIGEgcmVmXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNvbmRpdGlvbihzY2hlbWEsIHsgcmVmOiBleHBvcnRzLnJlZihjb25kaXRpb24pLCBpcywgdGhlbjogcnVsZS50aGVuLCBvdGhlcndpc2U6IHJ1bGUub3RoZXJ3aXNlLCBicmVhazogcnVsZS5icmVhayB9KTtcbiAgICB9XG5cbiAgICAvLyBTd2l0Y2ggc3RhdGVtZW50XG5cbiAgICBBc3NlcnQoQXJyYXkuaXNBcnJheShvcHRpb25zLnN3aXRjaCksICdcInN3aXRjaFwiIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICBBc3NlcnQob3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwiaXNcIicpO1xuICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwibm90XCInKTtcbiAgICBBc3NlcnQob3B0aW9ucy50aGVuID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcInN3aXRjaFwiIHdpdGggXCJ0aGVuXCInKTtcblxuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHJlZjogZXhwb3J0cy5yZWYoY29uZGl0aW9uKSxcbiAgICAgICAgc3dpdGNoOiBbXSxcbiAgICAgICAgYnJlYWs6IG9wdGlvbnMuYnJlYWtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLnN3aXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0ZXN0ID0gb3B0aW9ucy5zd2l0Y2hbaV07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBpID09PSBvcHRpb25zLnN3aXRjaC5sZW5ndGggLSAxO1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKHRlc3QsIGxhc3QgPyBbJ2lzJywgJ3RoZW4nLCAnb3RoZXJ3aXNlJ10gOiBbJ2lzJywgJ3RoZW4nXSk7XG5cbiAgICAgICAgQXNzZXJ0KHRlc3QuaXMgIT09IHVuZGVmaW5lZCwgJ1N3aXRjaCBzdGF0ZW1lbnQgbWlzc2luZyBcImlzXCInKTtcbiAgICAgICAgQXNzZXJ0KHRlc3QudGhlbiAhPT0gdW5kZWZpbmVkLCAnU3dpdGNoIHN0YXRlbWVudCBtaXNzaW5nIFwidGhlblwiJyk7XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIGlzOiBzY2hlbWEuJF9jb21waWxlKHRlc3QuaXMpLFxuICAgICAgICAgICAgdGhlbjogc2NoZW1hLiRfY29tcGlsZSh0ZXN0LnRoZW4pXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFSZWYuaXNSZWYodGVzdC5pcykgJiZcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEodGVzdC5pcykpIHtcblxuICAgICAgICAgICAgaXRlbS5pcyA9IGl0ZW0uaXMucmVxdWlyZWQoKTsgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgcmVxdWlyZWQgaWYgdGhpcyB3YXNuJ3QgYWxyZWFkeSBhIHNjaGVtYSBvciBhIHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIEFzc2VydChvcHRpb25zLm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkIHx8IHRlc3Qub3RoZXJ3aXNlID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSBcIm90aGVyd2lzZVwiIGluc2lkZSBhbmQgb3V0c2lkZSBhIFwic3dpdGNoXCInKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyd2lzZSA9IG9wdGlvbnMub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm90aGVyd2lzZSA6IHRlc3Qub3RoZXJ3aXNlO1xuICAgICAgICAgICAgaWYgKG90aGVyd2lzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJ1bGUuYnJlYWsgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggb3RoZXJ3aXNlIGFuZCBicmVhaycpO1xuICAgICAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlID0gc2NoZW1hLiRfY29tcGlsZShvdGhlcndpc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVsZS5zd2l0Y2gucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbmRpdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGNvbmRpdGlvbikge1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgWyd0aGVuJywgJ290aGVyd2lzZSddKSB7XG4gICAgICAgIGlmIChjb25kaXRpb25ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZGl0aW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25kaXRpb25ba2V5XSA9IHNjaGVtYS4kX2NvbXBpbGUoY29uZGl0aW9uW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmRpdGlvbjtcbn07XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkNvbW1vbiIsIlJlZiIsImludGVybmFscyIsImV4cG9ydHMiLCJzY2hlbWEiLCJKb2kiLCJjb25maWciLCJvcHRpb25zIiwiYXNzZXJ0T3B0aW9ucyIsImVyciIsImFwcGVuZFBhdGgiLCJwYXRoIiwidW5kZWZpbmVkIiwibWVzc2FnZSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInZhbGlkIiwiYmFzZSIsInZhbHVlcyIsIm92ZXJyaWRlIiwic2ltcGxlIiwiY3VzdG9tIiwiaXNSZXNvbHZhYmxlIiwiaXNTY2hlbWEiLCJpdGVtIiwiYWx0ZXJuYXRpdmVzIiwidHJ5IiwiUmVnRXhwIiwic3RyaW5nIiwicmVnZXgiLCJEYXRlIiwiZGF0ZSIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0Iiwia2V5cyIsInJlZiIsImlkIiwiaXNSZWYiLCJjcmVhdGUiLCJjb21waWxlIiwicm9vdCIsImFueSIsInN5bWJvbHMiLCJsZWdhY3kiLCJ2ZXJzaW9uIiwiY29tcGlsZXIiLCJ3YWxrIiwia2V5IiwidmFsdWUiLCJpbmNsdWRlcyIsIndoZW4iLCJjb25kaXRpb24iLCJzd2l0Y2giLCJpcyIsIm5vdCIsInRoZW4iLCJvdGhlcndpc2UiLCJicmVhayIsInJ1bGUiLCIkX2NvbXBpbGUiLCIkX3Jvb3QiLCJpbnZhbGlkIiwicmVxdWlyZWQiLCJpIiwidGVzdCIsImxhc3QiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/compile.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/errors.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/errors.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Annotate = __webpack_require__(/*! ./annotate */ \"(rsc)/./node_modules/joi/lib/annotate.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Template = __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\nconst internals = {};\nexports.Report = class {\n    constructor(code, value, local, flags, messages, state, prefs){\n        this.code = code;\n        this.flags = flags;\n        this.messages = messages;\n        this.path = state.path;\n        this.prefs = prefs;\n        this.state = state;\n        this.value = value;\n        this.message = null;\n        this.template = null;\n        this.local = local || {};\n        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);\n        if (this.value !== undefined && !this.local.hasOwnProperty(\"value\")) {\n            this.local.value = this.value;\n        }\n        if (this.path.length) {\n            const key = this.path[this.path.length - 1];\n            if (typeof key !== \"object\") {\n                this.local.key = key;\n            }\n        }\n    }\n    _setTemplate(template) {\n        this.template = template;\n        if (!this.flags.label && this.path.length === 0) {\n            const localized = this._template(this.template, \"root\");\n            if (localized) {\n                this.local.label = localized;\n            }\n        }\n    }\n    toString() {\n        if (this.message) {\n            return this.message;\n        }\n        const code = this.code;\n        if (!this.prefs.errors.render) {\n            return this.code;\n        }\n        const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);\n        if (template === undefined) {\n            return `Error code \"${code}\" is not defined, your custom type is missing the correct messages definition`;\n        }\n        // Render and cache result\n        this.message = template.render(this.value, this.state, this.prefs, this.local, {\n            errors: this.prefs.errors,\n            messages: [\n                this.prefs.messages,\n                this.messages\n            ]\n        });\n        if (!this.prefs.errors.label) {\n            this.message = this.message.replace(/^\"\" /, \"\").trim();\n        }\n        return this.message;\n    }\n    _template(messages, code) {\n        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);\n    }\n};\nexports.path = function(path) {\n    let label = \"\";\n    for (const segment of path){\n        if (typeof segment === \"object\") {\n            continue;\n        }\n        if (typeof segment === \"string\") {\n            if (label) {\n                label += \".\";\n            }\n            label += segment;\n        } else {\n            label += `[${segment}]`;\n        }\n    }\n    return label;\n};\nexports.template = function(value, messages, code, state, prefs) {\n    if (!messages) {\n        return;\n    }\n    if (Template.isTemplate(messages)) {\n        return code !== \"root\" ? messages : null;\n    }\n    let lang = prefs.errors.language;\n    if (Common.isResolvable(lang)) {\n        lang = lang.resolve(value, state, prefs);\n    }\n    if (lang && messages[lang]) {\n        if (messages[lang][code] !== undefined) {\n            return messages[lang][code];\n        }\n        if (messages[lang][\"*\"] !== undefined) {\n            return messages[lang][\"*\"];\n        }\n    }\n    if (!messages[code]) {\n        return messages[\"*\"];\n    }\n    return messages[code];\n};\nexports.label = function(flags, state, prefs, messages) {\n    if (!prefs.errors.label) {\n        return \"\";\n    }\n    if (flags.label) {\n        return flags.label;\n    }\n    let path = state.path;\n    if (prefs.errors.label === \"key\" && state.path.length > 1) {\n        path = state.path.slice(-1);\n    }\n    const normalized = exports.path(path);\n    if (normalized) {\n        return normalized;\n    }\n    return exports.template(null, prefs.messages, \"root\", state, prefs) || messages && exports.template(null, messages, \"root\", state, prefs) || \"value\";\n};\nexports.process = function(errors, original, prefs) {\n    if (!errors) {\n        return null;\n    }\n    const { override, message, details } = exports.details(errors);\n    if (override) {\n        return override;\n    }\n    if (prefs.errors.stack) {\n        return new exports.ValidationError(message, details, original);\n    }\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    const validationError = new exports.ValidationError(message, details, original);\n    Error.stackTraceLimit = limit;\n    return validationError;\n};\nexports.details = function(errors, options = {}) {\n    let messages = [];\n    const details = [];\n    for (const item of errors){\n        // Override\n        if (item instanceof Error) {\n            if (options.override !== false) {\n                return {\n                    override: item\n                };\n            }\n            const message = item.toString();\n            messages.push(message);\n            details.push({\n                message,\n                type: \"override\",\n                context: {\n                    error: item\n                }\n            });\n            continue;\n        }\n        // Report\n        const message = item.toString();\n        messages.push(message);\n        details.push({\n            message,\n            path: item.path.filter((v)=>typeof v !== \"object\"),\n            type: item.code,\n            context: item.local\n        });\n    }\n    if (messages.length > 1) {\n        messages = [\n            ...new Set(messages)\n        ];\n    }\n    return {\n        message: messages.join(\". \"),\n        details\n    };\n};\nexports.ValidationError = class extends Error {\n    constructor(message, details, original){\n        super(message);\n        this._original = original;\n        this.details = details;\n    }\n    static isError(err) {\n        return err instanceof exports.ValidationError;\n    }\n};\nexports.ValidationError.prototype.isJoi = true;\nexports.ValidationError.prototype.name = \"ValidationError\";\nexports.ValidationError.prototype.annotate = Annotate.error;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxXQUFXQyxtQkFBT0EsQ0FBQztBQUN6QixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQztBQUd6QixNQUFNRyxZQUFZLENBQUM7QUFHbkJDLGNBQWMsR0FBRztJQUViRSxZQUFZQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLENBQUU7UUFFM0QsSUFBSSxDQUFDTixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0csSUFBSSxHQUFHRixNQUFNRSxJQUFJO1FBQ3RCLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0osS0FBSyxHQUFHQTtRQUViLElBQUksQ0FBQ08sT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFFaEIsSUFBSSxDQUFDUCxLQUFLLEdBQUdBLFNBQVMsQ0FBQztRQUN2QixJQUFJLENBQUNBLEtBQUssQ0FBQ1EsS0FBSyxHQUFHYixRQUFRYSxLQUFLLENBQUMsSUFBSSxDQUFDUCxLQUFLLEVBQUUsSUFBSSxDQUFDRSxLQUFLLEVBQUUsSUFBSSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDRixRQUFRO1FBRWxGLElBQUksSUFBSSxDQUFDSCxLQUFLLEtBQUtVLGFBQ2YsQ0FBQyxJQUFJLENBQUNULEtBQUssQ0FBQ1UsY0FBYyxDQUFDLFVBQVU7WUFFckMsSUFBSSxDQUFDVixLQUFLLENBQUNELEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7UUFDakM7UUFFQSxJQUFJLElBQUksQ0FBQ00sSUFBSSxDQUFDTSxNQUFNLEVB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QUNuQztZQUVkMEIsUUFBUVMsSUFBSSxDQUFDO2dCQUNUbkM7Z0JBQ0FvQyxNQUFNO2dCQUNOQyxTQUFTO29CQUFFQyxPQUFPSjtnQkFBSztZQUMzQjtZQUVBO1FBQ0o7UUFFQSxTQUFTO1FBRVQsTUFBTWxDLFVBQVVrQyxLQUFLeEIsUUFBUTtRQUM3QmQsU0FBU3VDLElBQUksQ0FBQ25DO1FBRWQwQixRQUFRUyxJQUFJLENBQUM7WUFDVG5DO1lBQ0FELE1BQU1tQyxLQUFLbkMsSUFBSSxDQUFDd0MsTUFBTSxDQUFDLENBQUNDLElBQU0sT0FBT0EsTUFBTTtZQUMzQ0osTUFBTUYsS0FBSzFDLElBQUk7WUFDZjZDLFNBQVNILEtBQUt4QyxLQUFLO1FBQ3ZCO0lBQ0o7SUFFQSxJQUFJRSxTQUFTUyxNQUFNLEdBQUcsR0FBRztRQUNyQlQsV0FBVztlQUFJLElBQUk2QyxJQUFJN0M7U0FBVTtJQUNyQztJQUVBLE9BQU87UUFBRUksU0FBU0osU0FBUzhDLElBQUksQ0FBQztRQUFPaEI7SUFBUTtBQUNuRDtBQUdBckMsdUJBQXVCLEdBQUcsY0FBY3lDO0lBRXBDdkMsWUFBWVMsT0FBTyxFQUFFMEIsT0FBTyxFQUFFRixRQUFRLENBQUU7UUFFcEMsS0FBSyxDQUFDeEI7UUFDTixJQUFJLENBQUMyQyxTQUFTLEdBQUduQjtRQUNqQixJQUFJLENBQUNFLE9BQU8sR0FBR0E7SUFDbkI7SUFFQSxPQUFPa0IsUUFBUUMsR0FBRyxFQUFFO1FBRWhCLE9BQU9BLGVBQWV4RCxRQUFRdUMsZUFBZTtJQUNqRDtBQUNKO0FBR0F2Qyx1Q0FBdUMsR0FBRztBQUUxQ0Esc0NBQXNDLEdBQUc7QUFFekNBLDBDQUEwQyxHQUFHTCxTQUFTc0QsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXJyb3JzLmpzP2Q0NzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBbm5vdGF0ZSA9IHJlcXVpcmUoJy4vYW5ub3RhdGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLlJlcG9ydCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5wYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgdGhpcy5wcmVmcyA9IHByZWZzO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwgfHwge307XG4gICAgICAgIHRoaXMubG9jYWwubGFiZWwgPSBleHBvcnRzLmxhYmVsKHRoaXMuZmxhZ3MsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMsIHRoaXMubWVzc2FnZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmxvY2FsLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG5cbiAgICAgICAgICAgIHRoaXMubG9jYWwudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmtleSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MubGFiZWwgJiZcbiAgICAgICAgICAgIHRoaXMucGF0aC5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5fdGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgJ3Jvb3QnKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmxhYmVsID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZWZzLmVycm9ycy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlKHRoaXMudGVtcGxhdGUpIHx8XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSh0aGlzLnByZWZzLm1lc3NhZ2VzKSB8fFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUodGhpcy5tZXNzYWdlcyk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgY29kZSBcIiR7Y29kZX1cIiBpcyBub3QgZGVmaW5lZCwgeW91ciBjdXN0b20gdHlwZSBpcyBtaXNzaW5nIHRoZSBjb3JyZWN0IG1lc3NhZ2VzIGRlZmluaXRpb25gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGFuZCBjYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0ZW1wbGF0ZS5yZW5kZXIodGhpcy52YWx1ZSwgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcywgdGhpcy5sb2NhbCwgeyBlcnJvcnM6IHRoaXMucHJlZnMuZXJyb3JzLCBtZXNzYWdlczogW3RoaXMucHJlZnMubWVzc2FnZXMsIHRoaXMubWVzc2FnZXNdIH0pO1xuICAgICAgICBpZiAoIXRoaXMucHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UucmVwbGFjZSgvXlwiXCIgLywgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgX3RlbXBsYXRlKG1lc3NhZ2VzLCBjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUodGhpcy52YWx1ZSwgbWVzc2FnZXMsIGNvZGUgfHwgdGhpcy5jb2RlLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMucGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdvYmplY3QnKSB7ICAgICAgICAgIC8vIEV4Y2x1ZGUgYXJyYXkgc2luZ2xlIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCArPSAnLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsICs9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCArPSBgWyR7c2VnbWVudH1dYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn07XG5cblxuZXhwb3J0cy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIGNvZGUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZXMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlICE9PSAncm9vdCcgPyBtZXNzYWdlcyA6IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGxhbmcgPSBwcmVmcy5lcnJvcnMubGFuZ3VhZ2U7XG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUobGFuZykpIHtcbiAgICAgICAgbGFuZyA9IGxhbmcucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAobGFuZyAmJlxuICAgICAgICBtZXNzYWdlc1tsYW5nXSkge1xuXG4gICAgICAgIGlmIChtZXNzYWdlc1tsYW5nXVtjb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bY29kZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVzc2FnZXNbbGFuZ11bJyonXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bJyonXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWVzc2FnZXNbY29kZV0pIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzWycqJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzW2NvZGVdO1xufTtcblxuXG5leHBvcnRzLmxhYmVsID0gZnVuY3Rpb24gKGZsYWdzLCBzdGF0ZSwgcHJlZnMsIG1lc3NhZ2VzKSB7XG5cbiAgICBpZiAoIXByZWZzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmbGFncy5sYWJlbDtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgaWYgKHByZWZzLmVycm9ycy5sYWJlbCA9PT0gJ2tleScgJiZcbiAgICAgICAgc3RhdGUucGF0aC5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgcGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoLTEpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBleHBvcnRzLnBhdGgocGF0aCk7XG4gICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUobnVsbCwgcHJlZnMubWVzc2FnZXMsICdyb290Jywgc3RhdGUsIHByZWZzKSB8fFxuICAgICAgICBtZXNzYWdlcyAmJiBleHBvcnRzLnRlbXBsYXRlKG51bGwsIG1lc3NhZ2VzLCAncm9vdCcsIHN0YXRlLCBwcmVmcykgfHxcbiAgICAgICAgJ3ZhbHVlJztcbn07XG5cblxuZXhwb3J0cy5wcm9jZXNzID0gZnVuY3Rpb24gKGVycm9ycywgb3JpZ2luYWwsIHByZWZzKSB7XG5cbiAgICBpZiAoIWVycm9ycykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IG92ZXJyaWRlLCBtZXNzYWdlLCBkZXRhaWxzIH0gPSBleHBvcnRzLmRldGFpbHMoZXJyb3JzKTtcbiAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5lcnJvcnMuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpO1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3I7XG59O1xuXG5cbmV4cG9ydHMuZGV0YWlscyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgbGV0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3QgZGV0YWlscyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGVycm9ycykge1xuXG4gICAgICAgIC8vIE92ZXJyaWRlXG5cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcnJpZGU6IGl0ZW0gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHsgZXJyb3I6IGl0ZW0gfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwb3J0XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgICAgICBkZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aC5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ICE9PSAnb2JqZWN0JyksXG4gICAgICAgICAgICB0eXBlOiBpdGVtLmNvZGUsXG4gICAgICAgICAgICBjb250ZXh0OiBpdGVtLmxvY2FsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1lc3NhZ2VzID0gWy4uLm5ldyBTZXQobWVzc2FnZXMpXTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlcy5qb2luKCcuICcpLCBkZXRhaWxzIH07XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCkge1xuXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbCA9IG9yaWdpbmFsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0Vycm9yKGVycikge1xuXG4gICAgICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBleHBvcnRzLlZhbGlkYXRpb25FcnJvcjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5pc0pvaSA9IHRydWU7XG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5hbm5vdGF0ZSA9IEFubm90YXRlLmVycm9yO1xuIl0sIm5hbWVzIjpbIkFubm90YXRlIiwicmVxdWlyZSIsIkNvbW1vbiIsIlRlbXBsYXRlIiwiaW50ZXJuYWxzIiwiZXhwb3J0cyIsIlJlcG9ydCIsImNvbnN0cnVjdG9yIiwiY29kZSIsInZhbHVlIiwibG9jYWwiLCJmbGFncyIsIm1lc3NhZ2VzIiwic3RhdGUiLCJwcmVmcyIsInBhdGgiLCJtZXNzYWdlIiwidGVtcGxhdGUiLCJsYWJlbCIsInVuZGVmaW5lZCIsImhhc093blByb3BlcnR5IiwibGVuZ3RoIiwia2V5IiwiX3NldFRlbXBsYXRlIiwibG9jYWxpemVkIiwiX3RlbXBsYXRlIiwidG9TdHJpbmciLCJlcnJvcnMiLCJyZW5kZXIiLCJyZXBsYWNlIiwidHJpbSIsInNlZ21lbnQiLCJpc1RlbXBsYXRlIiwibGFuZyIsImxhbmd1YWdlIiwiaXNSZXNvbHZhYmxlIiwicmVzb2x2ZSIsInNsaWNlIiwibm9ybWFsaXplZCIsInByb2Nlc3MiLCJvcmlnaW5hbCIsIm92ZXJyaWRlIiwiZGV0YWlscyIsInN0YWNrIiwiVmFsaWRhdGlvbkVycm9yIiwibGltaXQiLCJFcnJvciIsInN0YWNrVHJhY2VMaW1pdCIsInZhbGlkYXRpb25FcnJvciIsIm9wdGlvbnMiLCJpdGVtIiwicHVzaCIsInR5cGUiLCJjb250ZXh0IiwiZXJyb3IiLCJmaWx0ZXIiLCJ2IiwiU2V0Iiwiam9pbiIsIl9vcmlnaW5hbCIsImlzRXJyb3IiLCJlcnIiLCJwcm90b3R5cGUiLCJpc0pvaSIsIm5hbWUiLCJhbm5vdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/extend.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/extend.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\nconst internals = {};\nexports.type = function(from, options) {\n    const base = Object.getPrototypeOf(from);\n    const prototype = Clone(base);\n    const schema = from._assign(Object.create(prototype));\n    const def = Object.assign({}, options); // Shallow cloned\n    delete def.base;\n    prototype._definition = def;\n    const parent = base._definition || {};\n    def.messages = Messages.merge(parent.messages, def.messages);\n    def.properties = Object.assign({}, parent.properties, def.properties);\n    // Type\n    schema.type = def.type;\n    // Flags\n    def.flags = Object.assign({}, parent.flags, def.flags);\n    // Terms\n    const terms = Object.assign({}, parent.terms);\n    if (def.terms) {\n        for(const name in def.terms){\n            const term = def.terms[name];\n            Assert(schema.$_terms[name] === undefined, \"Invalid term override for\", def.type, name);\n            schema.$_terms[name] = term.init;\n            terms[name] = term;\n        }\n    }\n    def.terms = terms;\n    // Constructor arguments\n    if (!def.args) {\n        def.args = parent.args;\n    }\n    // Prepare\n    def.prepare = internals.prepare(def.prepare, parent.prepare);\n    // Coerce\n    if (def.coerce) {\n        if (typeof def.coerce === \"function\") {\n            def.coerce = {\n                method: def.coerce\n            };\n        }\n        if (def.coerce.from && !Array.isArray(def.coerce.from)) {\n            def.coerce = {\n                method: def.coerce.method,\n                from: [].concat(def.coerce.from)\n            };\n        }\n    }\n    def.coerce = internals.coerce(def.coerce, parent.coerce);\n    // Validate\n    def.validate = internals.validate(def.validate, parent.validate);\n    // Rules\n    const rules = Object.assign({}, parent.rules);\n    if (def.rules) {\n        for(const name in def.rules){\n            const rule = def.rules[name];\n            Assert(typeof rule === \"object\", \"Invalid rule definition for\", def.type, name);\n            let method = rule.method;\n            if (method === undefined) {\n                method = function() {\n                    return this.$_addRule(name);\n                };\n            }\n            if (method) {\n                Assert(!prototype[name], \"Rule conflict in\", def.type, name);\n                prototype[name] = method;\n            }\n            Assert(!rules[name], \"Rule conflict in\", def.type, name);\n            rules[name] = rule;\n            if (rule.alias) {\n                const aliases = [].concat(rule.alias);\n                for (const alias of aliases){\n                    prototype[alias] = rule.method;\n                }\n            }\n            if (rule.args) {\n                rule.argsByName = new Map();\n                rule.args = rule.args.map((arg)=>{\n                    if (typeof arg === \"string\") {\n                        arg = {\n                            name: arg\n                        };\n                    }\n                    Assert(!rule.argsByName.has(arg.name), \"Duplicated argument name\", arg.name);\n                    if (Common.isSchema(arg.assert)) {\n                        arg.assert = arg.assert.strict().label(arg.name);\n                    }\n                    rule.argsByName.set(arg.name, arg);\n                    return arg;\n                });\n            }\n        }\n    }\n    def.rules = rules;\n    // Modifiers\n    const modifiers = Object.assign({}, parent.modifiers);\n    if (def.modifiers) {\n        for(const name in def.modifiers){\n            Assert(!prototype[name], \"Rule conflict in\", def.type, name);\n            const modifier = def.modifiers[name];\n            Assert(typeof modifier === \"function\", \"Invalid modifier definition for\", def.type, name);\n            const method = function(arg) {\n                return this.rule({\n                    [name]: arg\n                });\n            };\n            prototype[name] = method;\n            modifiers[name] = modifier;\n        }\n    }\n    def.modifiers = modifiers;\n    // Overrides\n    if (def.overrides) {\n        prototype._super = base;\n        schema.$_super = {}; // Backwards compatibility\n        for(const override in def.overrides){\n            Assert(base[override], \"Cannot override missing\", override);\n            def.overrides[override][Common.symbols.parent] = base[override];\n            schema.$_super[override] = base[override].bind(schema); // Backwards compatibility\n        }\n        Object.assign(prototype, def.overrides);\n    }\n    // Casts\n    def.cast = Object.assign({}, parent.cast, def.cast);\n    // Manifest\n    const manifest = Object.assign({}, parent.manifest, def.manifest);\n    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);\n    def.manifest = manifest;\n    // Rebuild\n    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);\n    return schema;\n};\n// Helpers\ninternals.build = function(child, parent) {\n    if (!child || !parent) {\n        return child || parent;\n    }\n    return function(obj, desc) {\n        return parent(child(obj, desc), desc);\n    };\n};\ninternals.coerce = function(child, parent) {\n    if (!child || !parent) {\n        return child || parent;\n    }\n    return {\n        from: child.from && parent.from ? [\n            ...new Set([\n                ...child.from,\n                ...parent.from\n            ])\n        ] : null,\n        method (value, helpers) {\n            let coerced;\n            if (!parent.from || parent.from.includes(typeof value)) {\n                coerced = parent.method(value, helpers);\n                if (coerced) {\n                    if (coerced.errors || coerced.value === undefined) {\n                        return coerced;\n                    }\n                    value = coerced.value;\n                }\n            }\n            if (!child.from || child.from.includes(typeof value)) {\n                const own = child.method(value, helpers);\n                if (own) {\n                    return own;\n                }\n            }\n            return coerced;\n        }\n    };\n};\ninternals.prepare = function(child, parent) {\n    if (!child || !parent) {\n        return child || parent;\n    }\n    return function(value, helpers) {\n        const prepared = child(value, helpers);\n        if (prepared) {\n            if (prepared.errors || prepared.value === undefined) {\n                return prepared;\n            }\n            value = prepared.value;\n        }\n        return parent(value, helpers) || prepared;\n    };\n};\ninternals.rebuild = function(child, parent) {\n    if (!child || !parent) {\n        return child || parent;\n    }\n    return function(schema) {\n        parent(schema);\n        child(schema);\n    };\n};\ninternals.validate = function(child, parent) {\n    if (!child || !parent) {\n        return child || parent;\n    }\n    return function(value, helpers) {\n        const result = parent(value, helpers);\n        if (result) {\n            if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {\n                return result;\n            }\n            value = result.value;\n        }\n        return child(value, helpers) || result;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxDQUFDOEMsU0FDRCxDQUFDOUMsUUFBUTtRQUVULE9BQU84QyxTQUFTOUM7SUFDcEI7SUFFQSxPQUFPLFNBQVVrRCxLQUFLLEVBQUVDLE9BQU87UUFFM0IsTUFBTUssV0FBV1YsTUFBTUksT0FBT0M7UUFDOUIsSUFBSUssVUFBVTtZQUNWLElBQUlBLFNBQVNGLE1BQU0sSUFDZkUsU0FBU04sS0FBSyxLQUFLekMsV0FBVztnQkFFOUIsT0FBTytDO1lBQ1g7WUFFQU4sUUFBUU0sU0FBU04sS0FBSztRQUMxQjtRQUVBLE9BQU9sRCxPQUFPa0QsT0FBT0MsWUFBWUs7SUFDckM7QUFDSjtBQUdBdkUsVUFBVTRELE9BQU8sR0FBRyxTQUFVQyxLQUFLLEVBQUU5QyxNQUFNO0lBRXZDLElBQUksQ0FBQzhDLFNBQ0QsQ0FBQzlDLFFBQVE7UUFFVCxPQUFPOEMsU0FBUzlDO0lBQ3BCO0lBRUEsT0FBTyxTQUFVTixNQUFNO1FBRW5CTSxPQUFPTjtRQUNQb0QsTUFBTXBEO0lBQ1Y7QUFDSjtBQUdBVCxVQUFVaUMsUUFBUSxHQUFHLFNBQVU0QixLQUFLLEVBQUU5QyxNQUFNO0lBRXhDLElBQUksQ0FBQzhDLFNBQ0QsQ0FBQzlDLFFBQVE7UUFFVCxPQUFPOEMsU0FBUzlDO0lBQ3BCO0lBRUEsT0FBTyxTQUFVa0QsS0FBSyxFQUFFQyxPQUFPO1FBRTNCLE1BQU1NLFNBQVN6RCxPQUFPa0QsT0FBT0M7UUFDN0IsSUFBSU0sUUFBUTtZQUNSLElBQUlBLE9BQU9ILE1BQU0sSUFDWixFQUFDdkMsTUFBTUMsT0FBTyxDQUFDeUMsT0FBT0gsTUFBTSxLQUFLRyxPQUFPSCxNQUFNLENBQUNJLE1BQU0sR0FBRztnQkFFekQsT0FBT0Q7WUFDWDtZQUVBUCxRQUFRTyxPQUFPUCxLQUFLO1FBQ3hCO1FBRUEsT0FBT0osTUFBTUksT0FBT0MsWUFBWU07SUFDcEM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvZXh0ZW5kLmpzP2U3MGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIChmcm9tLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBiYXNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZyb20pO1xuICAgIGNvbnN0IHByb3RvdHlwZSA9IENsb25lKGJhc2UpO1xuICAgIGNvbnN0IHNjaGVtYSA9IGZyb20uX2Fzc2lnbihPYmplY3QuY3JlYXRlKHByb3RvdHlwZSkpO1xuICAgIGNvbnN0IGRlZiA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgZGVsZXRlIGRlZi5iYXNlO1xuXG4gICAgcHJvdG90eXBlLl9kZWZpbml0aW9uID0gZGVmO1xuXG4gICAgY29uc3QgcGFyZW50ID0gYmFzZS5fZGVmaW5pdGlvbiB8fCB7fTtcbiAgICBkZWYubWVzc2FnZXMgPSBNZXNzYWdlcy5tZXJnZShwYXJlbnQubWVzc2FnZXMsIGRlZi5tZXNzYWdlcyk7XG4gICAgZGVmLnByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQucHJvcGVydGllcywgZGVmLnByb3BlcnRpZXMpO1xuXG4gICAgLy8gVHlwZVxuXG4gICAgc2NoZW1hLnR5cGUgPSBkZWYudHlwZTtcblxuICAgIC8vIEZsYWdzXG5cbiAgICBkZWYuZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQuZmxhZ3MsIGRlZi5mbGFncyk7XG5cbiAgICAvLyBUZXJtc1xuXG4gICAgY29uc3QgdGVybXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQudGVybXMpO1xuICAgIGlmIChkZWYudGVybXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi50ZXJtcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IG93biB0ZXJtc1xuICAgICAgICAgICAgY29uc3QgdGVybSA9IGRlZi50ZXJtc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydChzY2hlbWEuJF90ZXJtc1tuYW1lXSA9PT0gdW5kZWZpbmVkLCAnSW52YWxpZCB0ZXJtIG92ZXJyaWRlIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zW25hbWVdID0gdGVybS5pbml0O1xuICAgICAgICAgICAgdGVybXNbbmFtZV0gPSB0ZXJtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLnRlcm1zID0gdGVybXM7XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBhcmd1bWVudHNcblxuICAgIGlmICghZGVmLmFyZ3MpIHtcbiAgICAgICAgZGVmLmFyZ3MgPSBwYXJlbnQuYXJncztcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlXG5cbiAgICBkZWYucHJlcGFyZSA9IGludGVybmFscy5wcmVwYXJlKGRlZi5wcmVwYXJlLCBwYXJlbnQucHJlcGFyZSk7XG5cbiAgICAvLyBDb2VyY2VcblxuICAgIGlmIChkZWYuY29lcmNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmLmNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVmLmNvZXJjZSA9IHsgbWV0aG9kOiBkZWYuY29lcmNlIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmLmNvZXJjZS5mcm9tICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShkZWYuY29lcmNlLmZyb20pKSB7XG5cbiAgICAgICAgICAgIGRlZi5jb2VyY2UgPSB7IG1ldGhvZDogZGVmLmNvZXJjZS5tZXRob2QsIGZyb206IFtdLmNvbmNhdChkZWYuY29lcmNlLmZyb20pIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYuY29lcmNlID0gaW50ZXJuYWxzLmNvZXJjZShkZWYuY29lcmNlLCBwYXJlbnQuY29lcmNlKTtcblxuICAgIC8vIFZhbGlkYXRlXG5cbiAgICBkZWYudmFsaWRhdGUgPSBpbnRlcm5hbHMudmFsaWRhdGUoZGVmLnZhbGlkYXRlLCBwYXJlbnQudmFsaWRhdGUpO1xuXG4gICAgLy8gUnVsZXNcblxuICAgIGNvbnN0IHJ1bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnJ1bGVzKTtcbiAgICBpZiAoZGVmLnJ1bGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBkZWYucnVsZXNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJ1bGUgPT09ICdvYmplY3QnLCAnSW52YWxpZCBydWxlIGRlZmluaXRpb24gZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gcnVsZS5tZXRob2Q7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXByb3RvdHlwZVtuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQoIXJ1bGVzW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIHJ1bGVzW25hbWVdID0gcnVsZTtcblxuICAgICAgICAgICAgaWYgKHJ1bGUuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGlhc2VzID0gW10uY29uY2F0KHJ1bGUuYWxpYXMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVbYWxpYXNdID0gcnVsZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcnVsZS5hcmdzQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXJncyA9IHJ1bGUuYXJncy5tYXAoKGFyZykgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0geyBuYW1lOiBhcmcgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghcnVsZS5hcmdzQnlOYW1lLmhhcyhhcmcubmFtZSksICdEdXBsaWNhdGVkIGFyZ3VtZW50IG5hbWUnLCBhcmcubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShhcmcuYXNzZXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnLmFzc2VydCA9IGFyZy5hc3NlcnQuc3RyaWN0KCkubGFiZWwoYXJnLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hcmdzQnlOYW1lLnNldChhcmcubmFtZSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5ydWxlcyA9IHJ1bGVzO1xuXG4gICAgLy8gTW9kaWZpZXJzXG5cbiAgICBjb25zdCBtb2RpZmllcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQubW9kaWZpZXJzKTtcbiAgICBpZiAoZGVmLm1vZGlmaWVycykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgQXNzZXJ0KCFwcm90b3R5cGVbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllciA9IGRlZi5tb2RpZmllcnNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGlmaWVyID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBtb2RpZmllciBkZWZpbml0aW9uIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKGFyZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVsZSh7IFtuYW1lXTogYXJnIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcHJvdG90eXBlW25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgbW9kaWZpZXJzW25hbWVdID0gbW9kaWZpZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXG4gICAgLy8gT3ZlcnJpZGVzXG5cbiAgICBpZiAoZGVmLm92ZXJyaWRlcykge1xuICAgICAgICBwcm90b3R5cGUuX3N1cGVyID0gYmFzZTtcbiAgICAgICAgc2NoZW1hLiRfc3VwZXIgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBmb3IgKGNvbnN0IG92ZXJyaWRlIGluIGRlZi5vdmVycmlkZXMpIHtcbiAgICAgICAgICAgIEFzc2VydChiYXNlW292ZXJyaWRlXSwgJ0Nhbm5vdCBvdmVycmlkZSBtaXNzaW5nJywgb3ZlcnJpZGUpO1xuICAgICAgICAgICAgZGVmLm92ZXJyaWRlc1tvdmVycmlkZV1bQ29tbW9uLnN5bWJvbHMucGFyZW50XSA9IGJhc2Vbb3ZlcnJpZGVdO1xuICAgICAgICAgICAgc2NoZW1hLiRfc3VwZXJbb3ZlcnJpZGVdID0gYmFzZVtvdmVycmlkZV0uYmluZChzY2hlbWEpOyAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHByb3RvdHlwZSwgZGVmLm92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FzdHNcblxuICAgIGRlZi5jYXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LmNhc3QsIGRlZi5jYXN0KTtcblxuICAgIC8vIE1hbmlmZXN0XG5cbiAgICBjb25zdCBtYW5pZmVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5tYW5pZmVzdCwgZGVmLm1hbmlmZXN0KTtcbiAgICBtYW5pZmVzdC5idWlsZCA9IGludGVybmFscy5idWlsZChkZWYubWFuaWZlc3QgJiYgZGVmLm1hbmlmZXN0LmJ1aWxkLCBwYXJlbnQubWFuaWZlc3QgJiYgcGFyZW50Lm1hbmlmZXN0LmJ1aWxkKTtcbiAgICBkZWYubWFuaWZlc3QgPSBtYW5pZmVzdDtcblxuICAgIC8vIFJlYnVpbGRcblxuICAgIGRlZi5yZWJ1aWxkID0gaW50ZXJuYWxzLnJlYnVpbGQoZGVmLnJlYnVpbGQsIHBhcmVudC5yZWJ1aWxkKTtcblxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmJ1aWxkID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gcGFyZW50KGNoaWxkKG9iaiwgZGVzYyksIGRlc2MpO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5jb2VyY2UgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBjaGlsZC5mcm9tICYmIHBhcmVudC5mcm9tID8gWy4uLm5ldyBTZXQoWy4uLmNoaWxkLmZyb20sIC4uLnBhcmVudC5mcm9tXSldIDogbnVsbCxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgIGxldCBjb2VyY2VkO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIGNvZXJjZWQgPSBwYXJlbnQubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAoY29lcmNlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29lcmNlZC5lcnJvcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2hpbGQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIGNoaWxkLmZyb20uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3duID0gY2hpbGQubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAob3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvd247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cbmludGVybmFscy5wcmVwYXJlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgIGNvbnN0IHByZXBhcmVkID0gY2hpbGQodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocHJlcGFyZWQpIHtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZC5lcnJvcnMgfHxcbiAgICAgICAgICAgICAgICBwcmVwYXJlZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlcGFyZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcHJlcGFyZWQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50KHZhbHVlLCBoZWxwZXJzKSB8fCBwcmVwYXJlZDtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMucmVidWlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICAgICAgcGFyZW50KHNjaGVtYSk7XG4gICAgICAgIGNoaWxkKHNjaGVtYSk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcmVudCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzICYmXG4gICAgICAgICAgICAgICAgKCFBcnJheS5pc0FycmF5KHJlc3VsdC5lcnJvcnMpIHx8IHJlc3VsdC5lcnJvcnMubGVuZ3RoKSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQodmFsdWUsIGhlbHBlcnMpIHx8IHJlc3VsdDtcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJBc3NlcnQiLCJyZXF1aXJlIiwiQ2xvbmUiLCJDb21tb24iLCJNZXNzYWdlcyIsImludGVybmFscyIsImV4cG9ydHMiLCJ0eXBlIiwiZnJvbSIsIm9wdGlvbnMiLCJiYXNlIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJzY2hlbWEiLCJfYXNzaWduIiwiY3JlYXRlIiwiZGVmIiwiYXNzaWduIiwiX2RlZmluaXRpb24iLCJwYXJlbnQiLCJtZXNzYWdlcyIsIm1lcmdlIiwicHJvcGVydGllcyIsImZsYWdzIiwidGVybXMiLCJuYW1lIiwidGVybSIsIiRfdGVybXMiLCJ1bmRlZmluZWQiLCJpbml0IiwiYXJncyIsInByZXBhcmUiLCJjb2VyY2UiLCJtZXRob2QiLCJBcnJheSIsImlzQXJyYXkiLCJjb25jYXQiLCJ2YWxpZGF0ZSIsInJ1bGVzIiwicnVsZSIsIiRfYWRkUnVsZSIsImFsaWFzIiwiYWxpYXNlcyIsImFyZ3NCeU5hbWUiLCJNYXAiLCJtYXAiLCJhcmciLCJoYXMiLCJpc1NjaGVtYSIsImFzc2VydCIsInN0cmljdCIsImxhYmVsIiwic2V0IiwibW9kaWZpZXJzIiwibW9kaWZpZXIiLCJvdmVycmlkZXMiLCJfc3VwZXIiLCIkX3N1cGVyIiwib3ZlcnJpZGUiLCJzeW1ib2xzIiwiYmluZCIsImNhc3QiLCJtYW5pZmVzdCIsImJ1aWxkIiwicmVidWlsZCIsImNoaWxkIiwib2JqIiwiZGVzYyIsIlNldCIsInZhbHVlIiwiaGVscGVycyIsImNvZXJjZWQiLCJpbmNsdWRlcyIsImVycm9ycyIsIm93biIsInByZXBhcmVkIiwicmVzdWx0IiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/extend.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/index.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/joi/lib/cache.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ./compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Extend = __webpack_require__(/*! ./extend */ \"(rsc)/./node_modules/joi/lib/extend.js\");\nconst Manifest = __webpack_require__(/*! ./manifest */ \"(rsc)/./node_modules/joi/lib/manifest.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\nconst Trace = __webpack_require__(/*! ./trace */ \"(rsc)/./node_modules/joi/lib/trace.js\");\nlet Schemas;\nconst internals = {\n    types: {\n        alternatives: __webpack_require__(/*! ./types/alternatives */ \"(rsc)/./node_modules/joi/lib/types/alternatives.js\"),\n        any: __webpack_require__(/*! ./types/any */ \"(rsc)/./node_modules/joi/lib/types/any.js\"),\n        array: __webpack_require__(/*! ./types/array */ \"(rsc)/./node_modules/joi/lib/types/array.js\"),\n        boolean: __webpack_require__(/*! ./types/boolean */ \"(rsc)/./node_modules/joi/lib/types/boolean.js\"),\n        date: __webpack_require__(/*! ./types/date */ \"(rsc)/./node_modules/joi/lib/types/date.js\"),\n        function: __webpack_require__(/*! ./types/function */ \"(rsc)/./node_modules/joi/lib/types/function.js\"),\n        link: __webpack_require__(/*! ./types/link */ \"(rsc)/./node_modules/joi/lib/types/link.js\"),\n        number: __webpack_require__(/*! ./types/number */ \"(rsc)/./node_modules/joi/lib/types/number.js\"),\n        object: __webpack_require__(/*! ./types/object */ \"(rsc)/./node_modules/joi/lib/types/object.js\"),\n        string: __webpack_require__(/*! ./types/string */ \"(rsc)/./node_modules/joi/lib/types/string.js\"),\n        symbol: __webpack_require__(/*! ./types/symbol */ \"(rsc)/./node_modules/joi/lib/types/symbol.js\")\n    },\n    aliases: {\n        alt: \"alternatives\",\n        bool: \"boolean\",\n        func: \"function\"\n    }\n};\nif (Buffer) {\n    internals.types.binary = __webpack_require__(/*! ./types/binary */ \"(rsc)/./node_modules/joi/lib/types/binary.js\");\n}\ninternals.root = function() {\n    const root = {\n        _types: new Set(Object.keys(internals.types))\n    };\n    // Types\n    for (const type of root._types){\n        root[type] = function(...args) {\n            Assert(!args.length || [\n                \"alternatives\",\n                \"link\",\n                \"object\"\n            ].includes(type), \"The\", type, \"type does not allow arguments\");\n            return internals.generate(this, internals.types[type], args);\n        };\n    }\n    // Shortcuts\n    for (const method of [\n        \"allow\",\n        \"custom\",\n        \"disallow\",\n        \"equal\",\n        \"exist\",\n        \"forbidden\",\n        \"invalid\",\n        \"not\",\n        \"only\",\n        \"optional\",\n        \"options\",\n        \"prefs\",\n        \"preferences\",\n        \"required\",\n        \"strip\",\n        \"valid\",\n        \"when\"\n    ]){\n        root[method] = function(...args) {\n            return this.any()[method](...args);\n        };\n    }\n    // Methods\n    Object.assign(root, internals.methods);\n    // Aliases\n    for(const alias in internals.aliases){\n        const target = internals.aliases[alias];\n        root[alias] = root[target];\n    }\n    root.x = root.expression;\n    // Trace\n    if (Trace.setup) {\n        Trace.setup(root);\n    }\n    return root;\n};\ninternals.methods = {\n    ValidationError: Errors.ValidationError,\n    version: Common.version,\n    cache: Cache.provider,\n    assert (value, schema, ...args /* [message], [options] */ ) {\n        internals.assert(value, schema, true, args);\n    },\n    attempt (value, schema, ...args /* [message], [options] */ ) {\n        return internals.assert(value, schema, false, args);\n    },\n    build (desc) {\n        Assert(typeof Manifest.build === \"function\", \"Manifest functionality disabled\");\n        return Manifest.build(this, desc);\n    },\n    checkPreferences (prefs) {\n        Common.checkPreferences(prefs);\n    },\n    compile (schema, options) {\n        return Compile.compile(this, schema, options);\n    },\n    defaults (modifier) {\n        Assert(typeof modifier === \"function\", \"modifier must be a function\");\n        const joi = Object.assign({}, this);\n        for (const type of joi._types){\n            const schema = modifier(joi[type]());\n            Assert(Common.isSchema(schema), \"modifier must return a valid schema object\");\n            joi[type] = function(...args) {\n                return internals.generate(this, schema, args);\n            };\n        }\n        return joi;\n    },\n    expression (...args) {\n        return new Template(...args);\n    },\n    extend (...extensions) {\n        Common.verifyFlat(extensions, \"extend\");\n        Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/joi/lib/schemas.js\");\n        Assert(extensions.length, \"You need to provide at least one extension\");\n        this.assert(extensions, Schemas.extensions);\n        const joi = Object.assign({}, this);\n        joi._types = new Set(joi._types);\n        for (let extension of extensions){\n            if (typeof extension === \"function\") {\n                extension = extension(joi);\n            }\n            this.assert(extension, Schemas.extension);\n            const expanded = internals.expandExtension(extension, joi);\n            for (const item of expanded){\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), \"Cannot override name\", item.type);\n                const base = item.base || this.any();\n                const schema = Extend.type(base, item);\n                joi._types.add(item.type);\n                joi[item.type] = function(...args) {\n                    return internals.generate(this, schema, args);\n                };\n            }\n        }\n        return joi;\n    },\n    isError: Errors.ValidationError.isError,\n    isExpression: Template.isTemplate,\n    isRef: Ref.isRef,\n    isSchema: Common.isSchema,\n    in (...args) {\n        return Ref.in(...args);\n    },\n    override: Common.symbols.override,\n    ref (...args) {\n        return Ref.create(...args);\n    },\n    types () {\n        const types = {};\n        for (const type of this._types){\n            types[type] = this[type]();\n        }\n        for(const target in internals.aliases){\n            types[target] = this[target]();\n        }\n        return types;\n    }\n};\n// Helpers\ninternals.assert = function(value, schema, annotate, args /* [message], [options] */ ) {\n    const message = args[0] instanceof Error || typeof args[0] === \"string\" ? args[0] : null;\n    const options = message !== null ? args[1] : args[0];\n    const result = schema.validate(value, Common.preferences({\n        errors: {\n            stack: true\n        }\n    }, options || {}));\n    let error = result.error;\n    if (!error) {\n        return result.value;\n    }\n    if (message instanceof Error) {\n        throw message;\n    }\n    const display = annotate && typeof error.annotate === \"function\" ? error.annotate() : error.message;\n    if (error instanceof Errors.ValidationError === false) {\n        error = Clone(error);\n    }\n    error.message = message ? `${message} ${display}` : display;\n    throw error;\n};\ninternals.generate = function(root, schema, args) {\n    Assert(root, \"Must be invoked on a Joi instance.\");\n    schema.$_root = root;\n    if (!schema._definition.args || !args.length) {\n        return schema;\n    }\n    return schema._definition.args(schema, ...args);\n};\ninternals.expandExtension = function(extension, joi) {\n    if (typeof extension.type === \"string\") {\n        return [\n            extension\n        ];\n    }\n    const extended = [];\n    for (const type of joi._types){\n        if (extension.type.test(type)) {\n            const item = Object.assign({}, extension);\n            item.type = type;\n            item.base = joi[type]();\n            extended.push(item);\n        }\n    }\n    return extended;\n};\nmodule.exports = internals.root();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBR0E7WUFDWnFDLEtBQUtHLElBQUksR0FBR1gsR0FBRyxDQUFDN0IsS0FBSztZQUNyQitELFNBQVNFLElBQUksQ0FBQzVCO1FBQ2xCO0lBQ0o7SUFFQSxPQUFPMEI7QUFDWDtBQUdBRyxPQUFPQyxPQUFPLEdBQUczRixVQUFVbUIsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvaW5kZXguanM/MDQ1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbmNvbnN0IE1hbmlmZXN0ID0gcmVxdWlyZSgnLi9tYW5pZmVzdCcpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlJyk7XG5cbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB0eXBlczoge1xuICAgICAgICBhbHRlcm5hdGl2ZXM6IHJlcXVpcmUoJy4vdHlwZXMvYWx0ZXJuYXRpdmVzJyksXG4gICAgICAgIGFueTogcmVxdWlyZSgnLi90eXBlcy9hbnknKSxcbiAgICAgICAgYXJyYXk6IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXknKSxcbiAgICAgICAgYm9vbGVhbjogcmVxdWlyZSgnLi90eXBlcy9ib29sZWFuJyksXG4gICAgICAgIGRhdGU6IHJlcXVpcmUoJy4vdHlwZXMvZGF0ZScpLFxuICAgICAgICBmdW5jdGlvbjogcmVxdWlyZSgnLi90eXBlcy9mdW5jdGlvbicpLFxuICAgICAgICBsaW5rOiByZXF1aXJlKCcuL3R5cGVzL2xpbmsnKSxcbiAgICAgICAgbnVtYmVyOiByZXF1aXJlKCcuL3R5cGVzL251bWJlcicpLFxuICAgICAgICBvYmplY3Q6IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0JyksXG4gICAgICAgIHN0cmluZzogcmVxdWlyZSgnLi90eXBlcy9zdHJpbmcnKSxcbiAgICAgICAgc3ltYm9sOiByZXF1aXJlKCcuL3R5cGVzL3N5bWJvbCcpXG4gICAgfSxcbiAgICBhbGlhc2VzOiB7XG4gICAgICAgIGFsdDogJ2FsdGVybmF0aXZlcycsXG4gICAgICAgIGJvb2w6ICdib29sZWFuJyxcbiAgICAgICAgZnVuYzogJ2Z1bmN0aW9uJ1xuICAgIH1cbn07XG5cblxuaWYgKEJ1ZmZlcikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgaW50ZXJuYWxzLnR5cGVzLmJpbmFyeSA9IHJlcXVpcmUoJy4vdHlwZXMvYmluYXJ5Jyk7XG59XG5cblxuaW50ZXJuYWxzLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCByb290ID0ge1xuICAgICAgICBfdHlwZXM6IG5ldyBTZXQoT2JqZWN0LmtleXMoaW50ZXJuYWxzLnR5cGVzKSlcbiAgICB9O1xuXG4gICAgLy8gVHlwZXNcblxuICAgIGZvciAoY29uc3QgdHlwZSBvZiByb290Ll90eXBlcykge1xuICAgICAgICByb290W3R5cGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KCFhcmdzLmxlbmd0aCB8fCBbJ2FsdGVybmF0aXZlcycsICdsaW5rJywgJ29iamVjdCddLmluY2x1ZGVzKHR5cGUpLCAnVGhlJywgdHlwZSwgJ3R5cGUgZG9lcyBub3QgYWxsb3cgYXJndW1lbnRzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlKHRoaXMsIGludGVybmFscy50eXBlc1t0eXBlXSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU2hvcnRjdXRzXG5cbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ2FsbG93JywgJ2N1c3RvbScsICdkaXNhbGxvdycsICdlcXVhbCcsICdleGlzdCcsICdmb3JiaWRkZW4nLCAnaW52YWxpZCcsICdub3QnLCAnb25seScsICdvcHRpb25hbCcsICdvcHRpb25zJywgJ3ByZWZzJywgJ3ByZWZlcmVuY2VzJywgJ3JlcXVpcmVkJywgJ3N0cmlwJywgJ3ZhbGlkJywgJ3doZW4nXSkge1xuICAgICAgICByb290W21ldGhvZF0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbnkoKVttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1ldGhvZHNcblxuICAgIE9iamVjdC5hc3NpZ24ocm9vdCwgaW50ZXJuYWxzLm1ldGhvZHMpO1xuXG4gICAgLy8gQWxpYXNlc1xuXG4gICAgZm9yIChjb25zdCBhbGlhcyBpbiBpbnRlcm5hbHMuYWxpYXNlcykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpbnRlcm5hbHMuYWxpYXNlc1thbGlhc107XG4gICAgICAgIHJvb3RbYWxpYXNdID0gcm9vdFt0YXJnZXRdO1xuICAgIH1cblxuICAgIHJvb3QueCA9IHJvb3QuZXhwcmVzc2lvbjtcblxuICAgIC8vIFRyYWNlXG5cbiAgICBpZiAoVHJhY2Uuc2V0dXApIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgVHJhY2Uuc2V0dXAocm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3Q7XG59O1xuXG5cbmludGVybmFscy5tZXRob2RzID0ge1xuXG4gICAgVmFsaWRhdGlvbkVycm9yOiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yLFxuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNhY2hlOiBDYWNoZS5wcm92aWRlcixcblxuICAgIGFzc2VydCh2YWx1ZSwgc2NoZW1hLCAuLi5hcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLmFzc2VydCh2YWx1ZSwgc2NoZW1hLCB0cnVlLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgYXR0ZW1wdCh2YWx1ZSwgc2NoZW1hLCAuLi5hcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hc3NlcnQodmFsdWUsIHNjaGVtYSwgZmFsc2UsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBidWlsZChkZXNjKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBNYW5pZmVzdC5idWlsZCA9PT0gJ2Z1bmN0aW9uJywgJ01hbmlmZXN0IGZ1bmN0aW9uYWxpdHkgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE1hbmlmZXN0LmJ1aWxkKHRoaXMsIGRlc2MpO1xuICAgIH0sXG5cbiAgICBjaGVja1ByZWZlcmVuY2VzKHByZWZzKSB7XG5cbiAgICAgICAgQ29tbW9uLmNoZWNrUHJlZmVyZW5jZXMocHJlZnMpO1xuICAgIH0sXG5cbiAgICBjb21waWxlKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBDb21waWxlLmNvbXBpbGUodGhpcywgc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZGVmYXVsdHMobW9kaWZpZXIpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGlmaWVyID09PSAnZnVuY3Rpb24nLCAnbW9kaWZpZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgY29uc3Qgam9pID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBqb2kuX3R5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBtb2RpZmllcihqb2lbdHlwZV0oKSk7XG4gICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSksICdtb2RpZmllciBtdXN0IHJldHVybiBhIHZhbGlkIHNjaGVtYSBvYmplY3QnKTtcblxuICAgICAgICAgICAgam9pW3R5cGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgc2NoZW1hLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH0sXG5cbiAgICBleHByZXNzaW9uKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBleHRlbmQoLi4uZXh0ZW5zaW9ucykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KGV4dGVuc2lvbnMsICdleHRlbmQnKTtcblxuICAgICAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgICAgICBBc3NlcnQoZXh0ZW5zaW9ucy5sZW5ndGgsICdZb3UgbmVlZCB0byBwcm92aWRlIGF0IGxlYXN0IG9uZSBleHRlbnNpb24nKTtcbiAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9ucywgU2NoZW1hcy5leHRlbnNpb25zKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzKTtcbiAgICAgICAgam9pLl90eXBlcyA9IG5ldyBTZXQoam9pLl90eXBlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uKGpvaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGV4dGVuc2lvbiwgU2NoZW1hcy5leHRlbnNpb24pO1xuXG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZCA9IGludGVybmFscy5leHBhbmRFeHRlbnNpb24oZXh0ZW5zaW9uLCBqb2kpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGpvaVtpdGVtLnR5cGVdID09PSB1bmRlZmluZWQgfHwgam9pLl90eXBlcy5oYXMoaXRlbS50eXBlKSwgJ0Nhbm5vdCBvdmVycmlkZSBuYW1lJywgaXRlbS50eXBlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBpdGVtLmJhc2UgfHwgdGhpcy5hbnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBFeHRlbmQudHlwZShiYXNlLCBpdGVtKTtcblxuICAgICAgICAgICAgICAgIGpvaS5fdHlwZXMuYWRkKGl0ZW0udHlwZSk7XG4gICAgICAgICAgICAgICAgam9pW2l0ZW0udHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgc2NoZW1hLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpvaTtcbiAgICB9LFxuXG4gICAgaXNFcnJvcjogRXJyb3JzLlZhbGlkYXRpb25FcnJvci5pc0Vycm9yLFxuICAgIGlzRXhwcmVzc2lvbjogVGVtcGxhdGUuaXNUZW1wbGF0ZSxcbiAgICBpc1JlZjogUmVmLmlzUmVmLFxuICAgIGlzU2NoZW1hOiBDb21tb24uaXNTY2hlbWEsXG5cbiAgICBpbiguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIFJlZi5pbiguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgb3ZlcnJpZGU6IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLFxuXG4gICAgcmVmKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmNyZWF0ZSguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgdHlwZXMoKSB7XG5cbiAgICAgICAgY29uc3QgdHlwZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMuX3R5cGVzKSB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IHRoaXNbdHlwZV0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IGluIGludGVybmFscy5hbGlhc2VzKSB7XG4gICAgICAgICAgICB0eXBlc1t0YXJnZXRdID0gdGhpc1t0YXJnZXRdKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxufTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5hc3NlcnQgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgYW5ub3RhdGUsIGFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnID8gYXJnc1swXSA6IG51bGw7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1lc3NhZ2UgIT09IG51bGwgPyBhcmdzWzFdIDogYXJnc1swXTtcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEudmFsaWRhdGUodmFsdWUsIENvbW1vbi5wcmVmZXJlbmNlcyh7IGVycm9yczogeyBzdGFjazogdHJ1ZSB9IH0sIG9wdGlvbnMgfHwge30pKTtcblxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3BsYXkgPSBhbm5vdGF0ZSAmJiB0eXBlb2YgZXJyb3IuYW5ub3RhdGUgPT09ICdmdW5jdGlvbicgPyBlcnJvci5hbm5vdGF0ZSgpIDogZXJyb3IubWVzc2FnZTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9ycy5WYWxpZGF0aW9uRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIGVycm9yID0gQ2xvbmUoZXJyb3IpO1xuICAgIH1cblxuICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlID8gYCR7bWVzc2FnZX0gJHtkaXNwbGF5fWAgOiBkaXNwbGF5O1xuICAgIHRocm93IGVycm9yO1xufTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocm9vdCwgc2NoZW1hLCBhcmdzKSB7XG5cbiAgICBBc3NlcnQocm9vdCwgJ011c3QgYmUgaW52b2tlZCBvbiBhIEpvaSBpbnN0YW5jZS4nKTtcblxuICAgIHNjaGVtYS4kX3Jvb3QgPSByb290O1xuXG4gICAgaWYgKCFzY2hlbWEuX2RlZmluaXRpb24uYXJncyB8fFxuICAgICAgICAhYXJncy5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEuX2RlZmluaXRpb24uYXJncyhzY2hlbWEsIC4uLmFyZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMuZXhwYW5kRXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbiwgam9pKSB7XG5cbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbi50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW2V4dGVuc2lvbl07XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW5kZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygam9pLl90eXBlcykge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUudGVzdCh0eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV4dGVuc2lvbik7XG4gICAgICAgICAgICBpdGVtLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaXRlbS5iYXNlID0gam9pW3R5cGVdKCk7XG4gICAgICAgICAgICBleHRlbmRlZC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZGVkO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5yb290KCk7XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkNsb25lIiwiQ2FjaGUiLCJDb21tb24iLCJDb21waWxlIiwiRXJyb3JzIiwiRXh0ZW5kIiwiTWFuaWZlc3QiLCJSZWYiLCJUZW1wbGF0ZSIsIlRyYWNlIiwiU2NoZW1hcyIsImludGVybmFscyIsInR5cGVzIiwiYWx0ZXJuYXRpdmVzIiwiYW55IiwiYXJyYXkiLCJib29sZWFuIiwiZGF0ZSIsImZ1bmN0aW9uIiwibGluayIsIm51bWJlciIsIm9iamVjdCIsInN0cmluZyIsInN5bWJvbCIsImFsaWFzZXMiLCJhbHQiLCJib29sIiwiZnVuYyIsIkJ1ZmZlciIsImJpbmFyeSIsInJvb3QiLCJfdHlwZXMiLCJTZXQiLCJPYmplY3QiLCJrZXlzIiwidHlwZSIsImFyZ3MiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImdlbmVyYXRlIiwibWV0aG9kIiwiYXNzaWduIiwibWV0aG9kcyIsImFsaWFzIiwidGFyZ2V0IiwieCIsImV4cHJlc3Npb24iLCJzZXR1cCIsIlZhbGlkYXRpb25FcnJvciIsInZlcnNpb24iLCJjYWNoZSIsInByb3ZpZGVyIiwiYXNzZXJ0IiwidmFsdWUiLCJzY2hlbWEiLCJhdHRlbXB0IiwiYnVpbGQiLCJkZXNjIiwiY2hlY2tQcmVmZXJlbmNlcyIsInByZWZzIiwiY29tcGlsZSIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsIm1vZGlmaWVyIiwiam9pIiwiaXNTY2hlbWEiLCJleHRlbmQiLCJleHRlbnNpb25zIiwidmVyaWZ5RmxhdCIsImV4dGVuc2lvbiIsImV4cGFuZGVkIiwiZXhwYW5kRXh0ZW5zaW9uIiwiaXRlbSIsInVuZGVmaW5lZCIsImhhcyIsImJhc2UiLCJhZGQiLCJpc0Vycm9yIiwiaXNFeHByZXNzaW9uIiwiaXNUZW1wbGF0ZSIsImlzUmVmIiwiaW4iLCJvdmVycmlkZSIsInN5bWJvbHMiLCJyZWYiLCJjcmVhdGUiLCJhbm5vdGF0ZSIsIm1lc3NhZ2UiLCJFcnJvciIsInJlc3VsdCIsInZhbGlkYXRlIiwicHJlZmVyZW5jZXMiLCJlcnJvcnMiLCJzdGFjayIsImVycm9yIiwiZGlzcGxheSIsIiRfcm9vdCIsIl9kZWZpbml0aW9uIiwiZXh0ZW5kZWQiLCJ0ZXN0IiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/manifest.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/manifest.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\nlet Schemas;\nconst internals = {};\nexports.describe = function(schema) {\n    const def = schema._definition;\n    // Type\n    const desc = {\n        type: schema.type,\n        flags: {},\n        rules: []\n    };\n    // Flags\n    for(const flag in schema._flags){\n        if (flag[0] !== \"_\") {\n            desc.flags[flag] = internals.describe(schema._flags[flag]);\n        }\n    }\n    if (!Object.keys(desc.flags).length) {\n        delete desc.flags;\n    }\n    // Preferences\n    if (schema._preferences) {\n        desc.preferences = Clone(schema._preferences, {\n            shallow: [\n                \"messages\"\n            ]\n        });\n        delete desc.preferences[Common.symbols.prefs];\n        if (desc.preferences.messages) {\n            desc.preferences.messages = Messages.decompile(desc.preferences.messages);\n        }\n    }\n    // Allow / Invalid\n    if (schema._valids) {\n        desc.allow = schema._valids.describe();\n    }\n    if (schema._invalids) {\n        desc.invalid = schema._invalids.describe();\n    }\n    // Rules\n    for (const rule of schema._rules){\n        const ruleDef = def.rules[rule.name];\n        if (ruleDef.manifest === false) {\n            continue;\n        }\n        const item = {\n            name: rule.name\n        };\n        for(const custom in def.modifiers){\n            if (rule[custom] !== undefined) {\n                item[custom] = internals.describe(rule[custom]);\n            }\n        }\n        if (rule.args) {\n            item.args = {};\n            for(const key in rule.args){\n                const arg = rule.args[key];\n                if (key === \"options\" && !Object.keys(arg).length) {\n                    continue;\n                }\n                item.args[key] = internals.describe(arg, {\n                    assign: key\n                });\n            }\n            if (!Object.keys(item.args).length) {\n                delete item.args;\n            }\n        }\n        desc.rules.push(item);\n    }\n    if (!desc.rules.length) {\n        delete desc.rules;\n    }\n    // Terms (must be last to verify no name conflicts)\n    for(const term in schema.$_terms){\n        if (term[0] === \"_\") {\n            continue;\n        }\n        Assert(!desc[term], \"Cannot describe schema due to internal name conflict with\", term);\n        const items = schema.$_terms[term];\n        if (!items) {\n            continue;\n        }\n        if (items instanceof Map) {\n            if (items.size) {\n                desc[term] = [\n                    ...items.entries()\n                ];\n            }\n            continue;\n        }\n        if (Common.isValues(items)) {\n            desc[term] = items.describe();\n            continue;\n        }\n        Assert(def.terms[term], \"Term\", term, \"missing configuration\");\n        const manifest = def.terms[term].manifest;\n        const mapped = typeof manifest === \"object\";\n        if (!items.length && !mapped) {\n            continue;\n        }\n        const normalized = [];\n        for (const item of items){\n            normalized.push(internals.describe(item));\n        }\n        // Mapped\n        if (mapped) {\n            const { from, to } = manifest.mapped;\n            desc[term] = {};\n            for (const item of normalized){\n                desc[term][item[to]] = item[from];\n            }\n            continue;\n        }\n        // Single\n        if (manifest === \"single\") {\n            Assert(normalized.length === 1, \"Term\", term, \"contains more than one item\");\n            desc[term] = normalized[0];\n            continue;\n        }\n        // Array\n        desc[term] = normalized;\n    }\n    internals.validate(schema.$_root, desc);\n    return desc;\n};\ninternals.describe = function(item, options = {}) {\n    if (Array.isArray(item)) {\n        return item.map(internals.describe);\n    }\n    if (item === Common.symbols.deepDefault) {\n        return {\n            special: \"deep\"\n        };\n    }\n    if (typeof item !== \"object\" || item === null) {\n        return item;\n    }\n    if (options.assign === \"options\") {\n        return Clone(item);\n    }\n    if (Buffer && Buffer.isBuffer(item)) {\n        return {\n            buffer: item.toString(\"binary\")\n        };\n    }\n    if (item instanceof Date) {\n        return item.toISOString();\n    }\n    if (item instanceof Error) {\n        return item;\n    }\n    if (item instanceof RegExp) {\n        if (options.assign === \"regex\") {\n            return item.toString();\n        }\n        return {\n            regex: item.toString()\n        };\n    }\n    if (item[Common.symbols.literal]) {\n        return {\n            function: item.literal\n        };\n    }\n    if (typeof item.describe === \"function\") {\n        if (options.assign === \"ref\") {\n            return item.describe().ref;\n        }\n        return item.describe();\n    }\n    const normalized = {};\n    for(const key in item){\n        const value = item[key];\n        if (value === undefined) {\n            continue;\n        }\n        normalized[key] = internals.describe(value, {\n            assign: key\n        });\n    }\n    return normalized;\n};\nexports.build = function(joi, desc) {\n    const builder = new internals.Builder(joi);\n    return builder.parse(desc);\n};\ninternals.Builder = class {\n    constructor(joi){\n        this.joi = joi;\n    }\n    parse(desc) {\n        internals.validate(this.joi, desc);\n        // Type\n        let schema = this.joi[desc.type]()._bare();\n        const def = schema._definition;\n        // Flags\n        if (desc.flags) {\n            for(const flag in desc.flags){\n                const setter = def.flags[flag] && def.flags[flag].setter || flag;\n                Assert(typeof schema[setter] === \"function\", \"Invalid flag\", flag, \"for type\", desc.type);\n                schema = schema[setter](this.build(desc.flags[flag]));\n            }\n        }\n        // Preferences\n        if (desc.preferences) {\n            schema = schema.preferences(this.build(desc.preferences));\n        }\n        // Allow / Invalid\n        if (desc.allow) {\n            schema = schema.allow(...this.build(desc.allow));\n        }\n        if (desc.invalid) {\n            schema = schema.invalid(...this.build(desc.invalid));\n        }\n        // Rules\n        if (desc.rules) {\n            for (const rule of desc.rules){\n                Assert(typeof schema[rule.name] === \"function\", \"Invalid rule\", rule.name, \"for type\", desc.type);\n                const args = [];\n                if (rule.args) {\n                    const built = {};\n                    for(const key in rule.args){\n                        built[key] = this.build(rule.args[key], {\n                            assign: key\n                        });\n                    }\n                    const keys = Object.keys(built);\n                    const definition = def.rules[rule.name].args;\n                    if (definition) {\n                        Assert(keys.length <= definition.length, \"Invalid number of arguments for\", desc.type, rule.name, \"(expected up to\", definition.length, \", found\", keys.length, \")\");\n                        for (const { name } of definition){\n                            args.push(built[name]);\n                        }\n                    } else {\n                        Assert(keys.length === 1, \"Invalid number of arguments for\", desc.type, rule.name, \"(expected up to 1, found\", keys.length, \")\");\n                        args.push(built[keys[0]]);\n                    }\n                }\n                // Apply\n                schema = schema[rule.name](...args);\n                // Ruleset\n                const options = {};\n                for(const custom in def.modifiers){\n                    if (rule[custom] !== undefined) {\n                        options[custom] = this.build(rule[custom]);\n                    }\n                }\n                if (Object.keys(options).length) {\n                    schema = schema.rule(options);\n                }\n            }\n        }\n        // Terms\n        const terms = {};\n        for(const key in desc){\n            if ([\n                \"allow\",\n                \"flags\",\n                \"invalid\",\n                \"whens\",\n                \"preferences\",\n                \"rules\",\n                \"type\"\n            ].includes(key)) {\n                continue;\n            }\n            Assert(def.terms[key], \"Term\", key, \"missing configuration\");\n            const manifest = def.terms[key].manifest;\n            if (manifest === \"schema\") {\n                terms[key] = desc[key].map((item)=>this.parse(item));\n                continue;\n            }\n            if (manifest === \"values\") {\n                terms[key] = desc[key].map((item)=>this.build(item));\n                continue;\n            }\n            if (manifest === \"single\") {\n                terms[key] = this.build(desc[key]);\n                continue;\n            }\n            if (typeof manifest === \"object\") {\n                terms[key] = {};\n                for(const name in desc[key]){\n                    const value = desc[key][name];\n                    terms[key][name] = this.parse(value);\n                }\n                continue;\n            }\n            terms[key] = this.build(desc[key]);\n        }\n        if (desc.whens) {\n            terms.whens = desc.whens.map((when)=>this.build(when));\n        }\n        schema = def.manifest.build(schema, terms);\n        schema.$_temp.ruleset = false;\n        return schema;\n    }\n    build(desc, options = {}) {\n        if (desc === null) {\n            return null;\n        }\n        if (Array.isArray(desc)) {\n            return desc.map((item)=>this.build(item));\n        }\n        if (desc instanceof Error) {\n            return desc;\n        }\n        if (options.assign === \"options\") {\n            return Clone(desc);\n        }\n        if (options.assign === \"regex\") {\n            return internals.regex(desc);\n        }\n        if (options.assign === \"ref\") {\n            return Ref.build(desc);\n        }\n        if (typeof desc !== \"object\") {\n            return desc;\n        }\n        if (Object.keys(desc).length === 1) {\n            if (desc.buffer) {\n                Assert(Buffer, \"Buffers are not supported\");\n                return Buffer && Buffer.from(desc.buffer, \"binary\"); // $lab:coverage:ignore$\n            }\n            if (desc.function) {\n                return {\n                    [Common.symbols.literal]: true,\n                    literal: desc.function\n                };\n            }\n            if (desc.override) {\n                return Common.symbols.override;\n            }\n            if (desc.ref) {\n                return Ref.build(desc.ref);\n            }\n            if (desc.regex) {\n                return internals.regex(desc.regex);\n            }\n            if (desc.special) {\n                Assert([\n                    \"deep\"\n                ].includes(desc.special), \"Unknown special value\", desc.special);\n                return Common.symbols.deepDefault;\n            }\n            if (desc.value) {\n                return Clone(desc.value);\n            }\n        }\n        if (desc.type) {\n            return this.parse(desc);\n        }\n        if (desc.template) {\n            return Template.build(desc);\n        }\n        const normalized = {};\n        for(const key in desc){\n            normalized[key] = this.build(desc[key], {\n                assign: key\n            });\n        }\n        return normalized;\n    }\n};\ninternals.regex = function(string) {\n    const end = string.lastIndexOf(\"/\");\n    const exp = string.slice(1, end);\n    const flags = string.slice(end + 1);\n    return new RegExp(exp, flags);\n};\ninternals.validate = function(joi, desc) {\n    Schemas = Schemas || __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/joi/lib/schemas.js\");\n    joi.assert(desc, Schemas.description);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tYW5pZmVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBRXRCLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1JLE1BQU1KLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDO0FBRXpCLElBQUlNO0FBR0osTUFBTUMsWUFBWSxDQUFDO0FBR25CQyxnQkFBZ0IsR0FBRyxTQUFVRSxNQUFNO0lBRS9CLE1BQU1DLE1BQU1ELE9BQU9FLFdBQVc7SUFFOUIsT0FBTztJQUVQLE1BQU1DLE9BQU87UUFDVEMsTUFBTUosT0FBT0ksSUFBSTtRQUNqQkMsT0FBTyxDQUFDO1FBQ1JDLE9BQU8sRUFBRTtJQUNiO0lBRUEsUUFBUTtJQUVSLElBQUssTUFBTUMsUUFBUVAsT0FBT1EsTUFBTSxDQUFFO1FBQzlCLElBQUlELElBQUksQ0FBQyxFQUFFLEtBQUssS0FBSztZQUNqQkosS0FBS0UsS0FBSyxDQUFDRSxLQUFLLEdBQUdWLFVBQVVFLFFBQVEsQ0FBQ0MsT0FBT1EsTUFBTSxDQUFDRCxLQUFLO1FBQzdEO0lBQ0o7SUFFQSxJQUFJLENBQUNFLE9BQU9DLElBQUksQ0FBQ1AsS0FBS0UsS0FBSyxFQUFFTSxNQUFNLEVBQUU7UUFDakMsT0FBT1IsS0FBS0UsS0FBSztJQUNyQjtJQUVBLGNBQWM7SUFFZCxJQUFJTCxPQUFPWSxZQUFZLEVBQUU7UUFDckJULEtBQUtVLFdBQVcsR0FBR3RCLE1BQU1TLE9BQU9ZLFlBQVksRUFBRTtZQUFFRSxTQUFTO2dCQUFDO2FBQVc7UUFBQztRQUN0RSxPQUFPWCxLQUFLVSxXQUFXLENBQUNyQixPQUFPdUIsT0FBTyxDQUFDQyxLQUFLLENBQUM7UUFDN0MsSUFBSWIsS0FBS1UsV0FBVyxDQUFDSSxRQUFR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TztnQkFDN0UsT0FBT2hFLE9BQU91QixPQUFPLENBQUN3QyxXQUFXO1lBQ3JDO1lBRUEsSUFBSXBELEtBQUtrRSxLQUFLLEVBQUU7Z0JBQ1osT0FBTzlFLE1BQU1ZLEtBQUtrRSxLQUFLO1lBQzNCO1FBQ0o7UUFFQSxJQUFJbEUsS0FBS0MsSUFBSSxFQUFFO1lBQ1gsT0FBTyxJQUFJLENBQUNzRSxLQUFLLENBQUN2RTtRQUN0QjtRQUVBLElBQUlBLEtBQUttRixRQUFRLEVBQUU7WUFDZixPQUFPM0YsU0FBUzJFLEtBQUssQ0FBQ25FO1FBQzFCO1FBRUEsTUFBTTJDLGFBQWEsQ0FBQztRQUNwQixJQUFLLE1BQU1iLE9BQU85QixLQUFNO1lBQ3BCMkMsVUFBVSxDQUFDYixJQUFJLEdBQUcsSUFBSSxDQUFDcUMsS0FBSyxDQUFDbkUsSUFBSSxDQUFDOEIsSUFBSSxFQUFFO2dCQUFFRSxRQUFRRjtZQUFJO1FBQzFEO1FBRUEsT0FBT2E7SUFDWDtBQUNKO0FBR0FqRCxVQUFVb0UsS0FBSyxHQUFHLFNBQVVzQixNQUFNO0lBRTlCLE1BQU1DLE1BQU1ELE9BQU9FLFdBQVcsQ0FBQztJQUMvQixNQUFNQyxNQUFNSCxPQUFPSSxLQUFLLENBQUMsR0FBR0g7SUFDNUIsTUFBTW5GLFFBQVFrRixPQUFPSSxLQUFLLENBQUNILE1BQU07SUFDakMsT0FBTyxJQUFJeEIsT0FBTzBCLEtBQUtyRjtBQUMzQjtBQUdBUixVQUFVb0QsUUFBUSxHQUFHLFNBQVVzQixHQUFHLEVBQUVwRSxJQUFJO0lBRXBDUCxVQUFVQSxXQUFXTixtQkFBT0EsQ0FBQztJQUU3QmlGLElBQUlxQixNQUFNLENBQUN6RixNQUFNUCxRQUFRaUcsV0FBVztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbWFuaWZlc3QuanM/ZWNmMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX2RlZmluaXRpb247XG5cbiAgICAvLyBUeXBlXG5cbiAgICBjb25zdCBkZXNjID0ge1xuICAgICAgICB0eXBlOiBzY2hlbWEudHlwZSxcbiAgICAgICAgZmxhZ3M6IHt9LFxuICAgICAgICBydWxlczogW11cbiAgICB9O1xuXG4gICAgLy8gRmxhZ3NcblxuICAgIGZvciAoY29uc3QgZmxhZyBpbiBzY2hlbWEuX2ZsYWdzKSB7XG4gICAgICAgIGlmIChmbGFnWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIGRlc2MuZmxhZ3NbZmxhZ10gPSBpbnRlcm5hbHMuZGVzY3JpYmUoc2NoZW1hLl9mbGFnc1tmbGFnXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKGRlc2MuZmxhZ3MpLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgZGVzYy5mbGFncztcbiAgICB9XG5cbiAgICAvLyBQcmVmZXJlbmNlc1xuXG4gICAgaWYgKHNjaGVtYS5fcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgZGVzYy5wcmVmZXJlbmNlcyA9IENsb25lKHNjaGVtYS5fcHJlZmVyZW5jZXMsIHsgc2hhbGxvdzogWydtZXNzYWdlcyddIH0pO1xuICAgICAgICBkZWxldGUgZGVzYy5wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgICAgIGlmIChkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzID0gTWVzc2FnZXMuZGVjb21waWxlKGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgLyBJbnZhbGlkXG5cbiAgICBpZiAoc2NoZW1hLl92YWxpZHMpIHtcbiAgICAgICAgZGVzYy5hbGxvdyA9IHNjaGVtYS5fdmFsaWRzLmRlc2NyaWJlKCk7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5faW52YWxpZHMpIHtcbiAgICAgICAgZGVzYy5pbnZhbGlkID0gc2NoZW1hLl9pbnZhbGlkcy5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIC8vIFJ1bGVzXG5cbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygc2NoZW1hLl9ydWxlcykge1xuICAgICAgICBjb25zdCBydWxlRGVmID0gZGVmLnJ1bGVzW3J1bGUubmFtZV07XG4gICAgICAgIGlmIChydWxlRGVmLm1hbmlmZXN0ID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHsgbmFtZTogcnVsZS5uYW1lIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBjdXN0b20gaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgaWYgKHJ1bGVbY3VzdG9tXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbVtjdXN0b21dID0gaW50ZXJuYWxzLmRlc2NyaWJlKHJ1bGVbY3VzdG9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICBpdGVtLmFyZ3MgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IHJ1bGUuYXJnc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdvcHRpb25zJyAmJlxuICAgICAgICAgICAgICAgICAgICAhT2JqZWN0LmtleXMoYXJnKS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtLmFyZ3Nba2V5XSA9IGludGVybmFscy5kZXNjcmliZShhcmcsIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoaXRlbS5hcmdzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5hcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYy5ydWxlcy5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIGlmICghZGVzYy5ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGRlc2MucnVsZXM7XG4gICAgfVxuXG4gICAgLy8gVGVybXMgKG11c3QgYmUgbGFzdCB0byB2ZXJpZnkgbm8gbmFtZSBjb25mbGljdHMpXG5cbiAgICBmb3IgKGNvbnN0IHRlcm0gaW4gc2NoZW1hLiRfdGVybXMpIHtcbiAgICAgICAgaWYgKHRlcm1bMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQoIWRlc2NbdGVybV0sICdDYW5ub3QgZGVzY3JpYmUgc2NoZW1hIGR1ZSB0byBpbnRlcm5hbCBuYW1lIGNvbmZsaWN0IHdpdGgnLCB0ZXJtKTtcblxuICAgICAgICBjb25zdCBpdGVtcyA9IHNjaGVtYS4kX3Rlcm1zW3Rlcm1dO1xuICAgICAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgaWYgKGl0ZW1zLnNpemUpIHtcbiAgICAgICAgICAgICAgICBkZXNjW3Rlcm1dID0gWy4uLml0ZW1zLmVudHJpZXMoKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1ZhbHVlcyhpdGVtcykpIHtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSBpdGVtcy5kZXNjcmliZSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQoZGVmLnRlcm1zW3Rlcm1dLCAnVGVybScsIHRlcm0sICdtaXNzaW5nIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBkZWYudGVybXNbdGVybV0ubWFuaWZlc3Q7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHR5cGVvZiBtYW5pZmVzdCA9PT0gJ29iamVjdCc7XG4gICAgICAgIGlmICghaXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhbWFwcGVkKSB7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChpbnRlcm5hbHMuZGVzY3JpYmUoaXRlbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFwcGVkXG5cbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gbWFuaWZlc3QubWFwcGVkO1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBkZXNjW3Rlcm1dW2l0ZW1bdG9dXSA9IGl0ZW1bZnJvbV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlXG5cbiAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgQXNzZXJ0KG5vcm1hbGl6ZWQubGVuZ3RoID09PSAxLCAnVGVybScsIHRlcm0sICdjb250YWlucyBtb3JlIHRoYW4gb25lIGl0ZW0nKTtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSBub3JtYWxpemVkWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcnJheVxuXG4gICAgICAgIGRlc2NbdGVybV0gPSBub3JtYWxpemVkO1xuICAgIH1cblxuICAgIGludGVybmFscy52YWxpZGF0ZShzY2hlbWEuJF9yb290LCBkZXNjKTtcbiAgICByZXR1cm4gZGVzYztcbn07XG5cblxuaW50ZXJuYWxzLmRlc2NyaWJlID0gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubWFwKGludGVybmFscy5kZXNjcmliZSk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gPT09IENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiB7IHNwZWNpYWw6ICdkZWVwJyB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgaXRlbSA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIHJldHVybiBDbG9uZShpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgIHJldHVybiB7IGJ1ZmZlcjogaXRlbS50b1N0cmluZygnYmluYXJ5JykgfTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZ2V4Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlZ2V4OiBpdGVtLnRvU3RyaW5nKCkgfTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbVtDb21tb24uc3ltYm9scy5saXRlcmFsXSkge1xuICAgICAgICByZXR1cm4geyBmdW5jdGlvbjogaXRlbS5saXRlcmFsIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVtLmRlc2NyaWJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZicpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRlc2NyaWJlKCkucmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0uZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW1ba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZFtrZXldID0gaW50ZXJuYWxzLmRlc2NyaWJlKHZhbHVlLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKGpvaSwgZGVzYykge1xuXG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBpbnRlcm5hbHMuQnVpbGRlcihqb2kpO1xuICAgIHJldHVybiBidWlsZGVyLnBhcnNlKGRlc2MpO1xufTtcblxuXG5pbnRlcm5hbHMuQnVpbGRlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGpvaSkge1xuXG4gICAgICAgIHRoaXMuam9pID0gam9pO1xuICAgIH1cblxuICAgIHBhcnNlKGRlc2MpIHtcblxuICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGUodGhpcy5qb2ksIGRlc2MpO1xuXG4gICAgICAgIC8vIFR5cGVcblxuICAgICAgICBsZXQgc2NoZW1hID0gdGhpcy5qb2lbZGVzYy50eXBlXSgpLl9iYXJlKCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcblxuICAgICAgICAvLyBGbGFnc1xuXG4gICAgICAgIGlmIChkZXNjLmZsYWdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZsYWcgaW4gZGVzYy5mbGFncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRlciA9IGRlZi5mbGFnc1tmbGFnXSAmJiBkZWYuZmxhZ3NbZmxhZ10uc2V0dGVyIHx8IGZsYWc7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBzY2hlbWFbc2V0dGVyXSA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgZmxhZycsIGZsYWcsICdmb3IgdHlwZScsIGRlc2MudHlwZSk7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hW3NldHRlcl0odGhpcy5idWlsZChkZXNjLmZsYWdzW2ZsYWddKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVmZXJlbmNlc1xuXG4gICAgICAgIGlmIChkZXNjLnByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEucHJlZmVyZW5jZXModGhpcy5idWlsZChkZXNjLnByZWZlcmVuY2VzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyAvIEludmFsaWRcblxuICAgICAgICBpZiAoZGVzYy5hbGxvdykge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLmFsbG93KC4uLnRoaXMuYnVpbGQoZGVzYy5hbGxvdykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuaW52YWxpZCkge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLmludmFsaWQoLi4udGhpcy5idWlsZChkZXNjLmludmFsaWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1bGVzXG5cbiAgICAgICAgaWYgKGRlc2MucnVsZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBkZXNjLnJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBzY2hlbWFbcnVsZS5uYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgcnVsZScsIHJ1bGUubmFtZSwgJ2ZvciB0eXBlJywgZGVzYy50eXBlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1aWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbHRba2V5XSA9IHRoaXMuYnVpbGQocnVsZS5hcmdzW2tleV0sIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYnVpbHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGVmLnJ1bGVzW3J1bGUubmFtZV0uYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXlzLmxlbmd0aCA8PSBkZWZpbml0aW9uLmxlbmd0aCwgJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3InLCBkZXNjLnR5cGUsIHJ1bGUubmFtZSwgJyhleHBlY3RlZCB1cCB0bycsIGRlZmluaXRpb24ubGVuZ3RoLCAnLCBmb3VuZCcsIGtleXMubGVuZ3RoLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IG5hbWUgfSBvZiBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWx0W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXlzLmxlbmd0aCA9PT0gMSwgJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3InLCBkZXNjLnR5cGUsIHJ1bGUubmFtZSwgJyhleHBlY3RlZCB1cCB0byAxLCBmb3VuZCcsIGtleXMubGVuZ3RoLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWx0W2tleXNbMF1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWFbcnVsZS5uYW1lXSguLi5hcmdzKTtcblxuICAgICAgICAgICAgICAgIC8vIFJ1bGVzZXRcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlW2N1c3RvbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tjdXN0b21dID0gdGhpcy5idWlsZChydWxlW2N1c3RvbV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEucnVsZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXJtc1xuXG4gICAgICAgIGNvbnN0IHRlcm1zID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgIGlmIChbJ2FsbG93JywgJ2ZsYWdzJywgJ2ludmFsaWQnLCAnd2hlbnMnLCAncHJlZmVyZW5jZXMnLCAncnVsZXMnLCAndHlwZSddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KGRlZi50ZXJtc1trZXldLCAnVGVybScsIGtleSwgJ21pc3NpbmcgY29uZmlndXJhdGlvbicpO1xuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBkZWYudGVybXNba2V5XS5tYW5pZmVzdDtcblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2NoZW1hJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSBkZXNjW2tleV0ubWFwKChpdGVtKSA9PiB0aGlzLnBhcnNlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAndmFsdWVzJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSBkZXNjW2tleV0ubWFwKChpdGVtKSA9PiB0aGlzLmJ1aWxkKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFuaWZlc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZXNjW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZXNjW2tleV1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHRlcm1zW2tleV1bbmFtZV0gPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVybXNba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLndoZW5zKSB7XG4gICAgICAgICAgICB0ZXJtcy53aGVucyA9IGRlc2Mud2hlbnMubWFwKCh3aGVuKSA9PiB0aGlzLmJ1aWxkKHdoZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYSA9IGRlZi5tYW5pZmVzdC5idWlsZChzY2hlbWEsIHRlcm1zKTtcbiAgICAgICAgc2NoZW1hLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgYnVpbGQoZGVzYywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKGRlc2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVzYykpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjLm1hcCgoaXRlbSkgPT4gdGhpcy5idWlsZChpdGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWdleCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVnZXgoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWYnKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmLmJ1aWxkKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXNjICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVzYykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoZGVzYy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoQnVmZmVyLCAnQnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIgJiYgQnVmZmVyLmZyb20oZGVzYy5idWZmZXIsICdiaW5hcnknKTsgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5mdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IFtDb21tb24uc3ltYm9scy5saXRlcmFsXTogdHJ1ZSwgbGl0ZXJhbDogZGVzYy5mdW5jdGlvbiB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uc3ltYm9scy5vdmVycmlkZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZi5idWlsZChkZXNjLnJlZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5yZWdleChkZXNjLnJlZ2V4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2Muc3BlY2lhbCkge1xuICAgICAgICAgICAgICAgIEFzc2VydChbJ2RlZXAnXS5pbmNsdWRlcyhkZXNjLnNwZWNpYWwpLCAnVW5rbm93biBzcGVjaWFsIHZhbHVlJywgZGVzYy5zcGVjaWFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENsb25lKGRlc2MudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlLmJ1aWxkKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSwgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnJlZ2V4ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgY29uc3QgZW5kID0gc3RyaW5nLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgY29uc3QgZXhwID0gc3RyaW5nLnNsaWNlKDEsIGVuZCk7XG4gICAgY29uc3QgZmxhZ3MgPSBzdHJpbmcuc2xpY2UoZW5kICsgMSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZXhwLCBmbGFncyk7XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChqb2ksIGRlc2MpIHtcblxuICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgam9pLmFzc2VydChkZXNjLCBTY2hlbWFzLmRlc2NyaXB0aW9uKTtcbn07XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkNsb25lIiwiQ29tbW9uIiwiTWVzc2FnZXMiLCJSZWYiLCJUZW1wbGF0ZSIsIlNjaGVtYXMiLCJpbnRlcm5hbHMiLCJleHBvcnRzIiwiZGVzY3JpYmUiLCJzY2hlbWEiLCJkZWYiLCJfZGVmaW5pdGlvbiIsImRlc2MiLCJ0eXBlIiwiZmxhZ3MiLCJydWxlcyIsImZsYWciLCJfZmxhZ3MiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiX3ByZWZlcmVuY2VzIiwicHJlZmVyZW5jZXMiLCJzaGFsbG93Iiwic3ltYm9scyIsInByZWZzIiwibWVzc2FnZXMiLCJkZWNvbXBpbGUiLCJfdmFsaWRzIiwiYWxsb3ciLCJfaW52YWxpZHMiLCJpbnZhbGlkIiwicnVsZSIsIl9ydWxlcyIsInJ1bGVEZWYiLCJuYW1lIiwibWFuaWZlc3QiLCJpdGVtIiwiY3VzdG9tIiwibW9kaWZpZXJzIiwidW5kZWZpbmVkIiwiYXJncyIsImtleSIsImFyZyIsImFzc2lnbiIsInB1c2giLCJ0ZXJtIiwiJF90ZXJtcyIsIml0ZW1zIiwiTWFwIiwic2l6ZSIsImVudHJpZXMiLCJpc1ZhbHVlcyIsInRlcm1zIiwibWFwcGVkIiwibm9ybWFsaXplZCIsImZyb20iLCJ0byIsInZhbGlkYXRlIiwiJF9yb290Iiwib3B0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImRlZXBEZWZhdWx0Iiwic3BlY2lhbCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiYnVmZmVyIiwidG9TdHJpbmciLCJEYXRlIiwidG9JU09TdHJpbmciLCJFcnJvciIsIlJlZ0V4cCIsInJlZ2V4IiwibGl0ZXJhbCIsImZ1bmN0aW9uIiwicmVmIiwidmFsdWUiLCJidWlsZCIsImpvaSIsImJ1aWxkZXIiLCJCdWlsZGVyIiwicGFyc2UiLCJjb25zdHJ1Y3RvciIsIl9iYXJlIiwic2V0dGVyIiwiYnVpbHQiLCJkZWZpbml0aW9uIiwiaW5jbHVkZXMiLCJ3aGVucyIsIndoZW4iLCIkX3RlbXAiLCJydWxlc2V0Iiwib3ZlcnJpZGUiLCJ0ZW1wbGF0ZSIsInN0cmluZyIsImVuZCIsImxhc3RJbmRleE9mIiwiZXhwIiwic2xpY2UiLCJhc3NlcnQiLCJkZXNjcmlwdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/manifest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/messages.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/messages.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Template = __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\nconst internals = {};\nexports.compile = function(messages, target) {\n    // Single value string ('plain error message', 'template {error} message')\n    if (typeof messages === \"string\") {\n        Assert(!target, \"Cannot set single message string\");\n        return new Template(messages);\n    }\n    // Single value template\n    if (Template.isTemplate(messages)) {\n        Assert(!target, \"Cannot set single message template\");\n        return messages;\n    }\n    // By error code { 'number.min': <string | template> }\n    Assert(typeof messages === \"object\" && !Array.isArray(messages), \"Invalid message options\");\n    target = target ? Clone(target) : {};\n    for(let code in messages){\n        const message = messages[code];\n        if (code === \"root\" || Template.isTemplate(message)) {\n            target[code] = message;\n            continue;\n        }\n        if (typeof message === \"string\") {\n            target[code] = new Template(message);\n            continue;\n        }\n        // By language { english: { 'number.min': <string | template> } }\n        Assert(typeof message === \"object\" && !Array.isArray(message), \"Invalid message for\", code);\n        const language = code;\n        target[language] = target[language] || {};\n        for(code in message){\n            const localized = message[code];\n            if (code === \"root\" || Template.isTemplate(localized)) {\n                target[language][code] = localized;\n                continue;\n            }\n            Assert(typeof localized === \"string\", \"Invalid message for\", code, \"in\", language);\n            target[language][code] = new Template(localized);\n        }\n    }\n    return target;\n};\nexports.decompile = function(messages) {\n    // By error code { 'number.min': <string | template> }\n    const target = {};\n    for(let code in messages){\n        const message = messages[code];\n        if (code === \"root\") {\n            target.root = message;\n            continue;\n        }\n        if (Template.isTemplate(message)) {\n            target[code] = message.describe({\n                compact: true\n            });\n            continue;\n        }\n        // By language { english: { 'number.min': <string | template> } }\n        const language = code;\n        target[language] = {};\n        for(code in message){\n            const localized = message[code];\n            if (code === \"root\") {\n                target[language].root = localized;\n                continue;\n            }\n            target[language][code] = localized.describe({\n                compact: true\n            });\n        }\n    }\n    return target;\n};\nexports.merge = function(base, extended) {\n    if (!base) {\n        return exports.compile(extended);\n    }\n    if (!extended) {\n        return base;\n    }\n    // Single value string\n    if (typeof extended === \"string\") {\n        return new Template(extended);\n    }\n    // Single value template\n    if (Template.isTemplate(extended)) {\n        return extended;\n    }\n    // By error code { 'number.min': <string | template> }\n    const target = Clone(base);\n    for(let code in extended){\n        const message = extended[code];\n        if (code === \"root\" || Template.isTemplate(message)) {\n            target[code] = message;\n            continue;\n        }\n        if (typeof message === \"string\") {\n            target[code] = new Template(message);\n            continue;\n        }\n        // By language { english: { 'number.min': <string | template> } }\n        Assert(typeof message === \"object\" && !Array.isArray(message), \"Invalid message for\", code);\n        const language = code;\n        target[language] = target[language] || {};\n        for(code in message){\n            const localized = message[code];\n            if (code === \"root\" || Template.isTemplate(localized)) {\n                target[language][code] = localized;\n                continue;\n            }\n            Assert(typeof localized === \"string\", \"Invalid message for\", code, \"in\", language);\n            target[language][code] = new Template(localized);\n        }\n    }\n    return target;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tZXNzYWdlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBRXRCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDO0FBR3pCLE1BQU1HLFlBQVksQ0FBQztBQUduQkMsZUFBZSxHQUFHLFNBQVVFLFFBQVEsRUFBRUMsTUFBTTtJQUV4QywwRUFBMEU7SUFFMUUsSUFBSSxPQUFPRCxhQUFhLFVBQVU7UUFDOUJQLE9BQU8sQ0FBQ1EsUUFBUTtRQUNoQixPQUFPLElBQUlMLFNBQVNJO0lBQ3hCO0lBRUEsd0JBQXdCO0lBRXhCLElBQUlKLFNBQVNNLFVBQVUsQ0FBQ0YsV0FBVztRQUMvQlAsT0FBTyxDQUFDUSxRQUFRO1FBQ2hCLE9BQU9EO0lBQ1g7SUFFQSxzREFBc0Q7SUFFdERQLE9BQU8sT0FBT08sYUFBYSxZQUFZLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ0osV0FBVztJQUVqRUMsU0FBU0EsU0FBU04sTUFBTU0sVUFBVSxDQUFDO0lBRW5DLElBQUssSUFBSUksUUFBUUwsU0FBVTtRQUN2QixNQUFNTSxVQUFVTixRQUFRLENBQUNLLEtBQUs7UUFFOUIsSUFBSUEsU0FBUyxVQUNUVCxTQUFTTSxVQUFVLENBQUNJLFVBQVU7WUFFOUJMLE1BQU0sQ0FBQ0ksS0FBSyxHQUFHQztZQUNmO1FBQ0o7UUFFQSxJQUFJLE9BQU9BLFlBQVksVUFBVTtZQUM3QkwsTUFBTSxDQUFDSSxLQUFLLEdBQUcsSUFBSVQsU0FBU1U7WUFDNUI7UUFDSjtRQUVBLGlFQUFpRTtRQUVqRWIsT0FBTyxPQUFPYSxZQUFZLFlBQVksQ0FBQ0gsTUFBTUMsT0FBTyxDQUFDRSxVQUFVLHVCQUF1QkQ7UUFFdEYsTUFBTUUsV0FBV0Y7UUFDakJKLE1BQU0sQ0FBQ00sU0FBUyxHQUFHTixNQUFNLENBQUNNLFNBQVMsSUFBSSxDQUFDO1FBRXhDLElBQUtGLFFBQVFD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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL21lc3NhZ2VzLmpzPzU3NDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCB0YXJnZXQpIHtcblxuICAgIC8vIFNpbmdsZSB2YWx1ZSBzdHJpbmcgKCdwbGFpbiBlcnJvciBtZXNzYWdlJywgJ3RlbXBsYXRlIHtlcnJvcn0gbWVzc2FnZScpXG5cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2VzID09PSAnc3RyaW5nJykge1xuICAgICAgICBBc3NlcnQoIXRhcmdldCwgJ0Nhbm5vdCBzZXQgc2luZ2xlIG1lc3NhZ2Ugc3RyaW5nJyk7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUobWVzc2FnZXMpO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSB0ZW1wbGF0ZVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZXMpKSB7XG4gICAgICAgIEFzc2VydCghdGFyZ2V0LCAnQ2Fubm90IHNldCBzaW5nbGUgbWVzc2FnZSB0ZW1wbGF0ZScpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBBc3NlcnQodHlwZW9mIG1lc3NhZ2VzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShtZXNzYWdlcyksICdJbnZhbGlkIG1lc3NhZ2Ugb3B0aW9ucycpO1xuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0ID8gQ2xvbmUodGFyZ2V0KSA6IHt9O1xuXG4gICAgZm9yIChsZXQgY29kZSBpbiBtZXNzYWdlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbY29kZV07XG5cbiAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBuZXcgVGVtcGxhdGUobWVzc2FnZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShtZXNzYWdlKSwgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlKTtcblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB0YXJnZXRbbGFuZ3VhZ2VdIHx8IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShsb2NhbGl6ZWQpKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGxvY2FsaXplZCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSwgJ2luJywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IG5ldyBUZW1wbGF0ZShsb2NhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuZXhwb3J0cy5kZWNvbXBpbGUgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcblxuICAgIC8vIEJ5IGVycm9yIGNvZGUgeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgZm9yIChsZXQgY29kZSBpbiBtZXNzYWdlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbY29kZV07XG5cbiAgICAgICAgaWYgKGNvZGUgPT09ICdyb290Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnJvb3QgPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZS5kZXNjcmliZSh7IGNvbXBhY3Q6IHRydWUgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0ge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdLnJvb3QgPSBsb2NhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBsb2NhbGl6ZWQuZGVzY3JpYmUoeyBjb21wYWN0OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIChiYXNlLCBleHRlbmRlZCkge1xuXG4gICAgaWYgKCFiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbXBpbGUoZXh0ZW5kZWQpO1xuICAgIH1cblxuICAgIGlmICghZXh0ZW5kZWQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHN0cmluZ1xuXG4gICAgaWYgKHR5cGVvZiBleHRlbmRlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShleHRlbmRlZCk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHRlbXBsYXRlXG5cbiAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShleHRlbmRlZCkpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZGVkO1xuICAgIH1cblxuICAgIC8vIEJ5IGVycm9yIGNvZGUgeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQ2xvbmUoYmFzZSk7XG5cbiAgICBmb3IgKGxldCBjb2RlIGluIGV4dGVuZGVkKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBleHRlbmRlZFtjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG5cbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG5ldyBUZW1wbGF0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2UpLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUpO1xuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHRhcmdldFtsYW5ndWFnZV0gfHwge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKGxvY2FsaXplZCkpIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBsb2NhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbG9jYWxpemVkID09PSAnc3RyaW5nJywgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlLCAnaW4nLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbmV3IFRlbXBsYXRlKGxvY2FsaXplZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcbiJdLCJuYW1lcyI6WyJBc3NlcnQiLCJyZXF1aXJlIiwiQ2xvbmUiLCJUZW1wbGF0ZSIsImludGVybmFscyIsImV4cG9ydHMiLCJjb21waWxlIiwibWVzc2FnZXMiLCJ0YXJnZXQiLCJpc1RlbXBsYXRlIiwiQXJyYXkiLCJpc0FycmF5IiwiY29kZSIsIm1lc3NhZ2UiLCJsYW5ndWFnZSIsImxvY2FsaXplZCIsImRlY29tcGlsZSIsInJvb3QiLCJkZXNjcmliZSIsImNvbXBhY3QiLCJtZXJnZSIsImJhc2UiLCJleHRlbmRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/modify.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/modify.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst internals = {};\nexports.Ids = internals.Ids = class {\n    constructor(){\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n    clone() {\n        const clone = new internals.Ids();\n        clone._byId = new Map(this._byId);\n        clone._byKey = new Map(this._byKey);\n        clone._schemaChain = this._schemaChain;\n        return clone;\n    }\n    concat(source) {\n        if (source._schemaChain) {\n            this._schemaChain = true;\n        }\n        for (const [id, value] of source._byId.entries()){\n            Assert(!this._byKey.has(id), \"Schema id conflicts with existing key:\", id);\n            this._byId.set(id, value);\n        }\n        for (const [key, value] of source._byKey.entries()){\n            Assert(!this._byId.has(key), \"Schema key conflicts with existing id:\", key);\n            this._byKey.set(key, value);\n        }\n    }\n    fork(path, adjuster, root) {\n        const chain = this._collect(path);\n        chain.push({\n            schema: root\n        });\n        const tail = chain.shift();\n        let adjusted = {\n            id: tail.id,\n            schema: adjuster(tail.schema)\n        };\n        Assert(Common.isSchema(adjusted.schema), \"adjuster function failed to return a joi schema type\");\n        for (const node of chain){\n            adjusted = {\n                id: node.id,\n                schema: internals.fork(node.schema, adjusted.id, adjusted.schema)\n            };\n        }\n        return adjusted.schema;\n    }\n    labels(path, behind = []) {\n        const current = path[0];\n        const node = this._get(current);\n        if (!node) {\n            return [\n                ...behind,\n                ...path\n            ].join(\".\");\n        }\n        const forward = path.slice(1);\n        behind = [\n            ...behind,\n            node.schema._flags.label || current\n        ];\n        if (!forward.length) {\n            return behind.join(\".\");\n        }\n        return node.schema._ids.labels(forward, behind);\n    }\n    reach(path, behind = []) {\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, \"Schema does not contain path\", [\n            ...behind,\n            ...path\n        ].join(\".\"));\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return node.schema;\n        }\n        return node.schema._ids.reach(forward, [\n            ...behind,\n            current\n        ]);\n    }\n    register(schema, { key } = {}) {\n        if (!schema || !Common.isSchema(schema)) {\n            return;\n        }\n        if (schema.$_property(\"schemaChain\") || schema._ids._schemaChain) {\n            this._schemaChain = true;\n        }\n        const id = schema._flags.id;\n        if (id) {\n            const existing = this._byId.get(id);\n            Assert(!existing || existing.schema === schema, \"Cannot add different schemas with the same id:\", id);\n            Assert(!this._byKey.has(id), \"Schema id conflicts with existing key:\", id);\n            this._byId.set(id, {\n                schema,\n                id\n            });\n        }\n        if (key) {\n            Assert(!this._byKey.has(key), \"Schema already contains key:\", key);\n            Assert(!this._byId.has(key), \"Schema key conflicts with existing id:\", key);\n            this._byKey.set(key, {\n                schema,\n                id: key\n            });\n        }\n    }\n    reset() {\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n    _collect(path, behind = [], nodes = []) {\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, \"Schema does not contain path\", [\n            ...behind,\n            ...path\n        ].join(\".\"));\n        nodes = [\n            node,\n            ...nodes\n        ];\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return nodes;\n        }\n        return node.schema._ids._collect(forward, [\n            ...behind,\n            current\n        ], nodes);\n    }\n    _get(id) {\n        return this._byId.get(id) || this._byKey.get(id);\n    }\n};\ninternals.fork = function(schema, id, replacement) {\n    const each = (item, { key })=>{\n        if (id === (item._flags.id || key)) {\n            return replacement;\n        }\n    };\n    const obj = exports.schema(schema, {\n        each,\n        ref: false\n    });\n    return obj ? obj.$_mutateRebuild() : schema;\n};\nexports.schema = function(schema, options) {\n    let obj;\n    for(const name in schema._flags){\n        if (name[0] === \"_\") {\n            continue;\n        }\n        const result = internals.scan(schema._flags[name], {\n            source: \"flags\",\n            name\n        }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj._flags[name] = result;\n        }\n    }\n    for(let i = 0; i < schema._rules.length; ++i){\n        const rule = schema._rules[i];\n        const result = internals.scan(rule.args, {\n            source: \"rules\",\n            name: rule.name\n        }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            const clone = Object.assign({}, rule);\n            clone.args = result;\n            obj._rules[i] = clone;\n            const existingUnique = obj._singleRules.get(rule.name);\n            if (existingUnique === rule) {\n                obj._singleRules.set(rule.name, clone);\n            }\n        }\n    }\n    for(const name in schema.$_terms){\n        if (name[0] === \"_\") {\n            continue;\n        }\n        const result = internals.scan(schema.$_terms[name], {\n            source: \"terms\",\n            name\n        }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj.$_terms[name] = result;\n        }\n    }\n    return obj;\n};\ninternals.scan = function(item, source, options, _path, _key) {\n    const path = _path || [];\n    if (item === null || typeof item !== \"object\") {\n        return;\n    }\n    let clone;\n    if (Array.isArray(item)) {\n        for(let i = 0; i < item.length; ++i){\n            const key = source.source === \"terms\" && source.name === \"keys\" && item[i].key;\n            const result = internals.scan(item[i], source, options, [\n                i,\n                ...path\n            ], key);\n            if (result !== undefined) {\n                clone = clone || item.slice();\n                clone[i] = result;\n            }\n        }\n        return clone;\n    }\n    if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {\n        const result = options.each(item, {\n            ...source,\n            path,\n            key: _key\n        });\n        if (result === item) {\n            return;\n        }\n        return result;\n    }\n    for(const key in item){\n        if (key[0] === \"_\") {\n            continue;\n        }\n        const result = internals.scan(item[key], source, options, [\n            key,\n            ...path\n        ], _key);\n        if (result !== undefined) {\n            clone = clone || Object.assign({}, item);\n            clone[key] = result;\n        }\n    }\n    return clone;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9tb2RpZnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUV2QixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQztBQUdwQixNQUFNRyxZQUFZLENBQUM7QUFJbkJDLFdBQVcsR0FBR0QsVUFBVUUsR0FBRyxHQUFHO0lBRTFCQyxhQUFjO1FBRVYsSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSUM7UUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUQ7UUFDbEIsSUFBSSxDQUFDRSxZQUFZLEdBQUc7SUFDeEI7SUFFQUMsUUFBUTtRQUVKLE1BQU1BLFFBQVEsSUFBSVIsVUFBVUUsR0FBRztRQUMvQk0sTUFBTUosS0FBSyxHQUFHLElBQUlDLElBQUksSUFBSSxDQUFDRCxLQUFLO1FBQ2hDSSxNQUFNRixNQUFNLEdBQUcsSUFBSUQsSUFBSSxJQUFJLENBQUNDLE1BQU07UUFDbENFLE1BQU1ELFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7UUFDdEMsT0FBT0M7SUFDWDtJQUVBQyxPQUFPQyxNQUFNLEVBQUU7UUFFWCxJQUFJQSxPQUFPSCxZQUFZLEVBQUU7WUFDckIsSUFBSSxDQUFDQSxZQUFZLEdBQUc7UUFDeEI7UUFFQSxLQUFLLE1BQU0sQ0FBQ0ksSUFBSUMsTUFBTSxJQUFJRixPQUFPTixLQUFLLENBQUNTLE9BQU8sR0FBSTtZQUM5Q2pCLE9BQU8sQ0FBQyxJQUFJLENBQUNVLE1BQU0sQ0FBQ1EsR0FBRyxDQUFDSCxLQUFLLDBDQUEwQ0E7WUFDdkUsSUFBSSxDQUFDUCxLQUFLLENBQUNXLEdBQUcsQ0FBQ0osSUFBSUM7UUFDdkI7UUFFQSxLQUFLLE1BQU0sQ0FBQ0ksS0FBS0osTUFBTSxJQUFJRixPQUFPSixNQUFNLENBQUNPLE9BQU8sR0FBSTtZQUNoRGpCLE9BQU8sQ0FBQyxJQUFJLENBQUNRLEtBQUssQ0FBQ1Us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QyxHQUFHO1lBQzlFLE1BQU13QyxTQUFTeEQsVUFBVXlELElBQUksQ0FBQ1AsSUFBSSxDQUFDUyxFQUFFLEVBQUVqRCxRQUFRNEMsU0FBUztnQkFBQ0s7bUJBQU16QzthQUFLLEVBQUVGO1lBQ3RFLElBQUl3QyxXQUFXRSxXQUFXO2dCQUN0QmxELFFBQVFBLFNBQVMwQyxLQUFLZCxLQUFLO2dCQUMzQjVCLEtBQUssQ0FBQ21ELEVBQUUsR0FBR0g7WUFDZjtRQUNKO1FBRUEsT0FBT2hEO0lBQ1g7SUFFQSxJQUFJOEMsUUFBUTlCLE1BQU0sS0FBSyxTQUFTMUIsT0FBTzhCLFFBQVEsQ0FBQ3NCLFNBQzVDSSxRQUFRRixHQUFHLEtBQUssU0FBU3JELElBQUl5RSxLQUFLLENBQUN0QixPQUFPO1FBRTFDLE1BQU1NLFNBQVNGLFFBQVFMLElBQUksQ0FBQ0MsTUFBTTtZQUFFLEdBQUd4QyxNQUFNO1lBQUVRO1lBQU1GLEtBQUtxRDtRQUFLO1FBQy9ELElBQUliLFdBQVdOLE1BQU07WUFDakI7UUFDSjtRQUVBLE9BQU9NO0lBQ1g7SUFFQSxJQUFLLE1BQU14QyxPQUFPa0MsS0FBTTtRQUNwQixJQUFJbEMsR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLO1lBQ2hCO1FBQ0o7UUFFQSxNQUFNd0MsU0FBU3hELFVBQVV5RCxJQUFJLENBQUNQLElBQUksQ0FBQ2xDLElBQUksRUFBRU4sUUFBUTRDLFNBQVM7WUFBQ3RDO2VBQVFFO1NBQUssRUFBRW1EO1FBQzFFLElBQUliLFdBQVdFLFdBQVc7WUFDdEJsRCxRQUFRQSxTQUFTdUQsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2Q7WUFDbkMxQyxLQUFLLENBQUNRLElBQUksR0FBR3dDO1FBQ2pCO0lBQ0o7SUFFQSxPQUFPaEQ7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvbW9kaWZ5LmpzP2NjOTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuXG5leHBvcnRzLklkcyA9IGludGVybmFscy5JZHMgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLl9ieUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ieUtleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBpbnRlcm5hbHMuSWRzKCk7XG4gICAgICAgIGNsb25lLl9ieUlkID0gbmV3IE1hcCh0aGlzLl9ieUlkKTtcbiAgICAgICAgY2xvbmUuX2J5S2V5ID0gbmV3IE1hcCh0aGlzLl9ieUtleSk7XG4gICAgICAgIGNsb25lLl9zY2hlbWFDaGFpbiA9IHRoaXMuX3NjaGVtYUNoYWluO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIGlmIChzb3VyY2UuX3NjaGVtYUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtpZCwgdmFsdWVdIG9mIHNvdXJjZS5fYnlJZC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGlkKSwgJ1NjaGVtYSBpZCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBrZXk6JywgaWQpO1xuICAgICAgICAgICAgdGhpcy5fYnlJZC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNvdXJjZS5fYnlLZXkuZW50cmllcygpKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5SWQuaGFzKGtleSksICdTY2hlbWEga2V5IGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGlkOicsIGtleSk7XG4gICAgICAgICAgICB0aGlzLl9ieUtleS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3JrKHBhdGgsIGFkanVzdGVyLCByb290KSB7XG5cbiAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLl9jb2xsZWN0KHBhdGgpO1xuICAgICAgICBjaGFpbi5wdXNoKHsgc2NoZW1hOiByb290IH0pO1xuICAgICAgICBjb25zdCB0YWlsID0gY2hhaW4uc2hpZnQoKTtcbiAgICAgICAgbGV0IGFkanVzdGVkID0geyBpZDogdGFpbC5pZCwgc2NoZW1hOiBhZGp1c3Rlcih0YWlsLnNjaGVtYSkgfTtcblxuICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKGFkanVzdGVkLnNjaGVtYSksICdhZGp1c3RlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmV0dXJuIGEgam9pIHNjaGVtYSB0eXBlJyk7XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGNoYWluKSB7XG4gICAgICAgICAgICBhZGp1c3RlZCA9IHsgaWQ6IG5vZGUuaWQsIHNjaGVtYTogaW50ZXJuYWxzLmZvcmsobm9kZS5zY2hlbWEsIGFkanVzdGVkLmlkLCBhZGp1c3RlZC5zY2hlbWEpIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRqdXN0ZWQuc2NoZW1hO1xuICAgIH1cblxuICAgIGxhYmVscyhwYXRoLCBiZWhpbmQgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgYmVoaW5kID0gWy4uLmJlaGluZCwgbm9kZS5zY2hlbWEuX2ZsYWdzLmxhYmVsIHx8IGN1cnJlbnRdO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVoaW5kLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLmxhYmVscyhmb3J3YXJkLCBiZWhpbmQpO1xuICAgIH1cblxuICAgIHJlYWNoKHBhdGgsIGJlaGluZCA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIEFzc2VydChub2RlLCAnU2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gcGF0aCcsIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKSk7XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnNjaGVtYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLnJlYWNoKGZvcndhcmQsIFsuLi5iZWhpbmQsIGN1cnJlbnRdKTtcbiAgICB9XG5cbiAgICByZWdpc3RlcihzY2hlbWEsIHsga2V5IH0gPSB7fSkge1xuXG4gICAgICAgIGlmICghc2NoZW1hIHx8XG4gICAgICAgICAgICAhQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Byb3BlcnR5KCdzY2hlbWFDaGFpbicpIHx8XG4gICAgICAgICAgICBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4pIHtcblxuICAgICAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWQgPSBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fYnlJZC5nZXQoaWQpO1xuICAgICAgICAgICAgQXNzZXJ0KCFleGlzdGluZyB8fCBleGlzdGluZy5zY2hlbWEgPT09IHNjaGVtYSwgJ0Nhbm5vdCBhZGQgZGlmZmVyZW50IHNjaGVtYXMgd2l0aCB0aGUgc2FtZSBpZDonLCBpZCk7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhpZCksICdTY2hlbWEgaWQgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcga2V5OicsIGlkKTtcblxuICAgICAgICAgICAgdGhpcy5fYnlJZC5zZXQoaWQsIHsgc2NoZW1hLCBpZCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGtleSksICdTY2hlbWEgYWxyZWFkeSBjb250YWlucyBrZXk6Jywga2V5KTtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlJZC5oYXMoa2V5KSwgJ1NjaGVtYSBrZXkgY29uZmxpY3RzIHdpdGggZXhpc3RpbmcgaWQ6Jywga2V5KTtcblxuICAgICAgICAgICAgdGhpcy5fYnlLZXkuc2V0KGtleSwgeyBzY2hlbWEsIGlkOiBrZXkgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcblxuICAgICAgICB0aGlzLl9ieUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ieUtleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfY29sbGVjdChwYXRoLCBiZWhpbmQgPSBbXSwgbm9kZXMgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBBc3NlcnQobm9kZSwgJ1NjaGVtYSBkb2VzIG5vdCBjb250YWluIHBhdGgnLCBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJykpO1xuXG4gICAgICAgIG5vZGVzID0gW25vZGUsIC4uLm5vZGVzXTtcblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMuX2NvbGxlY3QoZm9yd2FyZCwgWy4uLmJlaGluZCwgY3VycmVudF0sIG5vZGVzKTtcbiAgICB9XG5cbiAgICBfZ2V0KGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5SWQuZ2V0KGlkKSB8fCB0aGlzLl9ieUtleS5nZXQoaWQpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZvcmsgPSBmdW5jdGlvbiAoc2NoZW1hLCBpZCwgcmVwbGFjZW1lbnQpIHtcblxuICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgeyBrZXkgfSkgPT4ge1xuXG4gICAgICAgIGlmIChpZCA9PT0gKGl0ZW0uX2ZsYWdzLmlkIHx8IGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvYmogPSBleHBvcnRzLnNjaGVtYShzY2hlbWEsIHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gb2JqID8gb2JqLiRfbXV0YXRlUmVidWlsZCgpIDogc2NoZW1hO1xufTtcblxuXG5leHBvcnRzLnNjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgIGxldCBvYmo7XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLl9mbGFncykge1xuICAgICAgICBpZiAobmFtZVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHNjaGVtYS5fZmxhZ3NbbmFtZV0sIHsgc291cmNlOiAnZmxhZ3MnLCBuYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIG9iai5fZmxhZ3NbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS5fcnVsZXNbaV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHJ1bGUuYXJncywgeyBzb3VyY2U6ICdydWxlcycsIG5hbWU6IHJ1bGUubmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIHJ1bGUpO1xuICAgICAgICAgICAgY2xvbmUuYXJncyA9IHJlc3VsdDtcbiAgICAgICAgICAgIG9iai5fcnVsZXNbaV0gPSBjbG9uZTtcblxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdVbmlxdWUgPSBvYmouX3NpbmdsZVJ1bGVzLmdldChydWxlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVW5pcXVlID09PSBydWxlKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQocnVsZS5uYW1lLCBjbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLiRfdGVybXMpIHtcbiAgICAgICAgaWYgKG5hbWVbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihzY2hlbWEuJF90ZXJtc1tuYW1lXSwgeyBzb3VyY2U6ICd0ZXJtcycsIG5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgb2JqLiRfdGVybXNbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMuc2NhbiA9IGZ1bmN0aW9uIChpdGVtLCBzb3VyY2UsIG9wdGlvbnMsIF9wYXRoLCBfa2V5KSB7XG5cbiAgICBjb25zdCBwYXRoID0gX3BhdGggfHwgW107XG5cbiAgICBpZiAoaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNsb25lO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBzb3VyY2Uuc291cmNlID09PSAndGVybXMnICYmIHNvdXJjZS5uYW1lID09PSAna2V5cycgJiYgaXRlbVtpXS5rZXk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihpdGVtW2ldLCBzb3VyY2UsIG9wdGlvbnMsIFtpLCAuLi5wYXRoXSwga2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNsb25lID0gY2xvbmUgfHwgaXRlbS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNsb25lW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNjaGVtYSAhPT0gZmFsc2UgJiYgQ29tbW9uLmlzU2NoZW1hKGl0ZW0pIHx8XG4gICAgICAgIG9wdGlvbnMucmVmICE9PSBmYWxzZSAmJiBSZWYuaXNSZWYoaXRlbSkpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb25zLmVhY2goaXRlbSwgeyAuLi5zb3VyY2UsIHBhdGgsIGtleTogX2tleSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihpdGVtW2tleV0sIHNvdXJjZSwgb3B0aW9ucywgW2tleSwgLi4ucGF0aF0sIF9rZXkpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsb25lID0gY2xvbmUgfHwgT2JqZWN0LmFzc2lnbih7fSwgaXRlbSk7XG4gICAgICAgICAgICBjbG9uZVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xufTtcbiJdLCJuYW1lcyI6WyJBc3NlcnQiLCJyZXF1aXJlIiwiQ29tbW9uIiwiUmVmIiwiaW50ZXJuYWxzIiwiZXhwb3J0cyIsIklkcyIsImNvbnN0cnVjdG9yIiwiX2J5SWQiLCJNYXAiLCJfYnlLZXkiLCJfc2NoZW1hQ2hhaW4iLCJjbG9uZSIsImNvbmNhdCIsInNvdXJjZSIsImlkIiwidmFsdWUiLCJlbnRyaWVzIiwiaGFzIiwic2V0Iiwia2V5IiwiZm9yayIsInBhdGgiLCJhZGp1c3RlciIsInJvb3QiLCJjaGFpbiIsIl9jb2xsZWN0IiwicHVzaCIsInNjaGVtYSIsInRhaWwiLCJzaGlmdCIsImFkanVzdGVkIiwiaXNTY2hlbWEiLCJub2RlIiwibGFiZWxzIiwiYmVoaW5kIiwiY3VycmVudCIsIl9nZXQiLCJqb2luIiwiZm9yd2FyZCIsInNsaWNlIiwiX2ZsYWdzIiwibGFiZWwiLCJsZW5ndGgiLCJfaWRzIiwicmVhY2giLCJyZWdpc3RlciIsIiRfcHJvcGVydHkiLCJleGlzdGluZyIsImdldCIsInJlc2V0Iiwibm9kZXMiLCJyZXBsYWNlbWVudCIsImVhY2giLCJpdGVtIiwib2JqIiwicmVmIiwiJF9tdXRhdGVSZWJ1aWxkIiwib3B0aW9ucyIsIm5hbWUiLCJyZXN1bHQiLCJzY2FuIiwidW5kZWZpbmVkIiwiaSIsIl9ydWxlcyIsInJ1bGUiLCJhcmdzIiwiT2JqZWN0IiwiYXNzaWduIiwiZXhpc3RpbmdVbmlxdWUiLCJfc2luZ2xlUnVsZXMiLCIkX3Rlcm1zIiwiX3BhdGgiLCJfa2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiaXNSZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/modify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/ref.js":
/*!*************************************!*\
  !*** ./node_modules/joi/lib/ref.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"(rsc)/./node_modules/@hapi/hoek/lib/reach.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nlet Template;\nconst internals = {\n    symbol: Symbol(\"ref\"),\n    defaults: {\n        adjust: null,\n        in: false,\n        iterables: null,\n        map: null,\n        separator: \".\",\n        type: \"value\"\n    }\n};\nexports.create = function(key, options = {}) {\n    Assert(typeof key === \"string\", \"Invalid reference key:\", key);\n    Common.assertOptions(options, [\n        \"adjust\",\n        \"ancestor\",\n        \"in\",\n        \"iterables\",\n        \"map\",\n        \"prefix\",\n        \"render\",\n        \"separator\"\n    ]);\n    Assert(!options.prefix || typeof options.prefix === \"object\", \"options.prefix must be of type object\");\n    const ref = Object.assign({}, internals.defaults, options);\n    delete ref.prefix;\n    const separator = ref.separator;\n    const context = internals.context(key, separator, options.prefix);\n    ref.type = context.type;\n    key = context.key;\n    if (ref.type === \"value\") {\n        if (context.root) {\n            Assert(!separator || key[0] !== separator, \"Cannot specify relative path with root prefix\");\n            ref.ancestor = \"root\";\n            if (!key) {\n                key = null;\n            }\n        }\n        if (separator && separator === key) {\n            key = null;\n            ref.ancestor = 0;\n        } else {\n            if (ref.ancestor !== undefined) {\n                Assert(!separator || !key || key[0] !== separator, \"Cannot combine prefix with ancestor option\");\n            } else {\n                const [ancestor, slice] = internals.ancestor(key, separator);\n                if (slice) {\n                    key = key.slice(slice);\n                    if (key === \"\") {\n                        key = null;\n                    }\n                }\n                ref.ancestor = ancestor;\n            }\n        }\n    }\n    ref.path = separator ? key === null ? [] : key.split(separator) : [\n        key\n    ];\n    return new internals.Ref(ref);\n};\nexports[\"in\"] = function(key, options = {}) {\n    return exports.create(key, {\n        ...options,\n        in: true\n    });\n};\nexports.isRef = function(ref) {\n    return ref ? !!ref[Common.symbols.ref] : false;\n};\ninternals.Ref = class {\n    constructor(options){\n        Assert(typeof options === \"object\", \"Invalid reference construction\");\n        Common.assertOptions(options, [\n            \"adjust\",\n            \"ancestor\",\n            \"in\",\n            \"iterables\",\n            \"map\",\n            \"path\",\n            \"render\",\n            \"separator\",\n            \"type\",\n            \"depth\",\n            \"key\",\n            \"root\",\n            \"display\" // Overridden\n        ]);\n        Assert([\n            false,\n            undefined\n        ].includes(options.separator) || typeof options.separator === \"string\" && options.separator.length === 1, \"Invalid separator\");\n        Assert(!options.adjust || typeof options.adjust === \"function\", \"options.adjust must be a function\");\n        Assert(!options.map || Array.isArray(options.map), \"options.map must be an array\");\n        Assert(!options.map || !options.adjust, \"Cannot set both map and adjust options\");\n        Object.assign(this, internals.defaults, options);\n        Assert(this.type === \"value\" || this.ancestor === undefined, \"Non-value references cannot reference ancestors\");\n        if (Array.isArray(this.map)) {\n            this.map = new Map(this.map);\n        }\n        this.depth = this.path.length;\n        this.key = this.path.length ? this.path.join(this.separator) : null;\n        this.root = this.path[0];\n        this.updateDisplay();\n    }\n    resolve(value, state, prefs, local, options = {}) {\n        Assert(!this.in || options.in, \"Invalid in() reference usage\");\n        if (this.type === \"global\") {\n            return this._resolve(prefs.context, state, options);\n        }\n        if (this.type === \"local\") {\n            return this._resolve(local, state, options);\n        }\n        if (!this.ancestor) {\n            return this._resolve(value, state, options);\n        }\n        if (this.ancestor === \"root\") {\n            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);\n        }\n        Assert(this.ancestor <= state.ancestors.length, \"Invalid reference exceeds the schema root:\", this.display);\n        return this._resolve(state.ancestors[this.ancestor - 1], state, options);\n    }\n    _resolve(target, state, options) {\n        let resolved;\n        if (this.type === \"value\" && state.mainstay.shadow && options.shadow !== false) {\n            resolved = state.mainstay.shadow.get(this.absolute(state));\n        }\n        if (resolved === undefined) {\n            resolved = Reach(target, this.path, {\n                iterables: this.iterables,\n                functions: true\n            });\n        }\n        if (this.adjust) {\n            resolved = this.adjust(resolved);\n        }\n        if (this.map) {\n            const mapped = this.map.get(resolved);\n            if (mapped !== undefined) {\n                resolved = mapped;\n            }\n        }\n        if (state.mainstay) {\n            state.mainstay.tracer.resolve(state, this, resolved);\n        }\n        return resolved;\n    }\n    toString() {\n        return this.display;\n    }\n    absolute(state) {\n        return [\n            ...state.path.slice(0, -this.ancestor),\n            ...this.path\n        ];\n    }\n    clone() {\n        return new internals.Ref(this);\n    }\n    describe() {\n        const ref = {\n            path: this.path\n        };\n        if (this.type !== \"value\") {\n            ref.type = this.type;\n        }\n        if (this.separator !== \".\") {\n            ref.separator = this.separator;\n        }\n        if (this.type === \"value\" && this.ancestor !== 1) {\n            ref.ancestor = this.ancestor;\n        }\n        if (this.map) {\n            ref.map = [\n                ...this.map\n            ];\n        }\n        for (const key of [\n            \"adjust\",\n            \"iterables\",\n            \"render\"\n        ]){\n            if (this[key] !== null && this[key] !== undefined) {\n                ref[key] = this[key];\n            }\n        }\n        if (this.in !== false) {\n            ref.in = true;\n        }\n        return {\n            ref\n        };\n    }\n    updateDisplay() {\n        const key = this.key !== null ? this.key : \"\";\n        if (this.type !== \"value\") {\n            this.display = `ref:${this.type}:${key}`;\n            return;\n        }\n        if (!this.separator) {\n            this.display = `ref:${key}`;\n            return;\n        }\n        if (!this.ancestor) {\n            this.display = `ref:${this.separator}${key}`;\n            return;\n        }\n        if (this.ancestor === \"root\") {\n            this.display = `ref:root:${key}`;\n            return;\n        }\n        if (this.ancestor === 1) {\n            this.display = `ref:${key || \"..\"}`;\n            return;\n        }\n        const lead = new Array(this.ancestor + 1).fill(this.separator).join(\"\");\n        this.display = `ref:${lead}${key || \"\"}`;\n    }\n};\ninternals.Ref.prototype[Common.symbols.ref] = true;\nexports.build = function(desc) {\n    desc = Object.assign({}, internals.defaults, desc);\n    if (desc.type === \"value\" && desc.ancestor === undefined) {\n        desc.ancestor = 1;\n    }\n    return new internals.Ref(desc);\n};\ninternals.context = function(key, separator, prefix = {}) {\n    key = key.trim();\n    if (prefix) {\n        const globalp = prefix.global === undefined ? \"$\" : prefix.global;\n        if (globalp !== separator && key.startsWith(globalp)) {\n            return {\n                key: key.slice(globalp.length),\n                type: \"global\"\n            };\n        }\n        const local = prefix.local === undefined ? \"#\" : prefix.local;\n        if (local !== separator && key.startsWith(local)) {\n            return {\n                key: key.slice(local.length),\n                type: \"local\"\n            };\n        }\n        const root = prefix.root === undefined ? \"/\" : prefix.root;\n        if (root !== separator && key.startsWith(root)) {\n            return {\n                key: key.slice(root.length),\n                type: \"value\",\n                root: true\n            };\n        }\n    }\n    return {\n        key,\n        type: \"value\"\n    };\n};\ninternals.ancestor = function(key, separator) {\n    if (!separator) {\n        return [\n            1,\n            0\n        ]; // 'a_b' -> 1 (parent)\n    }\n    if (key[0] !== separator) {\n        return [\n            1,\n            0\n        ];\n    }\n    if (key[1] !== separator) {\n        return [\n            0,\n            1\n        ];\n    }\n    let i = 2;\n    while(key[i] === separator){\n        ++i;\n    }\n    return [\n        i - 1,\n        i\n    ]; // '...a.b.' -> 2 (grandparent)\n};\nexports.toSibling = 0;\nexports.toParent = 1;\nexports.Manager = class {\n    constructor(){\n        this.refs = []; // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...\n    }\n    register(source, target) {\n        if (!source) {\n            return;\n        }\n        target = target === undefined ? exports.toParent : target;\n        // Array\n        if (Array.isArray(source)) {\n            for (const ref of source){\n                this.register(ref, target);\n            }\n            return;\n        }\n        // Schema\n        if (Common.isSchema(source)) {\n            for (const item of source._refs.refs){\n                if (item.ancestor - target >= 0) {\n                    this.refs.push({\n                        ancestor: item.ancestor - target,\n                        root: item.root\n                    });\n                }\n            }\n            return;\n        }\n        // Reference\n        if (exports.isRef(source) && source.type === \"value\" && source.ancestor - target >= 0) {\n            this.refs.push({\n                ancestor: source.ancestor - target,\n                root: source.root\n            });\n        }\n        // Template\n        Template = Template || __webpack_require__(/*! ./template */ \"(rsc)/./node_modules/joi/lib/template.js\");\n        if (Template.isTemplate(source)) {\n            this.register(source.refs(), target);\n        }\n    }\n    get length() {\n        return this.refs.length;\n    }\n    clone() {\n        const copy = new exports.Manager();\n        copy.refs = Clone(this.refs);\n        return copy;\n    }\n    reset() {\n        this.refs = [];\n    }\n    roots() {\n        return this.refs.filter((ref)=>!ref.ancestor).map((ref)=>ref.root);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9yZWYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUV0QixNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUV2QixJQUFJSTtBQUdKLE1BQU1DLFlBQVk7SUFDZEMsUUFBUUMsT0FBTztJQUNmQyxVQUFVO1FBQ05DLFFBQVE7UUFDUkMsSUFBSTtRQUNKQyxXQUFXO1FBQ1hDLEtBQUs7UUFDTEMsV0FBVztRQUNYQyxNQUFNO0lBQ1Y7QUFDSjtBQUdBQyxjQUFjLEdBQUcsU0FBVUUsR0FBRyxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUV4Q25CLE9BQU8sT0FBT2tCLFFBQVEsVUFBVSwwQkFBMEJBO0lBQzFEZCxPQUFPZ0IsYUFBYSxDQUFDRCxTQUFTO1FBQUM7UUFBVTtRQUFZO1FBQU07UUFBYTtRQUFPO1FBQVU7UUFBVTtLQUFZO0lBQy9HbkIsT0FBTyxDQUFDbUIsUUFBUUUsTUFBTSxJQUFJLE9BQU9GLFFBQVFFLE1BQU0sS0FBSyxVQUFVO0lBRTlELE1BQU1DLE1BQU1DLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdsQixVQUFVRyxRQUFRLEVBQUVVO0lBQ2xELE9BQU9HLElBQUlELE1BQU07SUFFakIsTUFBTVAsWUFBWVEsSUFBSVIsU0FBUztJQUMvQixNQUFNVyxVQUFVbkIsVUFBVW1CLE9BQU8sQ0FBQ1AsS0FBS0osV0FBV0ssUUFBUUUsTUFBTTtJQUNoRUMsSUFBSVAsSUFBSSxHQUFHVSxRQUFRVixJQUFJO0lBQ3ZCRyxNQUFNTyxRQUFRUCxHQUFHO0lBRWpCLElBQUlJLElBQUlQLElBQUksS0FBSyxTQUFTO1FBQ3RCLElBQUlVLFFBQVFDLElBQUksRUFBRTtZQUNkMUIsT0FBTyxDQUFDYyxhQUFhSSxHQUFHLENBQUMsRUFBRSxLQUFLSixXQUFXO1lBQzNDUSxJQUFJSyxRQUFRLEdBQUc7WUFDZixJQUFJLENBQUNULEtBQUs7Z0JBQ05BLE1BQU07WUFDVjtRQUNKO1FBRUEsSUFBSUosYUFDQUEsY0FBY0ksS0FBSztZQUVuQkEsTUFBTTtZQUNOSSxJQUFJSyxRQUFRLEdBQUc7UUFDbkIsT0FDSztZQUNELElBQUlMLElBQUlLLFFBQVEsS0FBS0MsV0FBVztnQkFDNUI1QixPQUFPLENBQUNjLGFBQWEsQ0FBQ0ksT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBS0osV0FBVztZQUN2RCxPQUNLO2dCQUNELE1BQU0sQ0FBQ2EsVUFBVUUsTUFBTSxHQUFHdkIsVUFBVXFCLFFBQVEsQ0FBQ1QsS0FBS0o7Z0JBQ2xELElBQUllLE9BQU87b0JBQ1BYLE1BQU1BLElBQUlXLEtBQUssQ0FBQ0E7b0JBQ2hCLElBQUlYLFFBQVEsSUFBSTt3QkFDWkEsTUFBTTtvQkFDVjtnQkFDSjtnQkFFQUksSUFBSUssUUFBUSxHQUFHQTtZQUNuQjtRQUNKO0lBQ0o7SUFFQUwsSUFBSVEsSUFBSSxHQUFHaEIsWUFBYUksUUFBUSxPQUFPLEVBQUUsR0FBR0EsSUFBSWEsS0FBSyxDQUFDakIsYUFBYztRQUFDSTtLQUFJO0lBRXpFLE9BQU8sSUFBSVosVUFBVTBCLEdBQUcsQ0FBQ1Y7QUFDN0I7QUFHQU4sYUFBVSxHQUFHLFNBQVVFLEdBQUcsRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFFcEMsT0FBT0gsUUFBUUMsTUFBTSxDQUFDQyxLQUFLO1FBQUUsR0FBR0MsT0FBTztRQUFFUixJQUFJO0lBQUs7QUFDdEQ7QUFHQUssYUFBYSxHQUFHLFNBQVVNLEdBQUc7SUFFekIsT0FBT0EsTUFBTSxDQUFDLENBQUNBLEdBQUcsQ0FBQ2xCLE9BQU84QixPQUFPLENBQUNaLEdBQUcsQ0FBQyxHQUFHO0FBQzdDO0FBR0FoQixVQUFVMEIsR0FBRyxHQUFHO0lBRVpHLFlBQVloQixPQUFPLENBQUU7UUFFakJuQixPQUFPLE9BQU9tQixZQUFZLFVBQVU7UUFDcENmLE9BQU9nQixhQUFhLENBQUNELFNBQVM7WUFDMUI7WUFBVTtZQUFZO1lBQU07WUFBYTtZQUFPO1lBQVE7WUFBVTtZQUFhO1lBQy9FO1lBQVM7WUFBTztZQUFRLFVBQWdFLGFBQWE7U0FDeEc7UUFFRG5CLE9BQU87WUFBQztZQUFPNEI7U0FBVSxDQUFDUSxRQUFRLENBQUNqQixRQUFRTCxTQUFTLEtBQUssT0FBT0ssUUFBUUwsU0FBUyxLQUFLLFlBQVlLLFFBQVFMLFNBQVMsQ0FBQ3VCLE1BQU0sS0FBSyxHQUFHO1FBQ2xJckMsT0FBTyxDQUFDbUIsUUFBUVQsTUFBTSxJQUFJLE9BQU9TLFFBQVFULE1BQU0sS0FBSyxZQUFZO1FBQ2hFVixPQUFPLENBQUNtQixRQUFRTixHQUFHLElBQUl5QixNQUFNQyxPQUFPLENBQUNwQixRQUFRTixHQUFHLEdBQUc7UUFDbkRiLE9BQU8sQ0FBQ21CLFFBQVFOLEdBQUcsSUFBSSxDQUFDTSxRQUFRVCxNQUFNLEVBQUU7UUFFeENhLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLEVBQUVsQixVQUFVRyxRQUFRLEVBQUVVO1FBRXhDbkIsT0FBTyxJQUFJLENBQUNlLElBQUksS0FBSyxXQUFXLElBQUksQ0FBQ1ksUUFBUSxLQUFLQyxXQUFXO1FBRTdELElBQUlVLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUMxQixHQUFHLEdBQUc7WUFDekIsSUFBSSxDQUFDQSxHQUFHLEdBQUcsSUFBSTJCLElBQUksSUFBSSxDQUFDM0IsR0FBRztRQUMvQjtRQUVBLElBQUksQ0FBQzRCLEtBQUssR0FBRyxJQUFJLENBQUNYLElBQUksQ0FBQ08sTUFBTTtRQUM3QixJQUFJLENBQUNuQixHQUFHLEdBQUcsSUFBSSxDQUFDWSxJQUFJLENBQUNPLE1BQU0sR0FBRyxJQUFJLENBQUNQLElBQUksQ0FBQ1ksSUFBSSxDQUFDLElBQUksQ0FBQzVCLFNBQVMsSUFBSTtRQUMvRCxJQUFJLENBQUNZLElBQUksR0FBRyxJQUFJLENBQUNJLElBQUksQ0FBQyxFQUFFO1FBRXhCLElBQUksQ0FBQ2EsYUFBYTtJQUN0QjtJQUVBQyxRQUFRQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU3QixVQUFVLENBQUMsQ0FBQyxFQUFFO1FBRTlDbkIsT0FBTyxDQUFDLElBQUksQ0FBQ1csRUFBRSxJQUFJUSxRQUFRUixFQUFFLEVBQUU7UUFFL0IsSUFBSSxJQUFJLENBQUNJLElBQUksS0FBSyxVQUFVO1lBQ3hCLE9BQU8sSUFBSSxDQUFDa0MsUUFBUSxDQUFDRixNQUFNdEIsT0FBTyxFQUFFcUIsT0FBTzNCO1FBQy9DO1FBRUEsSUFBSSxJQUFJLENBQUNKLElBQUksS0FBSyxTQUFTO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDa0MsUUFBUSxDQUFDRCxPQUFPRixPQUFPM0I7UUFDdkM7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDUSxRQUFRLEVBQUU7WUFDaEIsT0FBTyxJQUFJLENBQUNzQixRQUFRLENBQUNKLE9BQU9DLE9BQU8zQjtRQUN2QztRQUVBLElBQUksSUFBSSxDQUFDUSxRQUFRLEtBQUssUUFBUTtZQUMxQixPQUFPLElBQUksQ0FBQ3NCLFFBQVEsQ0FBQ0gsTUFBTUksU0FBUyxDQUFDSixNQUFNSSxTQUFTLENBQUNiLE1BQU0sR0FBRyxFQUFFLEVBQUVTLE9BQU8zQjtRQUM3RTtRQUVBbkIsT0FBTyxJQUFJLENBQUMyQixRQUFRLElBQUltQixNQUFNSSxTQUFTLENBQUNiLE1BQU0sRUFBRSw4Q0FBOEMsSUFBSSxDQUFDYyxPQUFPO1FBQzFHLE9BQU8sSUFBSSxDQUFDRixRQUFRLENBQUNILE1BQU1JLFNBQVMsQ0FBQyxJQUFJLENBQUN2QixRQUFRLEdBQUcsRUFBRSxFQUFFbUIsT0FBTzNCO0lBQ3BFO0lBRUE4QixTQUFTRyxNQUFNLEVBQUVOLEtBQUssRUFBRTNCLE9BQU8sRUFBRTtRQUU3QixJQUFJa0M7UUFFSixJQUFJLElBQUksQ0FBQ3RDLElBQUksS0FBSyxXQUNkK0IsTUFBTVEsUUFBUSxDQUFDQyxNQUFNLElBQ3JCcEMsUUFBUW9DLE1BQU0sS0FBSyxPQUFPO1lBRTFCRixXQUFXUCxNQUFNUSxRQUFRLENBQUNDLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsUUFBUSxDQUFDWDtRQUN2RDtRQUVBLElBQUlPLGFBQWF6QixXQUFXO1lBQ3hCeUIsV0FBV2xELE1BQU1pRCxRQUFRLElBQUksQ0FBQ3RCLElBQUksRUFBRTtnQkFBRWxCLFdBQVcsSUFBSSxDQUFDQSxTQUFTO2dCQUFFOEMsV0FBVztZQUFLO1FBQ3JGO1FBRUEsSUFBSSxJQUFJLENBQUNoRCxNQUFNLEVBQUU7WUFDYjJDLFdBQVcsSUFBSSxDQUFDM0MsTUFBTSxDQUFDMkM7UUFDM0I7UUFFQSxJQUFJLElBQUksQ0FBQ3hDLEdBQUcsRUFBRTtZQUNWLE1BQU04QyxTQUFTLElBQUksQ0FBQzlDLEdBQUcsQ0FBQzJDLEdBQUcsQ0FBQ0g7WUFDNUIsSUFBSU0sV0FBVy9CLFdBQVc7Z0JBQ3RCeUIsV0FBV007WUFDZjtRQUNKO1FBRUEsSUFBSWIsTUFBTVEsUUFBUSxFQUFFO1lBQ2hCUixNQUFNUSxRQUFRLENBQUNNLE1BQU0sQ0FBQ2hCLE9BQU8sQ0FBQ0UsT0FBTyxJQUFJLEVBQUVPO1FBQy9DO1FBRUEsT0FBT0E7SUFDWDtJQUVBUSxXQUFXO1FBRVAsT0FBTyxJQUFJLENBQUNWLE9BQU87SUFDdkI7SUFFQU0sU0FBU1gsS0FBSyxFQUFFO1FBRVosT0FBTztlQUFJQSxNQUFNaEIsSUFBSSxDQUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQ0YsUUFBUTtlQUFNLElBQUksQ0FBQ0csSUFBSTtTQUFDO0lBQ2pFO0lBRUFnQyxRQUFRO1FBRUosT0FBTyxJQUFJeEQsVUFBVTBCLEdBQUcsQ0FBQyxJQUFJO0lBQ2pDO0lBRUErQixXQUFXO1FBRVAsTUFBTXpDLE1BQU07WUFBRVEsTUFBTSxJQUFJLENBQUNBLElBQUk7UUFBQztRQUU5QixJQUFJLElBQUksQ0FBQ2YsSUFBSSxLQUFLLFNBQVM7WUFDdkJPLElBQUlQLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7UUFDeEI7UUFFQSxJQUFJLElBQUksQ0FBQ0QsU0FBUyxLQUFLLEtBQUs7WUFDeEJRLElBQUlSLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVM7UUFDbEM7UUFFQSxJQUFJLElBQUksQ0FBQ0MsSUFBSSxLQUFLLFdBQ2QsSUFBSSxDQUFDWSxRQUFRLEtBQUssR0FBRztZQUVyQkwsSUFBSUssUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUNoQztRQUVBLElBQUksSUFBSSxDQUFDZCxHQUFHLEVBQUU7WUFDVlMsSUFBSVQsR0FBRyxHQUFHO21CQUFJLElBQUksQ0FBQ0EsR0FBRzthQUFDO1FBQzNCO1FBRUEsS0FBSyxNQUFNSyxPQUFPO1lBQUM7WUFBVTtZQUFhO1NBQVMsQ0FBRTtZQUNqRCxJQUFJLElBQUksQ0FBQ0EsSUFBSSxLQUFLLFFBQ2QsSUFBSSxDQUFDQSxJQUFJLEtBQUtVLFdBQVc7Z0JBRXpCTixHQUFHLENBQUNKLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7WUFDeEI7UUFDSjtRQUVBLElBQUksSUFBSSxDQUFDUCxFQUFFLEtBQUssT0FBTztZQUNuQlcsSUFBSVgsRUFBRSxHQUFHO1FBQ2I7UUFFQSxPQUFPO1lBQUVXO1FBQUk7SUFDakI7SUFFQXFCLGdCQUFnQjtRQUVaLE1BQU16QixNQUFNLElBQUksQ0FBQ0EsR0FBRyxLQUFLLE9BQU8sSUFBSSxDQUFDQSxHQUFHLEdBQUc7UUFDM0MsSUFBSSxJQUFJLENBQUNILElBQUksS0FBSyxTQUFTO1lBQ3ZCLElBQUksQ0FBQ29DLE9BQU8sR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUNwQyxJQUFJLENBQUMsQ0FBQyxFQUFFRyxJQUFJLENBQUM7WUFDeEM7UUFDSjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUNKLFNBQVMsRUFBRTtZQUNqQixJQUFJLENBQUNxQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLEVBQUVqQyxJQUFJLENBQUM7WUFDM0I7UUFDSjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUNTLFFBQVEsRUFBRTtZQUNoQixJQUFJLENBQUN3QixPQUFPLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDckMsU0FBUyxDQUFDLEVBQUVJLElBQUksQ0FBQztZQUM1QztRQUNKO1FBRUEsSUFBSSxJQUFJLENBQUNTLFFBQVEsS0FBSyxRQUFRO1lBQzFCLElBQUksQ0FBQ3dCLE9BQU8sR0FBRyxDQUFDLFNBQVMsRUFBRWpDLElBQUksQ0FBQztZQUNoQztRQUNKO1FBRUEsSUFBSSxJQUFJLENBQUNTLFFBQVEsS0FBSyxHQUFHO1lBQ3JCLElBQUksQ0FBQ3dCLE9BQU8sR0FBRyxDQUFDLElBQUksRUFBRWpDLE9BQU8sS0FBSyxDQUFDO1lBQ25DO1FBQ0o7UUFFQSxNQUFNOEMsT0FBTyxJQUFJMUIsTUFBTSxJQUFJLENBQUNYLFFBQVEsR0FBRyxHQUFHc0MsSUFBSSxDQUFDLElBQUksQ0FBQ25ELFNBQVMsRUFBRTRCLElBQUksQ0FBQztRQUNwRSxJQUFJLENBQUNTLE9BQU8sR0FBRyxDQUFDLElBQUksRUFBRWEsS0FBSyxFQUFFOUMsT0FBTyxHQUFHLENBQUM7SUFDNUM7QUFDSjtBQUdBWixVQUFVMEIsR0FBRyxDQUFDa0MsU0FBUyxDQUFDOUQsT0FBTzhCLE9BQU8sQ0FBQ1osR0FBRyxDQUFDLEdBQUc7QUFHOUNOLGFBQWEsR0FBRyxTQUFVb0QsSUFBSTtJQUUxQkEsT0FBTzdDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdsQixVQUFVRyxRQUFRLEVBQUUyRDtJQUM3QyxJQUFJQSxLQUFLckQsSUFBSSxLQUFLLFdBQ2RxRCxLQUFLekMsUUFBUSxLQUFLQyxXQUFXO1FBRTdCd0MsS0FBS3pDLFFBQVEsR0FBRztJQUNwQjtJQUVBLE9BQU8sSUFBSXJCLFVBQVUwQixHQUFHLENBQUNvQztBQUM3QjtBQUdBOUQsVUFBVW1CLE9BQU8sR0FBRyxTQUFVUCxHQUFHLEVBQUVKLFNBQVMsRUFBRU8sU0FBUyxDQUFDLENBQUM7SUFFckRILE1BQU1BLElBQUltRCxJQUFJO0lBRWQsSUFBSWhELFFBQVE7UUFDUixNQUFNaUQsVUFBVWpELE9BQU9rRCxNQUFNLEtBQUszQyxZQUFZLE1BQU1QLE9BQU9rRCxNQUFNO1FBQ2pFLElBQUlELFlBQVl4RCxhQUNaSSxJQUFJc0QsVUFBVSxDQUFDRixVQUFVO1lBRXpCLE9BQU87Z0JBQUVwRCxLQUFLQSxJQUFJVyxLQUFLLENBQUN5QyxRQUFRakMsTUFBTTtnQkFBR3RCLE1BQU07WUFBUztRQUM1RDtRQUVBLE1BQU1pQyxRQUFRM0IsT0FBTzJCLEtBQUssS0FBS3BCLFlBQVksTUFBTVAsT0FBTzJCLEtBQUs7UUFDN0QsSUFBSUEsVUFBVWxDLGFBQ1ZJLElBQUlzRCxVQUFVLENBQUN4QixRQUFRO1lBRXZCLE9BQU87Z0JBQUU5QixLQUFLQSxJQUFJVyxLQUFLLENBQUNtQixNQUFNWCxNQUFNO2dCQUFHdEIsTUFBTTtZQUFRO1FBQ3pEO1FBRUEsTUFBTVcsT0FBT0wsT0FBT0ssSUFBSSxLQUFLRSxZQUFZLE1BQU1QLE9BQU9LLElBQUk7UUFDMUQsSUFBSUEsU0FBU1osYUFDVEksSUFBSXNELFVBQVUsQ0FBQzlDLE9BQU87WUFFdEIsT0FBTztnQkFBRVIsS0FBS0EsSUFBSVcsS0FBSyxDQUFDSCxLQUFLVyxNQUFNO2dCQUFHdEIsTUFBTTtnQkFBU1csTUFBTTtZQUFLO1FBQ3BFO0lBQ0o7SUFFQSxPQUFPO1FBQUVSO1FBQUtILE1BQU07SUFBUTtBQUNoQztBQUdBVCxVQUFVcUIsUUFBUSxHQUFHLFNBQVVULEdBQUcsRUFBRUosU0FBUztJQUV6QyxJQUFJLENBQUNBLFdBQVc7UUFDWixPQUFPO1lBQUM7WUFBRztTQUFFLEVBQWUsc0JBQXNCO0lBQ3REO0lBRUEsSUFBSUksR0FBRyxDQUFDLEVBQUUsS0FBS0osV0FBVztRQUN0QixPQUFPO1lBQUM7WUFBRztTQUFFO0lBQ2pCO0lBRUEsSUFBSUksR0FBRyxDQUFDLEVBQUUsS0FBS0osV0FBVztRQUN0QixPQUFPO1lBQUM7WUFBRztTQUFFO0lBQ2pCO0lBRUEsSUFBSTJELElBQUk7SUFDUixNQUFPdkQsR0FBRyxDQUFDdUQsRUFBRSxLQUFLM0QsVUFBVztRQUN6QixFQUFFMkQ7SUFDTjtJQUVBLE9BQU87UUFBQ0EsSUFBSTtRQUFHQTtLQUFFLEVBQWUsK0JBQStCO0FBQ25FO0FBR0F6RCxpQkFBaUIsR0FBRztBQUVwQkEsZ0JBQWdCLEdBQUc7QUFHbkJBLGVBQWUsR0FBRztJQUVkbUIsYUFBYztRQUVWLElBQUksQ0FBQzBDLElBQUksR0FBRyxFQUFFLEVBQXNCLCtEQUErRDtJQUN2RztJQUVBQyxTQUFTQyxNQUFNLEVBQUUzQixNQUFNLEVBQUU7UUFFckIsSUFBSSxDQUFDMkIsUUFBUTtZQUNUO1FBQ0o7UUFFQTNCLFNBQVNBLFdBQVd4QixZQUFZWixRQUFRMkQsUUFBUSxHQUFHdkI7UUFFbkQsUUFBUTtRQUVSLElBQUlkLE1BQU1DLE9BQU8sQ0FBQ3dDLFNBQVM7WUFDdkIsS0FBSyxNQUFNekQsT0FBT3lELE9BQVE7Z0JBQ3RCLElBQUksQ0FBQ0QsUUFBUSxDQUFDeEQsS0FBSzhCO1lBQ3ZCO1lBRUE7UUFDSjtRQUVBLFNBQVM7UUFFVCxJQUFJaEQsT0FBTzRFLFFBQVEsQ0FBQ0QsU0FBUztZQUN6QixLQUFLLE1BQU1FLFFBQVFGLE9BQU9HLEtBQUssQ0FBQ0wsSUFBSSxDQUFFO2dCQUNsQyxJQUFJSSxLQUFLdEQsUUFBUSxHQUFHeUIsVUFBVSxHQUFHO29CQUM3QixJQUFJLENBQUN5QixJQUFJLENBQUNNLElBQUksQ0FBQzt3QkFBRXhELFVBQVVzRCxLQUFLdEQsUUFBUSxHQUFHeUI7d0JBQVExQixNQUFNdUQsS0FBS3ZELElBQUk7b0JBQUM7Z0JBQ3ZFO1lBQ0o7WUFFQTtRQUNKO1FBRUEsWUFBWTtRQUVaLElBQUlWLFFBQVFpQixLQUFLLENBQUM4QyxXQUNkQSxPQUFPaEUsSUFBSSxLQUFLLFdBQ2hCZ0UsT0FBT3BELFFBQVEsR0FBR3lCLFVBQVUsR0FBRztZQUUvQixJQUFJLENBQUN5QixJQUFJLENBQUNNLElBQUksQ0FBQztnQkFBRXhELFVBQVVvRCxPQUFPcEQsUUFBUSxHQUFHeUI7Z0JBQVExQixNQUFNcUQsT0FBT3JELElBQUk7WUFBQztRQUMzRTtRQUVBLFdBQVc7UUFFWHJCLFdBQVdBLFlBQVlKLG1CQUFPQSxDQUFDO1FBRS9CLElBQUlJLFNBQVMrRSxVQUFVLENBQUNMLFNBQVM7WUFDN0IsSUFBSSxDQUFDRCxRQUFRLENBQUNDLE9BQU9GLElBQUksSUFBSXpCO1FBQ2pDO0lBQ0o7SUFFQSxJQUFJZixTQUFTO1FBRVQsT0FBTyxJQUFJLENBQUN3QyxJQUFJLENBQUN4QyxNQUFNO0lBQzNCO0lBRUF5QixRQUFRO1FBRUosTUFBTXVCLE9BQU8sSUFBSXJFLFFBQVE0RCxPQUFPO1FBQ2hDUyxLQUFLUixJQUFJLEdBQUczRSxNQUFNLElBQUksQ0FBQzJFLElBQUk7UUFDM0IsT0FBT1E7SUFDWDtJQUVBQyxRQUFRO1FBRUosSUFBSSxDQUFDVCxJQUFJLEdBQUcsRUFBRTtJQUNsQjtJQUVBVSxRQUFRO1FBRUosT0FBTyxJQUFJLENBQUNWLElBQUksQ0FBQ1csTUFBTSxDQUFDLENBQUNsRSxNQUFRLENBQUNBLElBQUlLLFFBQVEsRUFBRWQsR0FBRyxDQUFDLENBQUNTLE1BQVFBLElBQUlJLElBQUk7SUFDekU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvcmVmLmpzPzE2ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxubGV0IFRlbXBsYXRlO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzeW1ib2w6IFN5bWJvbCgncmVmJyksICAgICAgLy8gVXNlZCB0byBpbnRlcm5hbGx5IGlkZW50aWZ5IHJlZmVyZW5jZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBhZGp1c3Q6IG51bGwsXG4gICAgICAgIGluOiBmYWxzZSxcbiAgICAgICAgaXRlcmFibGVzOiBudWxsLFxuICAgICAgICBtYXA6IG51bGwsXG4gICAgICAgIHNlcGFyYXRvcjogJy4nLFxuICAgICAgICB0eXBlOiAndmFsdWUnXG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQXNzZXJ0KHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnLCAnSW52YWxpZCByZWZlcmVuY2Uga2V5OicsIGtleSk7XG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhZGp1c3QnLCAnYW5jZXN0b3InLCAnaW4nLCAnaXRlcmFibGVzJywgJ21hcCcsICdwcmVmaXgnLCAncmVuZGVyJywgJ3NlcGFyYXRvciddKTtcbiAgICBBc3NlcnQoIW9wdGlvbnMucHJlZml4IHx8IHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gJ29iamVjdCcsICdvcHRpb25zLnByZWZpeCBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG5cbiAgICBjb25zdCByZWYgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSByZWYucHJlZml4O1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gcmVmLnNlcGFyYXRvcjtcbiAgICBjb25zdCBjb250ZXh0ID0gaW50ZXJuYWxzLmNvbnRleHQoa2V5LCBzZXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICByZWYudHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICBrZXkgPSBjb250ZXh0LmtleTtcblxuICAgIGlmIChyZWYudHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBpZiAoY29udGV4dC5yb290KSB7XG4gICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCBrZXlbMF0gIT09IHNlcGFyYXRvciwgJ0Nhbm5vdCBzcGVjaWZ5IHJlbGF0aXZlIHBhdGggd2l0aCByb290IHByZWZpeCcpO1xuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gJ3Jvb3QnO1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcGFyYXRvciAmJlxuICAgICAgICAgICAgc2VwYXJhdG9yID09PSBrZXkpIHtcblxuICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVmLmFuY2VzdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCAha2V5IHx8IGtleVswXSAhPT0gc2VwYXJhdG9yLCAnQ2Fubm90IGNvbWJpbmUgcHJlZml4IHdpdGggYW5jZXN0b3Igb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYW5jZXN0b3IsIHNsaWNlXSA9IGludGVybmFscy5hbmNlc3RvcihrZXksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zbGljZShzbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gYW5jZXN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWYucGF0aCA9IHNlcGFyYXRvciA/IChrZXkgPT09IG51bGwgPyBbXSA6IGtleS5zcGxpdChzZXBhcmF0b3IpKSA6IFtrZXldO1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHJlZik7XG59O1xuXG5cbmV4cG9ydHMuaW4gPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShrZXksIHsgLi4ub3B0aW9ucywgaW46IHRydWUgfSk7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG5cbiAgICByZXR1cm4gcmVmID8gISFyZWZbQ29tbW9uLnN5bWJvbHMucmVmXSA6IGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuUmVmID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJlZmVyZW5jZSBjb25zdHJ1Y3Rpb24nKTtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgW1xuICAgICAgICAgICAgJ2FkanVzdCcsICdhbmNlc3RvcicsICdpbicsICdpdGVyYWJsZXMnLCAnbWFwJywgJ3BhdGgnLCAncmVuZGVyJywgJ3NlcGFyYXRvcicsICd0eXBlJywgIC8vIENvcGllZFxuICAgICAgICAgICAgJ2RlcHRoJywgJ2tleScsICdyb290JywgJ2Rpc3BsYXknICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRkZW5cbiAgICAgICAgXSk7XG5cbiAgICAgICAgQXNzZXJ0KFtmYWxzZSwgdW5kZWZpbmVkXS5pbmNsdWRlcyhvcHRpb25zLnNlcGFyYXRvcikgfHwgdHlwZW9mIG9wdGlvbnMuc2VwYXJhdG9yID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLnNlcGFyYXRvci5sZW5ndGggPT09IDEsICdJbnZhbGlkIHNlcGFyYXRvcicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYWRqdXN0IHx8IHR5cGVvZiBvcHRpb25zLmFkanVzdCA9PT0gJ2Z1bmN0aW9uJywgJ29wdGlvbnMuYWRqdXN0IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXApLCAnb3B0aW9ucy5tYXAgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8ICFvcHRpb25zLmFkanVzdCwgJ0Nhbm5vdCBzZXQgYm90aCBtYXAgYW5kIGFkanVzdCBvcHRpb25zJyk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIEFzc2VydCh0aGlzLnR5cGUgPT09ICd2YWx1ZScgfHwgdGhpcy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkLCAnTm9uLXZhbHVlIHJlZmVyZW5jZXMgY2Fubm90IHJlZmVyZW5jZSBhbmNlc3RvcnMnKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hcCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCh0aGlzLm1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnBhdGgubGVuZ3RoID8gdGhpcy5wYXRoLmpvaW4odGhpcy5zZXBhcmF0b3IpIDogbnVsbDtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wYXRoWzBdO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5pbiB8fCBvcHRpb25zLmluLCAnSW52YWxpZCBpbigpIHJlZmVyZW5jZSB1c2FnZScpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShwcmVmcy5jb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShsb2NhbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoc3RhdGUuYW5jZXN0b3JzW3N0YXRlLmFuY2VzdG9ycy5sZW5ndGggLSAxXSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMuYW5jZXN0b3IgPD0gc3RhdGUuYW5jZXN0b3JzLmxlbmd0aCwgJ0ludmFsaWQgcmVmZXJlbmNlIGV4Y2VlZHMgdGhlIHNjaGVtYSByb290OicsIHRoaXMuZGlzcGxheSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHN0YXRlLmFuY2VzdG9yc1t0aGlzLmFuY2VzdG9yIC0gMV0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfcmVzb2x2ZSh0YXJnZXQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHJlc29sdmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnNoYWRvdyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5zaGFkb3cgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHJlc29sdmVkID0gc3RhdGUubWFpbnN0YXkuc2hhZG93LmdldCh0aGlzLmFic29sdXRlKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBSZWFjaCh0YXJnZXQsIHRoaXMucGF0aCwgeyBpdGVyYWJsZXM6IHRoaXMuaXRlcmFibGVzLCBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hZGp1c3QpIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gdGhpcy5hZGp1c3QocmVzb2x2ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWQgPSB0aGlzLm1hcC5nZXQocmVzb2x2ZWQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBtYXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUubWFpbnN0YXkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5yZXNvbHZlKHN0YXRlLCB0aGlzLCByZXNvbHZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheTtcbiAgICB9XG5cbiAgICBhYnNvbHV0ZShzdGF0ZSkge1xuXG4gICAgICAgIHJldHVybiBbLi4uc3RhdGUucGF0aC5zbGljZSgwLCAtdGhpcy5hbmNlc3RvciksIC4uLnRoaXMucGF0aF07XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHRoaXMpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IHJlZiA9IHsgcGF0aDogdGhpcy5wYXRoIH07XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgcmVmLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgcmVmLnNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgdGhpcy5hbmNlc3RvciAhPT0gMSkge1xuXG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSB0aGlzLmFuY2VzdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICByZWYubWFwID0gWy4uLnRoaXMubWFwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnYWRqdXN0JywgJ2l0ZXJhYmxlcycsICdyZW5kZXInXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNba2V5XSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZWZba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVmLmluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlZiB9O1xuICAgIH1cblxuICAgIHVwZGF0ZURpc3BsYXkoKSB7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXkgIT09IG51bGwgPyB0aGlzLmtleSA6ICcnO1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy50eXBlfToke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy5zZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2VzdG9yID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6cm9vdDoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtrZXkgfHwgJy4uJ31gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVhZCA9IG5ldyBBcnJheSh0aGlzLmFuY2VzdG9yICsgMSkuZmlsbCh0aGlzLnNlcGFyYXRvcikuam9pbignJyk7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtsZWFkfSR7a2V5IHx8ICcnfWA7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVmLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5yZWZdID0gdHJ1ZTtcblxuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKGRlc2MpIHtcblxuICAgIGRlc2MgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIGRlc2MpO1xuICAgIGlmIChkZXNjLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgZGVzYy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgZGVzYy5hbmNlc3RvciA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKGRlc2MpO1xufTtcblxuXG5pbnRlcm5hbHMuY29udGV4dCA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvciwgcHJlZml4ID0ge30pIHtcblxuICAgIGtleSA9IGtleS50cmltKCk7XG5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbHAgPSBwcmVmaXguZ2xvYmFsID09PSB1bmRlZmluZWQgPyAnJCcgOiBwcmVmaXguZ2xvYmFsO1xuICAgICAgICBpZiAoZ2xvYmFscCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChnbG9iYWxwKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGtleS5zbGljZShnbG9iYWxwLmxlbmd0aCksIHR5cGU6ICdnbG9iYWwnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2NhbCA9IHByZWZpeC5sb2NhbCA9PT0gdW5kZWZpbmVkID8gJyMnIDogcHJlZml4LmxvY2FsO1xuICAgICAgICBpZiAobG9jYWwgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgobG9jYWwpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKGxvY2FsLmxlbmd0aCksIHR5cGU6ICdsb2NhbCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvb3QgPSBwcmVmaXgucm9vdCA9PT0gdW5kZWZpbmVkID8gJy8nIDogcHJlZml4LnJvb3Q7XG4gICAgICAgIGlmIChyb290ICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKHJvb3QpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKHJvb3QubGVuZ3RoKSwgdHlwZTogJ3ZhbHVlJywgcm9vdDogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsga2V5LCB0eXBlOiAndmFsdWUnIH07XG59O1xuXG5cbmludGVybmFscy5hbmNlc3RvciA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvcikge1xuXG4gICAgaWYgKCFzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFsxLCAwXTsgICAgICAgICAgICAgIC8vICdhX2InIC0+IDEgKHBhcmVudClcbiAgICB9XG5cbiAgICBpZiAoa2V5WzBdICE9PSBzZXBhcmF0b3IpIHsgICAgIC8vICdhLmInIC0+IDEgKHBhcmVudClcbiAgICAgICAgcmV0dXJuIFsxLCAwXTtcbiAgICB9XG5cbiAgICBpZiAoa2V5WzFdICE9PSBzZXBhcmF0b3IpIHsgICAgIC8vICcuYS5iJyAtPiAwIChzZWxmKVxuICAgICAgICByZXR1cm4gWzAsIDFdO1xuICAgIH1cblxuICAgIGxldCBpID0gMjtcbiAgICB3aGlsZSAoa2V5W2ldID09PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgKytpO1xuICAgIH1cblxuICAgIHJldHVybiBbaSAtIDEsIGldOyAgICAgICAgICAgICAgLy8gJy4uLmEuYi4nIC0+IDIgKGdyYW5kcGFyZW50KVxufTtcblxuXG5leHBvcnRzLnRvU2libGluZyA9IDA7XG5cbmV4cG9ydHMudG9QYXJlbnQgPSAxO1xuXG5cbmV4cG9ydHMuTWFuYWdlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMucmVmcyA9IFtdOyAgICAgICAgICAgICAgICAgICAgIC8vIDA6IFtzZWxmIHJlZnNdLCAxOiBbcGFyZW50IHJlZnNdLCAyOiBbZ3JhbmRwYXJlbnQgcmVmc10sIC4uLlxuICAgIH1cblxuICAgIHJlZ2lzdGVyKHNvdXJjZSwgdGFyZ2V0KSB7XG5cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZXhwb3J0cy50b1BhcmVudCA6IHRhcmdldDtcblxuICAgICAgICAvLyBBcnJheVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIocmVmLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTY2hlbWFcblxuICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzb3VyY2UuX3JlZnMucmVmcykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmFuY2VzdG9yIC0gdGFyZ2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZzLnB1c2goeyBhbmNlc3RvcjogaXRlbS5hbmNlc3RvciAtIHRhcmdldCwgcm9vdDogaXRlbS5yb290IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKGV4cG9ydHMuaXNSZWYoc291cmNlKSAmJlxuICAgICAgICAgICAgc291cmNlLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHNvdXJjZS5hbmNlc3RvciAtIHRhcmdldCA+PSAwKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVmcy5wdXNoKHsgYW5jZXN0b3I6IHNvdXJjZS5hbmNlc3RvciAtIHRhcmdldCwgcm9vdDogc291cmNlLnJvb3QgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wbGF0ZVxuXG4gICAgICAgIFRlbXBsYXRlID0gVGVtcGxhdGUgfHwgcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG4gICAgICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoc291cmNlLnJlZnMoKSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBleHBvcnRzLk1hbmFnZXIoKTtcbiAgICAgICAgY29weS5yZWZzID0gQ2xvbmUodGhpcy5yZWZzKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgdGhpcy5yZWZzID0gW107XG4gICAgfVxuXG4gICAgcm9vdHMoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy5maWx0ZXIoKHJlZikgPT4gIXJlZi5hbmNlc3RvcikubWFwKChyZWYpID0+IHJlZi5yb290KTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbIkFzc2VydCIsInJlcXVpcmUiLCJDbG9uZSIsIlJlYWNoIiwiQ29tbW9uIiwiVGVtcGxhdGUiLCJpbnRlcm5hbHMiLCJzeW1ib2wiLCJTeW1ib2wiLCJkZWZhdWx0cyIsImFkanVzdCIsImluIiwiaXRlcmFibGVzIiwibWFwIiwic2VwYXJhdG9yIiwidHlwZSIsImV4cG9ydHMiLCJjcmVhdGUiLCJrZXkiLCJvcHRpb25zIiwiYXNzZXJ0T3B0aW9ucyIsInByZWZpeCIsInJlZiIsIk9iamVjdCIsImFzc2lnbiIsImNvbnRleHQiLCJyb290IiwiYW5jZXN0b3IiLCJ1bmRlZmluZWQiLCJzbGljZSIsInBhdGgiLCJzcGxpdCIsIlJlZiIsImlzUmVmIiwic3ltYm9scyIsImNvbnN0cnVjdG9yIiwiaW5jbHVkZXMiLCJsZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJNYXAiLCJkZXB0aCIsImpvaW4iLCJ1cGRhdGVEaXNwbGF5IiwicmVzb2x2ZSIsInZhbHVlIiwic3RhdGUiLCJwcmVmcyIsImxvY2FsIiwiX3Jlc29sdmUiLCJhbmNlc3RvcnMiLCJkaXNwbGF5IiwidGFyZ2V0IiwicmVzb2x2ZWQiLCJtYWluc3RheSIsInNoYWRvdyIsImdldCIsImFic29sdXRlIiwiZnVuY3Rpb25zIiwibWFwcGVkIiwidHJhY2VyIiwidG9TdHJpbmciLCJjbG9uZSIsImRlc2NyaWJlIiwibGVhZCIsImZpbGwiLCJwcm90b3R5cGUiLCJidWlsZCIsImRlc2MiLCJ0cmltIiwiZ2xvYmFscCIsImdsb2JhbCIsInN0YXJ0c1dpdGgiLCJpIiwidG9TaWJsaW5nIiwidG9QYXJlbnQiLCJNYW5hZ2VyIiwicmVmcyIsInJlZ2lzdGVyIiwic291cmNlIiwiaXNTY2hlbWEiLCJpdGVtIiwiX3JlZnMiLCJwdXNoIiwiaXNUZW1wbGF0ZSIsImNvcHkiLCJyZXNldCIsInJvb3RzIiwiZmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/ref.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/schemas.js":
/*!*****************************************!*\
  !*** ./node_modules/joi/lib/schemas.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Joi = __webpack_require__(/*! ./index */ \"(rsc)/./node_modules/joi/lib/index.js\");\nconst internals = {};\n// Preferences\ninternals.wrap = Joi.string().min(1).max(2).allow(false);\nexports.preferences = Joi.object({\n    allowUnknown: Joi.boolean(),\n    abortEarly: Joi.boolean(),\n    artifacts: Joi.boolean(),\n    cache: Joi.boolean(),\n    context: Joi.object(),\n    convert: Joi.boolean(),\n    dateFormat: Joi.valid(\"date\", \"iso\", \"string\", \"time\", \"utc\"),\n    debug: Joi.boolean(),\n    errors: {\n        escapeHtml: Joi.boolean(),\n        label: Joi.valid(\"path\", \"key\", false),\n        language: [\n            Joi.string(),\n            Joi.object().ref()\n        ],\n        render: Joi.boolean(),\n        stack: Joi.boolean(),\n        wrap: {\n            label: internals.wrap,\n            array: internals.wrap,\n            string: internals.wrap\n        }\n    },\n    externals: Joi.boolean(),\n    messages: Joi.object(),\n    noDefaults: Joi.boolean(),\n    nonEnumerables: Joi.boolean(),\n    presence: Joi.valid(\"required\", \"optional\", \"forbidden\"),\n    skipFunctions: Joi.boolean(),\n    stripUnknown: Joi.object({\n        arrays: Joi.boolean(),\n        objects: Joi.boolean()\n    }).or(\"arrays\", \"objects\").allow(true, false),\n    warnings: Joi.boolean()\n}).strict();\n// Extensions\ninternals.nameRx = /^[a-zA-Z0-9]\\w*$/;\ninternals.rule = Joi.object({\n    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),\n    args: Joi.array().items(Joi.string(), Joi.object({\n        name: Joi.string().pattern(internals.nameRx).required(),\n        ref: Joi.boolean(),\n        assert: Joi.alternatives([\n            Joi.function(),\n            Joi.object().schema()\n        ]).conditional(\"ref\", {\n            is: true,\n            then: Joi.required()\n        }),\n        normalize: Joi.function(),\n        message: Joi.string().when(\"assert\", {\n            is: Joi.function(),\n            then: Joi.required()\n        })\n    })),\n    convert: Joi.boolean(),\n    manifest: Joi.boolean(),\n    method: Joi.function().allow(false),\n    multi: Joi.boolean(),\n    validate: Joi.function()\n});\nexports.extension = Joi.object({\n    type: Joi.alternatives([\n        Joi.string(),\n        Joi.object().regex()\n    ]).required(),\n    args: Joi.function(),\n    cast: Joi.object().pattern(internals.nameRx, Joi.object({\n        from: Joi.function().maxArity(1).required(),\n        to: Joi.function().minArity(1).maxArity(2).required()\n    })),\n    base: Joi.object().schema().when(\"type\", {\n        is: Joi.object().regex(),\n        then: Joi.forbidden()\n    }),\n    coerce: [\n        Joi.function().maxArity(3),\n        Joi.object({\n            method: Joi.function().maxArity(3).required(),\n            from: Joi.array().items(Joi.string()).single()\n        })\n    ],\n    flags: Joi.object().pattern(internals.nameRx, Joi.object({\n        setter: Joi.string(),\n        default: Joi.any()\n    })),\n    manifest: {\n        build: Joi.function().arity(2)\n    },\n    messages: [\n        Joi.object(),\n        Joi.string()\n    ],\n    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),\n    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),\n    prepare: Joi.function().maxArity(3),\n    rebuild: Joi.function().arity(1),\n    rules: Joi.object().pattern(internals.nameRx, internals.rule),\n    terms: Joi.object().pattern(internals.nameRx, Joi.object({\n        init: Joi.array().allow(null).required(),\n        manifest: Joi.object().pattern(/.+/, [\n            Joi.valid(\"schema\", \"single\"),\n            Joi.object({\n                mapped: Joi.object({\n                    from: Joi.string().required(),\n                    to: Joi.string().required()\n                }).required()\n            })\n        ])\n    })),\n    validate: Joi.function().maxArity(3)\n}).strict();\nexports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();\n// Manifest\ninternals.desc = {\n    buffer: Joi.object({\n        buffer: Joi.string()\n    }),\n    func: Joi.object({\n        function: Joi.function().required(),\n        options: {\n            literal: true\n        }\n    }),\n    override: Joi.object({\n        override: true\n    }),\n    ref: Joi.object({\n        ref: Joi.object({\n            type: Joi.valid(\"value\", \"global\", \"local\"),\n            path: Joi.array().required(),\n            separator: Joi.string().length(1).allow(false),\n            ancestor: Joi.number().min(0).integer().allow(\"root\"),\n            map: Joi.array().items(Joi.array().length(2)).min(1),\n            adjust: Joi.function(),\n            iterables: Joi.boolean(),\n            in: Joi.boolean(),\n            render: Joi.boolean()\n        }).required()\n    }),\n    regex: Joi.object({\n        regex: Joi.string().min(3)\n    }),\n    special: Joi.object({\n        special: Joi.valid(\"deep\").required()\n    }),\n    template: Joi.object({\n        template: Joi.string().required(),\n        options: Joi.object()\n    }),\n    value: Joi.object({\n        value: Joi.alternatives([\n            Joi.object(),\n            Joi.array()\n        ]).required()\n    })\n};\ninternals.desc.entity = Joi.alternatives([\n    Joi.array().items(Joi.link(\"...\")),\n    Joi.boolean(),\n    Joi.function(),\n    Joi.number(),\n    Joi.string(),\n    internals.desc.buffer,\n    internals.desc.func,\n    internals.desc.ref,\n    internals.desc.regex,\n    internals.desc.special,\n    internals.desc.template,\n    internals.desc.value,\n    Joi.link(\"/\")\n]);\ninternals.desc.values = Joi.array().items(null, Joi.boolean(), Joi.function(), Joi.number().allow(Infinity, -Infinity), Joi.string().allow(\"\"), Joi.symbol(), internals.desc.buffer, internals.desc.func, internals.desc.override, internals.desc.ref, internals.desc.regex, internals.desc.template, internals.desc.value);\ninternals.desc.messages = Joi.object().pattern(/.+/, [\n    Joi.string(),\n    internals.desc.template,\n    Joi.object().pattern(/.+/, [\n        Joi.string(),\n        internals.desc.template\n    ])\n]);\nexports.description = Joi.object({\n    type: Joi.string().required(),\n    flags: Joi.object({\n        cast: Joi.string(),\n        default: Joi.any(),\n        description: Joi.string(),\n        empty: Joi.link(\"/\"),\n        failover: internals.desc.entity,\n        id: Joi.string(),\n        label: Joi.string(),\n        only: true,\n        presence: [\n            \"optional\",\n            \"required\",\n            \"forbidden\"\n        ],\n        result: [\n            \"raw\",\n            \"strip\"\n        ],\n        strip: Joi.boolean(),\n        unit: Joi.string()\n    }).unknown(),\n    preferences: {\n        allowUnknown: Joi.boolean(),\n        abortEarly: Joi.boolean(),\n        artifacts: Joi.boolean(),\n        cache: Joi.boolean(),\n        convert: Joi.boolean(),\n        dateFormat: [\n            \"date\",\n            \"iso\",\n            \"string\",\n            \"time\",\n            \"utc\"\n        ],\n        errors: {\n            escapeHtml: Joi.boolean(),\n            label: [\n                \"path\",\n                \"key\"\n            ],\n            language: [\n                Joi.string(),\n                internals.desc.ref\n            ],\n            wrap: {\n                label: internals.wrap,\n                array: internals.wrap\n            }\n        },\n        externals: Joi.boolean(),\n        messages: internals.desc.messages,\n        noDefaults: Joi.boolean(),\n        nonEnumerables: Joi.boolean(),\n        presence: [\n            \"required\",\n            \"optional\",\n            \"forbidden\"\n        ],\n        skipFunctions: Joi.boolean(),\n        stripUnknown: Joi.object({\n            arrays: Joi.boolean(),\n            objects: Joi.boolean()\n        }).or(\"arrays\", \"objects\").allow(true, false),\n        warnings: Joi.boolean()\n    },\n    allow: internals.desc.values,\n    invalid: internals.desc.values,\n    rules: Joi.array().min(1).items({\n        name: Joi.string().required(),\n        args: Joi.object().min(1),\n        keep: Joi.boolean(),\n        message: [\n            Joi.string(),\n            internals.desc.messages\n        ],\n        warn: Joi.boolean()\n    }),\n    // Terms\n    keys: Joi.object().pattern(/.*/, Joi.link(\"/\")),\n    link: internals.desc.ref\n}).pattern(/^[a-z]\\w*$/, Joi.any());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU9yRixJQUFJNEIsS0FBSyxHQUFHdkIsR0FBRyxDQUFDLEdBQUd1QyxLQUFLLENBQUM7UUFDNUJJLE1BQU1oRCxJQUFJSSxNQUFNLEdBQUc2QyxRQUFRO1FBQzNCRixNQUFNL0MsSUFBSVUsTUFBTSxHQUFHTCxHQUFHLENBQUM7UUFDdkJ1SCxNQUFNNUgsSUFBSVksT0FBTztRQUNqQjhDLFNBQVM7WUFDTDFELElBQUlJLE1BQU07WUFDVkYsVUFBVXdGLElBQUksQ0FBQzVELFFBQVE7U0FDMUI7UUFDRCtGLE1BQU03SCxJQUFJWSxPQUFPO0lBQ3JCO0lBRUEsUUFBUTtJQUVSa0gsTUFBTTlILElBQUlVLE1BQU0sR0FBR21DLE9BQU8sQ0FBQyxNQUFNN0MsSUFBSThHLElBQUksQ0FBQztJQUMxQ0EsTUFBTTVHLFVBQVV3RixJQUFJLENBQUNqRSxHQUFHO0FBQzVCLEdBQ0tvQixPQUFPLENBQUMsY0FBYzdDLElBQUk4RSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi9zY2hlbWFzLmpzPzVjMGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKb2kgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLy8gUHJlZmVyZW5jZXNcblxuaW50ZXJuYWxzLndyYXAgPSBKb2kuc3RyaW5nKClcbiAgICAubWluKDEpXG4gICAgLm1heCgyKVxuICAgIC5hbGxvdyhmYWxzZSk7XG5cblxuZXhwb3J0cy5wcmVmZXJlbmNlcyA9IEpvaS5vYmplY3Qoe1xuICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgIGFydGlmYWN0czogSm9pLmJvb2xlYW4oKSxcbiAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICBjb250ZXh0OiBKb2kub2JqZWN0KCksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBkYXRlRm9ybWF0OiBKb2kudmFsaWQoJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YycpLFxuICAgIGRlYnVnOiBKb2kuYm9vbGVhbigpLFxuICAgIGVycm9yczoge1xuICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBsYWJlbDogSm9pLnZhbGlkKCdwYXRoJywgJ2tleScsIGZhbHNlKSxcbiAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3QoKS5yZWYoKVxuICAgICAgICBdLFxuICAgICAgICByZW5kZXI6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0YWNrOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB3cmFwOiB7XG4gICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBhcnJheTogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICBzdHJpbmc6IGludGVybmFscy53cmFwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICBtZXNzYWdlczogSm9pLm9iamVjdCgpLFxuICAgIG5vRGVmYXVsdHM6IEpvaS5ib29sZWFuKCksXG4gICAgbm9uRW51bWVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgcHJlc2VuY2U6IEpvaS52YWxpZCgncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJyksXG4gICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICBzdHJpcFVua25vd246IEpvaS5vYmplY3Qoe1xuICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG9iamVjdHM6IEpvaS5ib29sZWFuKClcbiAgICB9KVxuICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgLmFsbG93KHRydWUsIGZhbHNlKSxcbiAgICB3YXJuaW5nczogSm9pLmJvb2xlYW4oKVxufSlcbiAgICAuc3RyaWN0KCk7XG5cblxuLy8gRXh0ZW5zaW9uc1xuXG5pbnRlcm5hbHMubmFtZVJ4ID0gL15bYS16QS1aMC05XVxcdyokLztcblxuXG5pbnRlcm5hbHMucnVsZSA9IEpvaS5vYmplY3Qoe1xuICAgIGFsaWFzOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4KSkuc2luZ2xlKCksXG4gICAgYXJnczogSm9pLmFycmF5KCkuaXRlbXMoXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4KS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgcmVmOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgYXNzZXJ0OiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBKb2kub2JqZWN0KCkuc2NoZW1hKClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLmNvbmRpdGlvbmFsKCdyZWYnLCB7IGlzOiB0cnVlLCB0aGVuOiBKb2kucmVxdWlyZWQoKSB9KSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZTogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBKb2kuc3RyaW5nKCkud2hlbignYXNzZXJ0JywgeyBpczogSm9pLmZ1bmN0aW9uKCksIHRoZW46IEpvaS5yZXF1aXJlZCgpIH0pXG4gICAgICAgIH0pXG4gICAgKSxcbiAgICBjb252ZXJ0OiBKb2kuYm9vbGVhbigpLFxuICAgIG1hbmlmZXN0OiBKb2kuYm9vbGVhbigpLFxuICAgIG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkuYWxsb3coZmFsc2UpLFxuICAgIG11bHRpOiBKb2kuYm9vbGVhbigpLFxuICAgIHZhbGlkYXRlOiBKb2kuZnVuY3Rpb24oKVxufSk7XG5cblxuZXhwb3J0cy5leHRlbnNpb24gPSBKb2kub2JqZWN0KHtcbiAgICB0eXBlOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KCkucmVnZXgoKVxuICAgIF0pXG4gICAgICAgIC5yZXF1aXJlZCgpLFxuICAgIGFyZ3M6IEpvaS5mdW5jdGlvbigpLFxuICAgIGNhc3Q6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBmcm9tOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgxKS5yZXF1aXJlZCgpLFxuICAgICAgICB0bzogSm9pLmZ1bmN0aW9uKCkubWluQXJpdHkoMSkubWF4QXJpdHkoMikucmVxdWlyZWQoKVxuICAgIH0pKSxcbiAgICBiYXNlOiBKb2kub2JqZWN0KCkuc2NoZW1hKClcbiAgICAgICAgLndoZW4oJ3R5cGUnLCB7IGlzOiBKb2kub2JqZWN0KCkucmVnZXgoKSwgdGhlbjogSm9pLmZvcmJpZGRlbigpIH0pLFxuICAgIGNvZXJjZTogW1xuICAgICAgICBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICAgICAgSm9pLm9iamVjdCh7IG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMykucmVxdWlyZWQoKSwgZnJvbTogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKSB9KVxuICAgIF0sXG4gICAgZmxhZ3M6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBzZXR0ZXI6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpXG4gICAgfSkpLFxuICAgIG1hbmlmZXN0OiB7XG4gICAgICAgIGJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgyKVxuICAgIH0sXG4gICAgbWVzc2FnZXM6IFtKb2kub2JqZWN0KCksIEpvaS5zdHJpbmcoKV0sXG4gICAgbW9kaWZpZXJzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKS5taW5Bcml0eSgxKS5tYXhBcml0eSgyKSksXG4gICAgb3ZlcnJpZGVzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKSksXG4gICAgcHJlcGFyZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMyksXG4gICAgcmVidWlsZDogSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSksXG4gICAgcnVsZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIGludGVybmFscy5ydWxlKSxcbiAgICB0ZXJtczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIGluaXQ6IEpvaS5hcnJheSgpLmFsbG93KG51bGwpLnJlcXVpcmVkKCksXG4gICAgICAgIG1hbmlmZXN0OiBKb2kub2JqZWN0KCkucGF0dGVybigvLisvLCBbXG4gICAgICAgICAgICBKb2kudmFsaWQoJ3NjaGVtYScsICdzaW5nbGUnKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG1hcHBlZDogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgICAgICAgICB0bzogSm9pLnN0cmluZygpLnJlcXVpcmVkKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICB9KSksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbnMgPSBKb2kuYXJyYXkoKS5pdGVtcyhKb2kub2JqZWN0KCksIEpvaS5mdW5jdGlvbigpLmFyaXR5KDEpKS5zdHJpY3QoKTtcblxuXG4vLyBNYW5pZmVzdFxuXG5pbnRlcm5hbHMuZGVzYyA9IHtcblxuICAgIGJ1ZmZlcjogSm9pLm9iamVjdCh7XG4gICAgICAgIGJ1ZmZlcjogSm9pLnN0cmluZygpXG4gICAgfSksXG5cbiAgICBmdW5jOiBKb2kub2JqZWN0KHtcbiAgICAgICAgZnVuY3Rpb246IEpvaS5mdW5jdGlvbigpLnJlcXVpcmVkKCksXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pLFxuXG4gICAgb3ZlcnJpZGU6IEpvaS5vYmplY3Qoe1xuICAgICAgICBvdmVycmlkZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IEpvaS52YWxpZCgndmFsdWUnLCAnZ2xvYmFsJywgJ2xvY2FsJyksXG4gICAgICAgICAgICBwYXRoOiBKb2kuYXJyYXkoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgc2VwYXJhdG9yOiBKb2kuc3RyaW5nKCkubGVuZ3RoKDEpLmFsbG93KGZhbHNlKSxcbiAgICAgICAgICAgIGFuY2VzdG9yOiBKb2kubnVtYmVyKCkubWluKDApLmludGVnZXIoKS5hbGxvdygncm9vdCcpLFxuICAgICAgICAgICAgbWFwOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuYXJyYXkoKS5sZW5ndGgoMikpLm1pbigxKSxcbiAgICAgICAgICAgIGFkanVzdDogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBpdGVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBpbjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIHJlbmRlcjogSm9pLmJvb2xlYW4oKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHJlZ2V4OiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVnZXg6IEpvaS5zdHJpbmcoKS5taW4oMylcbiAgICB9KSxcblxuICAgIHNwZWNpYWw6IEpvaS5vYmplY3Qoe1xuICAgICAgICBzcGVjaWFsOiBKb2kudmFsaWQoJ2RlZXAnKS5yZXF1aXJlZCgpXG4gICAgfSksXG5cbiAgICB0ZW1wbGF0ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHRlbXBsYXRlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczogSm9pLm9iamVjdCgpXG4gICAgfSksXG5cbiAgICB2YWx1ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHZhbHVlOiBKb2kuYWx0ZXJuYXRpdmVzKFtKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpXSkucmVxdWlyZWQoKVxuICAgIH0pXG59O1xuXG5cbmludGVybmFscy5kZXNjLmVudGl0eSA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5saW5rKCcuLi4nKSksXG4gICAgSm9pLmJvb2xlYW4oKSxcbiAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICBKb2kubnVtYmVyKCksXG4gICAgSm9pLnN0cmluZygpLFxuICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICBpbnRlcm5hbHMuZGVzYy5zcGVjaWFsLFxuICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgIGludGVybmFscy5kZXNjLnZhbHVlLFxuICAgIEpvaS5saW5rKCcvJylcbl0pO1xuXG5cbmludGVybmFscy5kZXNjLnZhbHVlcyA9IEpvaS5hcnJheSgpXG4gICAgLml0ZW1zKFxuICAgICAgICBudWxsLFxuICAgICAgICBKb2kuYm9vbGVhbigpLFxuICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgSm9pLm51bWJlcigpLmFsbG93KEluZmluaXR5LCAtSW5maW5pdHkpLFxuICAgICAgICBKb2kuc3RyaW5nKCkuYWxsb3coJycpLFxuICAgICAgICBKb2kuc3ltYm9sKCksXG4gICAgICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuZnVuYyxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2Mub3ZlcnJpZGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVnZXgsXG4gICAgICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy52YWx1ZVxuICAgICk7XG5cblxuaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMgPSBKb2kub2JqZWN0KClcbiAgICAucGF0dGVybigvLisvLCBbXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtKb2kuc3RyaW5nKCksIGludGVybmFscy5kZXNjLnRlbXBsYXRlXSlcbiAgICBdKTtcblxuXG5leHBvcnRzLmRlc2NyaXB0aW9uID0gSm9pLm9iamVjdCh7XG4gICAgdHlwZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgZmxhZ3M6IEpvaS5vYmplY3Qoe1xuICAgICAgICBjYXN0OiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGRlZmF1bHQ6IEpvaS5hbnkoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZW1wdHk6IEpvaS5saW5rKCcvJyksXG4gICAgICAgIGZhaWxvdmVyOiBpbnRlcm5hbHMuZGVzYy5lbnRpdHksXG4gICAgICAgIGlkOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGxhYmVsOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIG9ubHk6IHRydWUsXG4gICAgICAgIHByZXNlbmNlOiBbJ29wdGlvbmFsJywgJ3JlcXVpcmVkJywgJ2ZvcmJpZGRlbiddLFxuICAgICAgICByZXN1bHQ6IFsncmF3JywgJ3N0cmlwJ10sXG4gICAgICAgIHN0cmlwOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB1bml0OiBKb2kuc3RyaW5nKClcbiAgICB9KVxuICAgICAgICAudW5rbm93bigpLFxuICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYWJvcnRFYXJseTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYXJ0aWZhY3RzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgZGF0ZUZvcm1hdDogWydkYXRlJywgJ2lzbycsICdzdHJpbmcnLCAndGltZScsICd1dGMnXSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgbGFiZWw6IFsncGF0aCcsICdrZXknXSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBbXG4gICAgICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGludGVybmFscy5kZXNjLnJlZlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHdyYXA6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogaW50ZXJuYWxzLndyYXAsXG4gICAgICAgICAgICAgICAgYXJyYXk6IGludGVybmFscy53cmFwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZXM6IGludGVybmFscy5kZXNjLm1lc3NhZ2VzLFxuICAgICAgICBub0RlZmF1bHRzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgcHJlc2VuY2U6IFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHNraXBGdW5jdGlvbnM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBvYmplY3RzOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgICAgIC5hbGxvdyh0cnVlLCBmYWxzZSksXG4gICAgICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG4gICAgfSxcbiAgICBhbGxvdzogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIGludmFsaWQ6IGludGVybmFscy5kZXNjLnZhbHVlcyxcbiAgICBydWxlczogSm9pLmFycmF5KCkubWluKDEpLml0ZW1zKHtcbiAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgIGFyZ3M6IEpvaS5vYmplY3QoKS5taW4oMSksXG4gICAgICAgIGtlZXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGludGVybmFscy5kZXNjLm1lc3NhZ2VzXG4gICAgICAgIF0sXG4gICAgICAgIHdhcm46IEpvaS5ib29sZWFuKClcbiAgICB9KSxcblxuICAgIC8vIFRlcm1zXG5cbiAgICBrZXlzOiBKb2kub2JqZWN0KCkucGF0dGVybigvLiovLCBKb2kubGluaygnLycpKSxcbiAgICBsaW5rOiBpbnRlcm5hbHMuZGVzYy5yZWZcbn0pXG4gICAgLnBhdHRlcm4oL15bYS16XVxcdyokLywgSm9pLmFueSgpKTtcbiJdLCJuYW1lcyI6WyJKb2kiLCJyZXF1aXJlIiwiaW50ZXJuYWxzIiwid3JhcCIsInN0cmluZyIsIm1pbiIsIm1heCIsImFsbG93IiwiZXhwb3J0cyIsInByZWZlcmVuY2VzIiwib2JqZWN0IiwiYWxsb3dVbmtub3duIiwiYm9vbGVhbiIsImFib3J0RWFybHkiLCJhcnRpZmFjdHMiLCJjYWNoZSIsImNvbnRleHQiLCJjb252ZXJ0IiwiZGF0ZUZvcm1hdCIsInZhbGlkIiwiZGVidWciLCJlcnJvcnMiLCJlc2NhcGVIdG1sIiwibGFiZWwiLCJsYW5ndWFnZSIsInJlZiIsInJlbmRlciIsInN0YWNrIiwiYXJyYXkiLCJleHRlcm5hbHMiLCJtZXNzYWdlcyIsIm5vRGVmYXVsdHMiLCJub25FbnVtZXJhYmxlcyIsInByZXNlbmNlIiwic2tpcEZ1bmN0aW9ucyIsInN0cmlwVW5rbm93biIsImFycmF5cyIsIm9iamVjdHMiLCJvciIsIndhcm5pbmdzIiwic3RyaWN0IiwibmFtZVJ4IiwicnVsZSIsImFsaWFzIiwiaXRlbXMiLCJwYXR0ZXJuIiwic2luZ2xlIiwiYXJncyIsIm5hbWUiLCJyZXF1aXJlZCIsImFzc2VydCIsImFsdGVybmF0aXZlcyIsImZ1bmN0aW9uIiwic2NoZW1hIiwiY29uZGl0aW9uYWwiLCJpcyIsInRoZW4iLCJub3JtYWxpemUiLCJtZXNzYWdlIiwid2hlbiIsIm1hbmlmZXN0IiwibWV0aG9kIiwibXVsdGkiLCJ2YWxpZGF0ZSIsImV4dGVuc2lvbiIsInR5cGUiLCJyZWdleCIsImNhc3QiLCJmcm9tIiwibWF4QXJpdHkiLCJ0byIsIm1pbkFyaXR5IiwiYmFzZSIsImZvcmJpZGRlbiIsImNvZXJjZSIsImZsYWdzIiwic2V0dGVyIiwiZGVmYXVsdCIsImFueSIsImJ1aWxkIiwiYXJpdHkiLCJtb2RpZmllcnMiLCJvdmVycmlkZXMiLCJwcmVwYXJlIiwicmVidWlsZCIsInJ1bGVzIiwidGVybXMiLCJpbml0IiwibWFwcGVkIiwiZXh0ZW5zaW9ucyIsImRlc2MiLCJidWZmZXIiLCJmdW5jIiwib3B0aW9ucyIsImxpdGVyYWwiLCJvdmVycmlkZSIsInBhdGgiLCJzZXBhcmF0b3IiLCJsZW5ndGgiLCJhbmNlc3RvciIsIm51bWJlciIsImludGVnZXIiLCJtYXAiLCJhZGp1c3QiLCJpdGVyYWJsZXMiLCJpbiIsInNwZWNpYWwiLCJ0ZW1wbGF0ZSIsInZhbHVlIiwiZW50aXR5IiwibGluayIsInZhbHVlcyIsIkluZmluaXR5Iiwic3ltYm9sIiwiZGVzY3JpcHRpb24iLCJlbXB0eSIsImZhaWxvdmVyIiwiaWQiLCJvbmx5IiwicmVzdWx0Iiwic3RyaXAiLCJ1bml0IiwidW5rbm93biIsImludmFsaWQiLCJrZWVwIiwid2FybiIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/state.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/state.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"(rsc)/./node_modules/@hapi/hoek/lib/reach.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst internals = {\n    value: Symbol(\"value\")\n};\nmodule.exports = internals.State = class {\n    constructor(path, ancestors, state){\n        this.path = path;\n        this.ancestors = ancestors; // [parent, ..., root]\n        this.mainstay = state.mainstay;\n        this.schemas = state.schemas; // [current, ..., root]\n        this.debug = null;\n    }\n    localize(path, ancestors = null, schema = null) {\n        const state = new internals.State(path, ancestors, this);\n        if (schema && state.schemas) {\n            state.schemas = [\n                internals.schemas(schema),\n                ...state.schemas\n            ];\n        }\n        return state;\n    }\n    nest(schema, debug) {\n        const state = new internals.State(this.path, this.ancestors, this);\n        state.schemas = state.schemas && [\n            internals.schemas(schema),\n            ...state.schemas\n        ];\n        state.debug = debug;\n        return state;\n    }\n    shadow(value, reason) {\n        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();\n        this.mainstay.shadow.set(this.path, value, reason);\n    }\n    snapshot() {\n        if (this.mainstay.shadow) {\n            this._snapshot = Clone(this.mainstay.shadow.node(this.path));\n        }\n        this.mainstay.snapshot();\n    }\n    restore() {\n        if (this.mainstay.shadow) {\n            this.mainstay.shadow.override(this.path, this._snapshot);\n            this._snapshot = undefined;\n        }\n        this.mainstay.restore();\n    }\n    commit() {\n        if (this.mainstay.shadow) {\n            this.mainstay.shadow.override(this.path, this._snapshot);\n            this._snapshot = undefined;\n        }\n        this.mainstay.commit();\n    }\n};\ninternals.schemas = function(schema) {\n    if (Common.isSchema(schema)) {\n        return {\n            schema\n        };\n    }\n    return schema;\n};\ninternals.Shadow = class {\n    constructor(){\n        this._values = null;\n    }\n    set(path, value, reason) {\n        if (!path.length) {\n            return;\n        }\n        if (reason === \"strip\" && typeof path[path.length - 1] === \"number\") {\n            return;\n        }\n        this._values = this._values || new Map();\n        let node = this._values;\n        for(let i = 0; i < path.length; ++i){\n            const segment = path[i];\n            let next = node.get(segment);\n            if (!next) {\n                next = new Map();\n                node.set(segment, next);\n            }\n            node = next;\n        }\n        node[internals.value] = value;\n    }\n    get(path) {\n        const node = this.node(path);\n        if (node) {\n            return node[internals.value];\n        }\n    }\n    node(path) {\n        if (!this._values) {\n            return;\n        }\n        return Reach(this._values, path, {\n            iterables: true\n        });\n    }\n    override(path, node) {\n        if (!this._values) {\n            return;\n        }\n        const parents = path.slice(0, -1);\n        const own = path[path.length - 1];\n        const parent = Reach(this._values, parents, {\n            iterables: true\n        });\n        if (node) {\n            parent.set(own, node);\n            return;\n        }\n        if (parent) {\n            parent.delete(own);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxPQUFPOUIsTUFBTSxJQUFJLENBQUM4QixPQUFPLEVBQUVyQixNQUFNO1lBQUU0QixXQUFXO1FBQUs7SUFDdkQ7SUFFQVgsU0FBU2pCLElBQUksRUFBRWUsSUFBSSxFQUFFO1FBRWpCLElBQUksQ0FBQyxJQUFJLENBQUNNLE9BQU8sRUFBRTtZQUNmO1FBQ0o7UUFFQSxNQUFNUSxVQUFVN0IsS0FBSzhCLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDL0IsTUFBTUMsTUFBTS9CLElBQUksQ0FBQ0EsS0FBS3NCLE1BQU0sR0FBRyxFQUFFO1FBQ2pDLE1BQU1VLFNBQVN6QyxNQUFNLElBQUksQ0FBQzhCLE9BQU8sRUFBRVEsU0FBUztZQUFFRCxXQUFXO1FBQUs7UUFFOUQsSUFBSWIsTUFBTTtZQUNOaUIsT0FBT3BCLEdBQUcsQ0FBQ21CLEtBQUtoQjtZQUNoQjtRQUNKO1FBRUEsSUFBSWlCLFFBQVE7WUFDUkEsT0FBT0MsTUFBTSxDQUFDRjtRQUNsQjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3N0YXRlLmpzP2QwNmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHZhbHVlOiBTeW1ib2woJ3ZhbHVlJylcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuU3RhdGUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBhbmNlc3RvcnMsIHN0YXRlKSB7XG5cbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5hbmNlc3RvcnMgPSBhbmNlc3RvcnM7ICAgICAgICAgICAgICAgICAvLyBbcGFyZW50LCAuLi4sIHJvb3RdXG5cbiAgICAgICAgdGhpcy5tYWluc3RheSA9IHN0YXRlLm1haW5zdGF5O1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSBzdGF0ZS5zY2hlbWFzOyAgICAgICAgICAgICAgIC8vIFtjdXJyZW50LCAuLi4sIHJvb3RdXG4gICAgICAgIHRoaXMuZGVidWcgPSBudWxsO1xuICAgIH1cblxuICAgIGxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycyA9IG51bGwsIHNjaGVtYSA9IG51bGwpIHtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IG5ldyBpbnRlcm5hbHMuU3RhdGUocGF0aCwgYW5jZXN0b3JzLCB0aGlzKTtcblxuICAgICAgICBpZiAoc2NoZW1hICYmXG4gICAgICAgICAgICBzdGF0ZS5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgIHN0YXRlLnNjaGVtYXMgPSBbaW50ZXJuYWxzLnNjaGVtYXMoc2NoZW1hKSwgLi4uc3RhdGUuc2NoZW1hc107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgbmVzdChzY2hlbWEsIGRlYnVnKSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgaW50ZXJuYWxzLlN0YXRlKHRoaXMucGF0aCwgdGhpcy5hbmNlc3RvcnMsIHRoaXMpO1xuICAgICAgICBzdGF0ZS5zY2hlbWFzID0gc3RhdGUuc2NoZW1hcyAmJiBbaW50ZXJuYWxzLnNjaGVtYXMoc2NoZW1hKSwgLi4uc3RhdGUuc2NoZW1hc107XG4gICAgICAgIHN0YXRlLmRlYnVnID0gZGVidWc7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBzaGFkb3codmFsdWUsIHJlYXNvbikge1xuXG4gICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93ID0gdGhpcy5tYWluc3RheS5zaGFkb3cgfHwgbmV3IGludGVybmFscy5TaGFkb3coKTtcbiAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cuc2V0KHRoaXMucGF0aCwgdmFsdWUsIHJlYXNvbik7XG4gICAgfVxuXG4gICAgc25hcHNob3QoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWFpbnN0YXkuc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IENsb25lKHRoaXMubWFpbnN0YXkuc2hhZG93Lm5vZGUodGhpcy5wYXRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1haW5zdGF5LnNuYXBzaG90KCk7XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcblxuICAgICAgICBpZiAodGhpcy5tYWluc3RheS5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93Lm92ZXJyaWRlKHRoaXMucGF0aCwgdGhpcy5fc25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1haW5zdGF5LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBjb21taXQoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWFpbnN0YXkuc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdy5vdmVycmlkZSh0aGlzLnBhdGgsIHRoaXMuX3NuYXBzaG90KTtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWluc3RheS5jb21taXQoKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWFzID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYSB9O1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5TaGFkb3cgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHNldChwYXRoLCB2YWx1ZSwgcmVhc29uKSB7XG5cbiAgICAgICAgaWYgKCFwYXRoLmxlbmd0aCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHN0b3JlIHJvb3QgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFzb24gPT09ICdzdHJpcCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7ICAgICAgICAvLyBDYW5ub3Qgc3RvcmUgc3RyaXBwZWQgYXJyYXkgdmFsdWVzIChkdWUgdG8gc2hpZnQpXG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuX3ZhbHVlcyB8fCBuZXcgTWFwKCk7XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHBhdGhbaV07XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuZ2V0KHNlZ21lbnQpO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldChzZWdtZW50LCBuZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlW2ludGVybmFscy52YWx1ZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQocGF0aCkge1xuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGUocGF0aCk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtpbnRlcm5hbHMudmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm9kZShwYXRoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjaCh0aGlzLl92YWx1ZXMsIHBhdGgsIHsgaXRlcmFibGVzOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIG92ZXJyaWRlKHBhdGgsIG5vZGUpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgICBjb25zdCBvd24gPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IFJlYWNoKHRoaXMuX3ZhbHVlcywgcGFyZW50cywgeyBpdGVyYWJsZXM6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudC5zZXQob3duLCBub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5kZWxldGUob3duKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiQ2xvbmUiLCJyZXF1aXJlIiwiUmVhY2giLCJDb21tb24iLCJpbnRlcm5hbHMiLCJ2YWx1ZSIsIlN5bWJvbCIsIm1vZHVsZSIsImV4cG9ydHMiLCJTdGF0ZSIsImNvbnN0cnVjdG9yIiwicGF0aCIsImFuY2VzdG9ycyIsInN0YXRlIiwibWFpbnN0YXkiLCJzY2hlbWFzIiwiZGVidWciLCJsb2NhbGl6ZSIsInNjaGVtYSIsIm5lc3QiLCJzaGFkb3ciLCJyZWFzb24iLCJTaGFkb3ciLCJzZXQiLCJzbmFwc2hvdCIsIl9zbmFwc2hvdCIsIm5vZGUiLCJyZXN0b3JlIiwib3ZlcnJpZGUiLCJ1bmRlZmluZWQiLCJjb21taXQiLCJpc1NjaGVtYSIsIl92YWx1ZXMiLCJsZW5ndGgiLCJNYXAiLCJpIiwic2VnbWVudCIsIm5leHQiLCJnZXQiLCJpdGVyYWJsZXMiLCJwYXJlbnRzIiwic2xpY2UiLCJvd24iLCJwYXJlbnQiLCJkZWxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/template.js":
/*!******************************************!*\
  !*** ./node_modules/joi/lib/template.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst EscapeHtml = __webpack_require__(/*! @hapi/hoek/lib/escapeHtml */ \"(rsc)/./node_modules/@hapi/hoek/lib/escapeHtml.js\");\nconst Formula = __webpack_require__(/*! @sideway/formula */ \"(rsc)/./node_modules/@sideway/formula/lib/index.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ./ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst internals = {\n    symbol: Symbol(\"template\"),\n    opens: new Array(1000).join(\"\\x00\"),\n    closes: new Array(1000).join(\"\\x01\"),\n    dateFormat: {\n        date: Date.prototype.toDateString,\n        iso: Date.prototype.toISOString,\n        string: Date.prototype.toString,\n        time: Date.prototype.toTimeString,\n        utc: Date.prototype.toUTCString\n    }\n};\nmodule.exports = exports = internals.Template = class {\n    constructor(source, options){\n        Assert(typeof source === \"string\", \"Template source must be a string\");\n        Assert(!source.includes(\"\\x00\") && !source.includes(\"\\x01\"), \"Template source cannot contain reserved control characters\");\n        this.source = source;\n        this.rendered = source;\n        this._template = null;\n        if (options) {\n            const { functions, ...opts } = options;\n            this._settings = Object.keys(opts).length ? Clone(opts) : undefined;\n            this._functions = functions;\n            if (this._functions) {\n                Assert(Object.keys(this._functions).every((key)=>typeof key === \"string\"), \"Functions keys must be strings\");\n                Assert(Object.values(this._functions).every((key)=>typeof key === \"function\"), \"Functions values must be functions\");\n            }\n        } else {\n            this._settings = undefined;\n            this._functions = undefined;\n        }\n        this._parse();\n    }\n    _parse() {\n        // 'text {raw} {{ref}} \\\\{{ignore}} {{ignore\\\\}} {{ignore {{ignore}'\n        if (!this.source.includes(\"{\")) {\n            return;\n        }\n        // Encode escaped \\\\{{{{{\n        const encoded = internals.encode(this.source);\n        // Split on first { in each set\n        const parts = internals.split(encoded);\n        // Process parts\n        let refs = false;\n        const processed = [];\n        const head = parts.shift();\n        if (head) {\n            processed.push(head);\n        }\n        for (const part of parts){\n            const raw = part[0] !== \"{\";\n            const ender = raw ? \"}\" : \"}}\";\n            const end = part.indexOf(ender);\n            if (end === -1 || // Ignore non-matching closing\n            part[1] === \"{\") {\n                processed.push(`{${internals.decode(part)}`);\n                continue;\n            }\n            let variable = part.slice(raw ? 0 : 1, end);\n            const wrapped = variable[0] === \":\";\n            if (wrapped) {\n                variable = variable.slice(1);\n            }\n            const dynamic = this._ref(internals.decode(variable), {\n                raw,\n                wrapped\n            });\n            processed.push(dynamic);\n            if (typeof dynamic !== \"string\") {\n                refs = true;\n            }\n            const rest = part.slice(end + ender.length);\n            if (rest) {\n                processed.push(internals.decode(rest));\n            }\n        }\n        if (!refs) {\n            this.rendered = processed.join(\"\");\n            return;\n        }\n        this._template = processed;\n    }\n    static date(date, prefs) {\n        return internals.dateFormat[prefs.dateFormat].call(date);\n    }\n    describe(options = {}) {\n        if (!this._settings && options.compact) {\n            return this.source;\n        }\n        const desc = {\n            template: this.source\n        };\n        if (this._settings) {\n            desc.options = this._settings;\n        }\n        if (this._functions) {\n            desc.functions = this._functions;\n        }\n        return desc;\n    }\n    static build(desc) {\n        return new internals.Template(desc.template, desc.options || desc.functions ? {\n            ...desc.options,\n            functions: desc.functions\n        } : undefined);\n    }\n    isDynamic() {\n        return !!this._template;\n    }\n    static isTemplate(template) {\n        return template ? !!template[Common.symbols.template] : false;\n    }\n    refs() {\n        if (!this._template) {\n            return;\n        }\n        const refs = [];\n        for (const part of this._template){\n            if (typeof part !== \"string\") {\n                refs.push(...part.refs);\n            }\n        }\n        return refs;\n    }\n    resolve(value, state, prefs, local) {\n        if (this._template && this._template.length === 1) {\n            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */ );\n        }\n        return this.render(value, state, prefs, local);\n    }\n    _part(part, ...args) {\n        if (part.ref) {\n            return part.ref.resolve(...args);\n        }\n        return part.formula.evaluate(args);\n    }\n    render(value, state, prefs, local, options = {}) {\n        if (!this.isDynamic()) {\n            return this.rendered;\n        }\n        const parts = [];\n        for (const part of this._template){\n            if (typeof part === \"string\") {\n                parts.push(part);\n            } else {\n                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */ );\n                const string = internals.stringify(rendered, value, state, prefs, local, options);\n                if (string !== undefined) {\n                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);\n                    parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));\n                }\n            }\n        }\n        return parts.join(\"\");\n    }\n    _ref(content, { raw, wrapped }) {\n        const refs = [];\n        const reference = (variable)=>{\n            const ref = Ref.create(variable, this._settings);\n            refs.push(ref);\n            return (context)=>{\n                const resolved = ref.resolve(...context);\n                return resolved !== undefined ? resolved : null;\n            };\n        };\n        try {\n            const functions = this._functions ? {\n                ...internals.functions,\n                ...this._functions\n            } : internals.functions;\n            var formula = new Formula.Parser(content, {\n                reference,\n                functions,\n                constants: internals.constants\n            });\n        } catch (err) {\n            err.message = `Invalid template variable \"${content}\" fails due to: ${err.message}`;\n            throw err;\n        }\n        if (formula.single) {\n            if (formula.single.type === \"reference\") {\n                const ref = refs[0];\n                return {\n                    ref,\n                    raw,\n                    refs,\n                    wrapped: wrapped || ref.type === \"local\" && ref.key === \"label\"\n                };\n            }\n            return internals.stringify(formula.single.value);\n        }\n        return {\n            formula,\n            raw,\n            refs\n        };\n    }\n    toString() {\n        return this.source;\n    }\n};\ninternals.Template.prototype[Common.symbols.template] = true;\ninternals.Template.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\ninternals.encode = function(string) {\n    return string.replace(/\\\\(\\{+)/g, ($0, $1)=>{\n        return internals.opens.slice(0, $1.length);\n    }).replace(/\\\\(\\}+)/g, ($0, $1)=>{\n        return internals.closes.slice(0, $1.length);\n    });\n};\ninternals.decode = function(string) {\n    return string.replace(/\\u0000/g, \"{\").replace(/\\u0001/g, \"}\");\n};\ninternals.split = function(string) {\n    const parts = [];\n    let current = \"\";\n    for(let i = 0; i < string.length; ++i){\n        const char = string[i];\n        if (char === \"{\") {\n            let next = \"\";\n            while(i + 1 < string.length && string[i + 1] === \"{\"){\n                next += \"{\";\n                ++i;\n            }\n            parts.push(current);\n            current = next;\n        } else {\n            current += char;\n        }\n    }\n    parts.push(current);\n    return parts;\n};\ninternals.wrap = function(value, ends) {\n    if (!ends) {\n        return value;\n    }\n    if (ends.length === 1) {\n        return `${ends}${value}${ends}`;\n    }\n    return `${ends[0]}${value}${ends[1]}`;\n};\ninternals.stringify = function(value, original, state, prefs, local, options = {}) {\n    const type = typeof value;\n    const wrap = prefs && prefs.errors && prefs.errors.wrap || {};\n    let skipWrap = false;\n    if (Ref.isRef(value) && value.render) {\n        skipWrap = value.in;\n        value = value.resolve(original, state, prefs, local, {\n            in: value.in,\n            ...options\n        });\n    }\n    if (value === null) {\n        return \"null\";\n    }\n    if (type === \"string\") {\n        return internals.wrap(value, options.arrayItems && wrap.string);\n    }\n    if (type === \"number\" || type === \"function\" || type === \"symbol\") {\n        return value.toString();\n    }\n    if (type !== \"object\") {\n        return JSON.stringify(value);\n    }\n    if (value instanceof Date) {\n        return internals.Template.date(value, prefs);\n    }\n    if (value instanceof Map) {\n        const pairs = [];\n        for (const [key, sym] of value.entries()){\n            pairs.push(`${key.toString()} -> ${sym.toString()}`);\n        }\n        value = pairs;\n    }\n    if (!Array.isArray(value)) {\n        return value.toString();\n    }\n    const values = [];\n    for (const item of value){\n        values.push(internals.stringify(item, original, state, prefs, local, {\n            arrayItems: true,\n            ...options\n        }));\n    }\n    return internals.wrap(values.join(\", \"), !skipWrap && wrap.array);\n};\ninternals.constants = {\n    true: true,\n    false: false,\n    null: null,\n    second: 1000,\n    minute: 60 * 1000,\n    hour: 60 * 60 * 1000,\n    day: 24 * 60 * 60 * 1000\n};\ninternals.functions = {\n    if (condition, then, otherwise) {\n        return condition ? then : otherwise;\n    },\n    length (item) {\n        if (typeof item === \"string\") {\n            return item.length;\n        }\n        if (!item || typeof item !== \"object\") {\n            return null;\n        }\n        if (Array.isArray(item)) {\n            return item.length;\n        }\n        return Object.keys(item).length;\n    },\n    msg (code) {\n        const [value, state, prefs, local, options] = this;\n        const messages = options.messages;\n        if (!messages) {\n            return \"\";\n        }\n        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);\n        if (!template) {\n            return \"\";\n        }\n        return template.render(value, state, prefs, local, options);\n    },\n    number (value) {\n        if (typeof value === \"number\") {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            return parseFloat(value);\n        }\n        if (typeof value === \"boolean\") {\n            return value ? 1 : 0;\n        }\n        if (value instanceof Date) {\n            return value.getTime();\n        }\n        return null;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90ZW1wbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDO0FBRXhCLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1LLFNBQVNMLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1NLE1BQU1OLG1CQUFPQSxDQUFDO0FBR3BCLE1BQU1PLFlBQVk7SUFDZEMsUUFBUUMsT0FBTztJQUVmQyxPQUFPLElBQUlDLE1BQU0sTUFBTUMsSUFBSSxDQUFDO0lBQzVCQyxRQUFRLElBQUlGLE1BQU0sTUFBTUMsSUFBSSxDQUFDO0lBRTdCRSxZQUFZO1FBQ1JDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0MsWUFBWTtRQUNqQ0MsS0FBS0gsS0FBS0MsU0FBUyxDQUFDRyxXQUFXO1FBQy9CQyxRQUFRTCxLQUFLQyxTQUFTLENBQUNLLFFBQVE7UUFDL0JDLE1BQU1QLEtBQUtDLFNBQVMsQ0FBQ08sWUFBWTtRQUNqQ0MsS0FBS1QsS0FBS0MsU0FBUyxDQUFDUyxXQUFXO0lBQ25DO0FBQ0o7QUFHQUMsT0FBT0MsT0FBTyxHQUFHQSxVQUFVckIsVUFBVXNCLFFBQVEsR0FBRztJQUU1Q0MsWUFBWUMsTUFBTSxFQUFFQyxPQUFPLENBQUU7UUFFekJqQyxPQUFPLE9BQU9nQyxXQUFXLFVBQVU7UUFDbkNoQyxPQUFPLENBQUNnQyxPQUFPRSxRQUFRLENBQUMsV0FBYSxDQUFDRixPQUFPRSxRQUFRLENBQUMsU0FBVztRQUVqRSxJQUFJLENBQUNGLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNHLFFBQVEsR0FBR0g7UUFFaEIsSUFBSSxDQUFDSSxTQUFTLEdBQUc7UUFFakIsSUFBSUgsU0FBUztZQUNULE1BQU0sRUFBRUksU0FBUyxFQUFF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LE9BQU9aLE9BQU9hLE9BQU9sRDtJQUN2RDtJQUVBOEcsUUFBTzlELEtBQUs7UUFFUixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUMzQixPQUFPQTtRQUNYO1FBRUEsSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDM0IsT0FBTytELFdBQVcvRDtRQUN0QjtRQUVBLElBQUksT0FBT0EsVUFBVSxXQUFXO1lBQzVCLE9BQU9BLFFBQVEsSUFBSTtRQUN2QjtRQUVBLElBQUlBLGlCQUFpQmhFLE1BQU07WUFDdkIsT0FBT2dFLE1BQU1nRSxPQUFPO1FBQ3hCO1FBRUEsT0FBTztJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3RlbXBsYXRlLmpzP2Q0YzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IEVzY2FwZUh0bWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lc2NhcGVIdG1sJyk7XG5jb25zdCBGb3JtdWxhID0gcmVxdWlyZSgnQHNpZGV3YXkvZm9ybXVsYScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHN5bWJvbDogU3ltYm9sKCd0ZW1wbGF0ZScpLFxuXG4gICAgb3BlbnM6IG5ldyBBcnJheSgxMDAwKS5qb2luKCdcXHUwMDAwJyksXG4gICAgY2xvc2VzOiBuZXcgQXJyYXkoMTAwMCkuam9pbignXFx1MDAwMScpLFxuXG4gICAgZGF0ZUZvcm1hdDoge1xuICAgICAgICBkYXRlOiBEYXRlLnByb3RvdHlwZS50b0RhdGVTdHJpbmcsXG4gICAgICAgIGlzbzogRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcsXG4gICAgICAgIHN0cmluZzogRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIHRpbWU6IERhdGUucHJvdG90eXBlLnRvVGltZVN0cmluZyxcbiAgICAgICAgdXRjOiBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZ1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gaW50ZXJuYWxzLlRlbXBsYXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnLCAnVGVtcGxhdGUgc291cmNlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuaW5jbHVkZXMoJ1xcdTAwMDAnKSAmJiAhc291cmNlLmluY2x1ZGVzKCdcXHUwMDAxJyksICdUZW1wbGF0ZSBzb3VyY2UgY2Fubm90IGNvbnRhaW4gcmVzZXJ2ZWQgY29udHJvbCBjaGFyYWN0ZXJzJyk7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBzb3VyY2U7XG5cbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZ1bmN0aW9ucywgLi4ub3B0cyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0gT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID8gQ2xvbmUob3B0cykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy5fZnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC5rZXlzKHRoaXMuX2Z1bmN0aW9ucykuZXZlcnkoKGtleSkgPT4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycpLCAnRnVuY3Rpb25zIGtleXMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC52YWx1ZXModGhpcy5fZnVuY3Rpb25zKS5ldmVyeSgoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSwgJ0Z1bmN0aW9ucyB2YWx1ZXMgbXVzdCBiZSBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fZnVuY3Rpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFyc2UoKTtcbiAgICB9XG5cbiAgICBfcGFyc2UoKSB7XG5cbiAgICAgICAgLy8gJ3RleHQge3Jhd30ge3tyZWZ9fSBcXFxce3tpZ25vcmV9fSB7e2lnbm9yZVxcXFx9fSB7e2lnbm9yZSB7e2lnbm9yZX0nXG5cbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmNvZGUgZXNjYXBlZCBcXFxce3t7e3tcblxuICAgICAgICBjb25zdCBlbmNvZGVkID0gaW50ZXJuYWxzLmVuY29kZSh0aGlzLnNvdXJjZSk7XG5cbiAgICAgICAgLy8gU3BsaXQgb24gZmlyc3QgeyBpbiBlYWNoIHNldFxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gaW50ZXJuYWxzLnNwbGl0KGVuY29kZWQpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICBsZXQgcmVmcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgY29uc3QgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gcGFydFswXSAhPT0gJ3snO1xuICAgICAgICAgICAgY29uc3QgZW5kZXIgPSByYXcgPyAnfScgOiAnfX0nO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcGFydC5pbmRleE9mKGVuZGVyKTtcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBub24tbWF0Y2hpbmcgY2xvc2luZ1xuICAgICAgICAgICAgICAgIHBhcnRbMV0gPT09ICd7JykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG1vcmUgdGhhbiB0d28ge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goYHske2ludGVybmFscy5kZWNvZGUocGFydCl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YXJpYWJsZSA9IHBhcnQuc2xpY2UocmF3ID8gMCA6IDEsIGVuZCk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gdmFyaWFibGVbMF0gPT09ICc6JztcbiAgICAgICAgICAgIGlmICh3cmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IHRoaXMuX3JlZihpbnRlcm5hbHMuZGVjb2RlKHZhcmlhYmxlKSwgeyByYXcsIHdyYXBwZWQgfSk7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChkeW5hbWljKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHluYW1pYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhcnQuc2xpY2UoZW5kICsgZW5kZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goaW50ZXJuYWxzLmRlY29kZShyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSBwcm9jZXNzZWQuam9pbignJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGF0ZShkYXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZUZvcm1hdFtwcmVmcy5kYXRlRm9ybWF0XS5jYWxsKGRhdGUpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcGFjdCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjID0geyB0ZW1wbGF0ZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB0aGlzLl9zZXR0aW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIGRlc2MuZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuXG4gICAgc3RhdGljIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5UZW1wbGF0ZShkZXNjLnRlbXBsYXRlLCBkZXNjLm9wdGlvbnMgfHwgZGVzYy5mdW5jdGlvbnMgPyB7IC4uLmRlc2Mub3B0aW9ucywgZnVuY3Rpb25zOiBkZXNjLmZ1bmN0aW9ucyB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBpc0R5bmFtaWMoKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVGVtcGxhdGUodGVtcGxhdGUpIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUgPyAhIXRlbXBsYXRlW0NvbW1vbi5zeW1ib2xzLnRlbXBsYXRlXSA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJlZnMoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2goLi4ucGFydC5yZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpIHtcblxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydCh0aGlzLl90ZW1wbGF0ZVswXSwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHt9IC8qXSAqLyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpO1xuICAgIH1cblxuICAgIF9wYXJ0KHBhcnQsIC4uLmFyZ3MpIHtcblxuICAgICAgICBpZiAocGFydC5yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnJlZi5yZXNvbHZlKC4uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnQuZm9ybXVsYS5ldmFsdWF0ZShhcmdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSB0aGlzLl9wYXJ0KHBhcnQsIC8qIGNvbnRleHQgLT4gWyovIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zIC8qXSAqLyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gaW50ZXJuYWxzLnN0cmluZ2lmeShyZW5kZXJlZCwgdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJ0LnJhdyB8fCAob3B0aW9ucy5lcnJvcnMgJiYgb3B0aW9ucy5lcnJvcnMuZXNjYXBlSHRtbCkgPT09IGZhbHNlID8gc3RyaW5nIDogRXNjYXBlSHRtbChzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGludGVybmFscy53cmFwKHJlc3VsdCwgcGFydC53cmFwcGVkICYmIHByZWZzLmVycm9ycy53cmFwLmxhYmVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIF9yZWYoY29udGVudCwgeyByYXcsIHdyYXBwZWQgfSkge1xuXG4gICAgICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gKHZhcmlhYmxlKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IFJlZi5jcmVhdGUodmFyaWFibGUsIHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgICAgIHJlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlZi5yZXNvbHZlKC4uLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZCAhPT0gdW5kZWZpbmVkID8gcmVzb2x2ZWQgOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gdGhpcy5fZnVuY3Rpb25zID8geyAuLi5pbnRlcm5hbHMuZnVuY3Rpb25zLCAuLi50aGlzLl9mdW5jdGlvbnMgfSA6IGludGVybmFscy5mdW5jdGlvbnM7XG4gICAgICAgICAgICB2YXIgZm9ybXVsYSA9IG5ldyBGb3JtdWxhLlBhcnNlcihjb250ZW50LCB7IHJlZmVyZW5jZSwgZnVuY3Rpb25zLCBjb25zdGFudHM6IGludGVybmFscy5jb25zdGFudHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgSW52YWxpZCB0ZW1wbGF0ZSB2YXJpYWJsZSBcIiR7Y29udGVudH1cIiBmYWlscyBkdWUgdG86ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtdWxhLnNpbmdsZSkge1xuICAgICAgICAgICAgaWYgKGZvcm11bGEuc2luZ2xlLnR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWYsIHJhdywgcmVmcywgd3JhcHBlZDogd3JhcHBlZCB8fCByZWYudHlwZSA9PT0gJ2xvY2FsJyAmJiByZWYua2V5ID09PSAnbGFiZWwnIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuc3RyaW5naWZ5KGZvcm11bGEuc2luZ2xlLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGZvcm11bGEsIHJhdywgcmVmcyB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudGVtcGxhdGVdID0gdHJ1ZTtcbmludGVybmFscy5UZW1wbGF0ZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzXG5cblxuaW50ZXJuYWxzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFx7KykvZywgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm9wZW5zLnNsaWNlKDAsICQxLmxlbmd0aCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcKFxcfSspL2csICgkMCwgJDEpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5jbG9zZXMuc2xpY2UoMCwgJDEubGVuZ3RoKTtcbiAgICAgICAgfSk7XG59O1xuXG5cbmludGVybmFscy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMDAwL2csICd7JylcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDEvZywgJ30nKTtcbn07XG5cblxuaW50ZXJuYWxzLnNwbGl0ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0cmluZ1tpXTtcblxuICAgICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgc3RyaW5nLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ1tpICsgMV0gPT09ICd7Jykge1xuXG4gICAgICAgICAgICAgICAgbmV4dCArPSAneyc7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpO1xuICAgIHJldHVybiBwYXJ0cztcbn07XG5cblxuaW50ZXJuYWxzLndyYXAgPSBmdW5jdGlvbiAodmFsdWUsIGVuZHMpIHtcblxuICAgIGlmICghZW5kcykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGVuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmRzfSR7dmFsdWV9JHtlbmRzfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2VuZHNbMF19JHt2YWx1ZX0ke2VuZHNbMV19YDtcbn07XG5cblxuaW50ZXJuYWxzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3JpZ2luYWwsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjb25zdCB3cmFwID0gcHJlZnMgJiYgcHJlZnMuZXJyb3JzICYmIHByZWZzLmVycm9ycy53cmFwIHx8IHt9O1xuXG4gICAgbGV0IHNraXBXcmFwID0gZmFsc2U7XG4gICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUucmVuZGVyKSB7XG5cbiAgICAgICAgc2tpcFdyYXAgPSB2YWx1ZS5pbjtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXNvbHZlKG9yaWdpbmFsLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCB7IGluOiB2YWx1ZS5pbiwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy53cmFwKHZhbHVlLCBvcHRpb25zLmFycmF5SXRlbXMgJiYgd3JhcC5zdHJpbmcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLlRlbXBsYXRlLmRhdGUodmFsdWUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBzeW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChgJHtrZXkudG9TdHJpbmcoKX0gLT4gJHtzeW0udG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gcGFpcnM7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goaW50ZXJuYWxzLnN0cmluZ2lmeShpdGVtLCBvcmlnaW5hbCwgc3RhdGUsIHByZWZzLCBsb2NhbCwgeyBhcnJheUl0ZW1zOiB0cnVlLCAuLi5vcHRpb25zIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLndyYXAodmFsdWVzLmpvaW4oJywgJyksICFza2lwV3JhcCAmJiB3cmFwLmFycmF5KTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbnN0YW50cyA9IHtcblxuICAgIHRydWU6IHRydWUsXG4gICAgZmFsc2U6IGZhbHNlLFxuICAgIG51bGw6IG51bGwsXG5cbiAgICBzZWNvbmQ6IDEwMDAsXG4gICAgbWludXRlOiA2MCAqIDEwMDAsXG4gICAgaG91cjogNjAgKiA2MCAqIDEwMDAsXG4gICAgZGF5OiAyNCAqIDYwICogNjAgKiAxMDAwXG59O1xuXG5cbmludGVybmFscy5mdW5jdGlvbnMgPSB7XG5cbiAgICBpZihjb25kaXRpb24sIHRoZW4sIG90aGVyd2lzZSkge1xuXG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyB0aGVuIDogb3RoZXJ3aXNlO1xuICAgIH0sXG5cbiAgICBsZW5ndGgoaXRlbSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIG1zZyhjb2RlKSB7XG5cbiAgICAgICAgY29uc3QgW3ZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zXSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBFcnJvcnMudGVtcGxhdGUodmFsdWUsIG1lc3NhZ2VzWzBdLCBjb2RlLCBzdGF0ZSwgcHJlZnMpIHx8IEVycm9ycy50ZW1wbGF0ZSh2YWx1ZSwgbWVzc2FnZXNbMV0sIGNvZGUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBudW1iZXIodmFsdWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJBc3NlcnQiLCJyZXF1aXJlIiwiQ2xvbmUiLCJFc2NhcGVIdG1sIiwiRm9ybXVsYSIsIkNvbW1vbiIsIkVycm9ycyIsIlJlZiIsImludGVybmFscyIsInN5bWJvbCIsIlN5bWJvbCIsIm9wZW5zIiwiQXJyYXkiLCJqb2luIiwiY2xvc2VzIiwiZGF0ZUZvcm1hdCIsImRhdGUiLCJEYXRlIiwicHJvdG90eXBlIiwidG9EYXRlU3RyaW5nIiwiaXNvIiwidG9JU09TdHJpbmciLCJzdHJpbmciLCJ0b1N0cmluZyIsInRpbWUiLCJ0b1RpbWVTdHJpbmciLCJ1dGMiLCJ0b1VUQ1N0cmluZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJUZW1wbGF0ZSIsImNvbnN0cnVjdG9yIiwic291cmNlIiwib3B0aW9ucyIsImluY2x1ZGVzIiwicmVuZGVyZWQiLCJfdGVtcGxhdGUiLCJmdW5jdGlvbnMiLCJvcHRzIiwiX3NldHRpbmdzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIl9mdW5jdGlvbnMiLCJldmVyeSIsImtleSIsInZhbHVlcyIsIl9wYXJzZSIsImVuY29kZWQiLCJlbmNvZGUiLCJwYXJ0cyIsInNwbGl0IiwicmVmcyIsInByb2Nlc3NlZCIsImhlYWQiLCJzaGlmdCIsInB1c2giLCJwYXJ0IiwicmF3IiwiZW5kZXIiLCJlbmQiLCJpbmRleE9mIiwiZGVjb2RlIiwidmFyaWFibGUiLCJzbGljZSIsIndyYXBwZWQiLCJkeW5hbWljIiwiX3JlZiIsInJlc3QiLCJwcmVmcyIsImNhbGwiLCJkZXNjcmliZSIsImNvbXBhY3QiLCJkZXNjIiwidGVtcGxhdGUiLCJidWlsZCIsImlzRHluYW1pYyIsImlzVGVtcGxhdGUiLCJzeW1ib2xzIiwicmVzb2x2ZSIsInZhbHVlIiwic3RhdGUiLCJsb2NhbCIsIl9wYXJ0IiwicmVuZGVyIiwiYXJncyIsInJlZiIsImZvcm11bGEiLCJldmFsdWF0ZSIsInN0cmluZ2lmeSIsInJlc3VsdCIsImVycm9ycyIsImVzY2FwZUh0bWwiLCJ3cmFwIiwibGFiZWwiLCJjb250ZW50IiwicmVmZXJlbmNlIiwiY3JlYXRlIiwiY29udGV4dCIsInJlc29sdmVkIiwiUGFyc2VyIiwiY29uc3RhbnRzIiwiZXJyIiwibWVzc2FnZSIsInNpbmdsZSIsInR5cGUiLCJpc0ltbXV0YWJsZSIsInJlcGxhY2UiLCIkMCIsIiQxIiwiY3VycmVudCIsImkiLCJjaGFyIiwibmV4dCIsImVuZHMiLCJvcmlnaW5hbCIsInNraXBXcmFwIiwiaXNSZWYiLCJpbiIsImFycmF5SXRlbXMiLCJKU09OIiwiTWFwIiwicGFpcnMiLCJzeW0iLCJlbnRyaWVzIiwiaXNBcnJheSIsIml0ZW0iLCJhcnJheSIsInRydWUiLCJmYWxzZSIsIm51bGwiLCJzZWNvbmQiLCJtaW51dGUiLCJob3VyIiwiZGF5IiwiaWYiLCJjb25kaXRpb24iLCJ0aGVuIiwib3RoZXJ3aXNlIiwibXNnIiwiY29kZSIsIm1lc3NhZ2VzIiwibnVtYmVyIiwicGFyc2VGbG9hdCIsImdldFRpbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/template.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/trace.js":
/*!***************************************!*\
  !*** ./node_modules/joi/lib/trace.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"(rsc)/./node_modules/@hapi/hoek/lib/deepEqual.js\");\nconst Pinpoint = __webpack_require__(/*! @sideway/pinpoint */ \"(rsc)/./node_modules/@sideway/pinpoint/lib/index.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst internals = {\n    codes: {\n        error: 1,\n        pass: 2,\n        full: 3\n    },\n    labels: {\n        0: \"never used\",\n        1: \"always error\",\n        2: \"always pass\"\n    }\n};\nexports.setup = function(root) {\n    const trace = function() {\n        root._tracer = root._tracer || new internals.Tracer();\n        return root._tracer;\n    };\n    root.trace = trace;\n    root[Symbol.for(\"@hapi/lab/coverage/initialize\")] = trace;\n    root.untrace = ()=>{\n        root._tracer = null;\n    };\n};\nexports.location = function(schema) {\n    return schema.$_setFlag(\"_tracerLocation\", Pinpoint.location(2)); // base.tracer(), caller\n};\ninternals.Tracer = class {\n    constructor(){\n        this.name = \"Joi\";\n        this._schemas = new Map();\n    }\n    _register(schema) {\n        const existing = this._schemas.get(schema);\n        if (existing) {\n            return existing.store;\n        }\n        const store = new internals.Store(schema);\n        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5); // internals.tracer(), internals.entry(), exports.entry(), validate(), caller\n        this._schemas.set(schema, {\n            filename,\n            line,\n            store\n        });\n        return store;\n    }\n    _combine(merged, sources) {\n        for (const { store } of this._schemas.values()){\n            store._combine(merged, sources);\n        }\n    }\n    report(file) {\n        const coverage = [];\n        // Process each registered schema\n        for (const { filename, line, store } of this._schemas.values()){\n            if (file && file !== filename) {\n                continue;\n            }\n            // Process sub schemas of the registered root\n            const missing = [];\n            const skipped = [];\n            for (const [schema, log] of store._sources.entries()){\n                // Check if sub schema parent skipped\n                if (internals.sub(log.paths, skipped)) {\n                    continue;\n                }\n                // Check if sub schema reached\n                if (!log.entry) {\n                    missing.push({\n                        status: \"never reached\",\n                        paths: [\n                            ...log.paths\n                        ]\n                    });\n                    skipped.push(...log.paths);\n                    continue;\n                }\n                // Check values\n                for (const type of [\n                    \"valid\",\n                    \"invalid\"\n                ]){\n                    const set = schema[`_${type}s`];\n                    if (!set) {\n                        continue;\n                    }\n                    const values = new Set(set._values);\n                    const refs = new Set(set._refs);\n                    for (const { value, ref } of log[type]){\n                        values.delete(value);\n                        refs.delete(ref);\n                    }\n                    if (values.size || refs.size) {\n                        missing.push({\n                            status: [\n                                ...values,\n                                ...[\n                                    ...refs\n                                ].map((ref)=>ref.display)\n                            ],\n                            rule: `${type}s`\n                        });\n                    }\n                }\n                // Check rules status\n                const rules = schema._rules.map((rule)=>rule.name);\n                for (const type of [\n                    \"default\",\n                    \"failover\"\n                ]){\n                    if (schema._flags[type] !== undefined) {\n                        rules.push(type);\n                    }\n                }\n                for (const name of rules){\n                    const status = internals.labels[log.rule[name] || 0];\n                    if (status) {\n                        const report = {\n                            rule: name,\n                            status\n                        };\n                        if (log.paths.size) {\n                            report.paths = [\n                                ...log.paths\n                            ];\n                        }\n                        missing.push(report);\n                    }\n                }\n            }\n            if (missing.length) {\n                coverage.push({\n                    filename,\n                    line,\n                    missing,\n                    severity: \"error\",\n                    message: `Schema missing tests for ${missing.map(internals.message).join(\", \")}`\n                });\n            }\n        }\n        return coverage.length ? coverage : null;\n    }\n};\ninternals.Store = class {\n    constructor(schema){\n        this.active = true;\n        this._sources = new Map(); // schema -> { paths, entry, rule, valid, invalid }\n        this._combos = new Map(); // merged -> [sources]\n        this._scan(schema);\n    }\n    debug(state, source, name, result) {\n        state.mainstay.debug && state.mainstay.debug.push({\n            type: source,\n            name,\n            result,\n            path: state.path\n        });\n    }\n    entry(schema, state) {\n        internals.debug(state, {\n            type: \"entry\"\n        });\n        this._record(schema, (log)=>{\n            log.entry = true;\n        });\n    }\n    filter(schema, state, source, value) {\n        internals.debug(state, {\n            type: source,\n            ...value\n        });\n        this._record(schema, (log)=>{\n            log[source].add(value);\n        });\n    }\n    log(schema, state, source, name, result) {\n        internals.debug(state, {\n            type: source,\n            name,\n            result: result === \"full\" ? \"pass\" : result\n        });\n        this._record(schema, (log)=>{\n            log[source][name] = log[source][name] || 0;\n            log[source][name] |= internals.codes[result];\n        });\n    }\n    resolve(state, ref, to) {\n        if (!state.mainstay.debug) {\n            return;\n        }\n        const log = {\n            type: \"resolve\",\n            ref: ref.display,\n            to,\n            path: state.path\n        };\n        state.mainstay.debug.push(log);\n    }\n    value(state, by, from, to, name) {\n        if (!state.mainstay.debug || DeepEqual(from, to)) {\n            return;\n        }\n        const log = {\n            type: \"value\",\n            by,\n            from,\n            to,\n            path: state.path\n        };\n        if (name) {\n            log.name = name;\n        }\n        state.mainstay.debug.push(log);\n    }\n    _record(schema, each) {\n        const log = this._sources.get(schema);\n        if (log) {\n            each(log);\n            return;\n        }\n        const sources = this._combos.get(schema);\n        for (const source of sources){\n            this._record(source, each);\n        }\n    }\n    _scan(schema, _path) {\n        const path = _path || [];\n        let log = this._sources.get(schema);\n        if (!log) {\n            log = {\n                paths: new Set(),\n                entry: false,\n                rule: {},\n                valid: new Set(),\n                invalid: new Set()\n            };\n            this._sources.set(schema, log);\n        }\n        if (path.length) {\n            log.paths.add(path);\n        }\n        const each = (sub, source)=>{\n            const subId = internals.id(sub, source);\n            this._scan(sub, path.concat(subId));\n        };\n        schema.$_modify({\n            each,\n            ref: false\n        });\n    }\n    _combine(merged, sources) {\n        this._combos.set(merged, sources);\n    }\n};\ninternals.message = function(item) {\n    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? \":\" : \"\") : \"\";\n    return `${path}${item.rule || \"\"} (${item.status})`;\n};\ninternals.id = function(schema, { source, name, path, key }) {\n    if (schema._flags.id) {\n        return schema._flags.id;\n    }\n    if (key) {\n        return key;\n    }\n    name = `@${name}`;\n    if (source === \"terms\") {\n        return [\n            name,\n            path[Math.min(path.length - 1, 1)]\n        ];\n    }\n    return name;\n};\ninternals.sub = function(paths, skipped) {\n    for (const path of paths){\n        for (const skip of skipped){\n            if (DeepEqual(path.slice(0, skip.length), skip)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\ninternals.debug = function(state, event) {\n    if (state.mainstay.debug) {\n        event.path = state.debug ? [\n            ...state.path,\n            state.debug\n        ] : state.path;\n        state.mainstay.debug.push(event);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxHQUFHLENBQUNuQixLQUFLWixNQUFNLEdBQUcsR0FBRyxHQUFHO1NBQUM7SUFDckQ7SUFFQSxPQUFPN0M7QUFDWDtBQUdBbkIsVUFBVTRDLEdBQUcsR0FBRyxTQUFVQyxLQUFLLEVBQUVMLE9BQU87SUFFcEMsS0FBSyxNQUFNb0MsUUFBUS9CLE1BQU87UUFDdEIsS0FBSyxNQUFNbUQsUUFBUXhELFFBQVM7WUFDeEIsSUFBSTVDLFVBQVVnRixLQUFLcUIsS0FBSyxDQUFDLEdBQUdELEtBQUtoQyxNQUFNLEdBQUdnQyxPQUFPO2dCQUM3QyxPQUFPO1lBQ1g7UUFDSjtJQUNKO0lBRUEsT0FBTztBQUNYO0FBR0FoRyxVQUFVdUUsS0FBSyxHQUFHLFNBQVVDLEtBQUssRUFBRTBCLEtBQUs7SUFFcEMsSUFBSTFCLE1BQU1HLFFBQVEsQ0FBQ0osS0FBSyxFQUFFO1FBQ3RCMkIsTUFBTXRCLElBQUksR0FBR0osTUFBTUQsS0FBSyxHQUFHO2VBQUlDLE1BQU1JLElBQUk7WUFBRUosTUFBTUQsS0FBSztTQUFDLEdBQUdDLE1BQU1JLElBQUk7UUFDcEVKLE1BQU1HLFFBQVEsQ0FBQ0osS0FBSyxDQUFDeEIsSUFBSSxDQUFDbUQ7SUFDOUI7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHJhY2UuanM/ZDRkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgUGlucG9pbnQgPSByZXF1aXJlKCdAc2lkZXdheS9waW5wb2ludCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBjb2Rlczoge1xuICAgICAgICBlcnJvcjogMSxcbiAgICAgICAgcGFzczogMixcbiAgICAgICAgZnVsbDogM1xuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICAgIDA6ICduZXZlciB1c2VkJyxcbiAgICAgICAgMTogJ2Fsd2F5cyBlcnJvcicsXG4gICAgICAgIDI6ICdhbHdheXMgcGFzcydcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuc2V0dXAgPSBmdW5jdGlvbiAocm9vdCkge1xuXG4gICAgY29uc3QgdHJhY2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gcm9vdC5fdHJhY2VyIHx8IG5ldyBpbnRlcm5hbHMuVHJhY2VyKCk7XG4gICAgICAgIHJldHVybiByb290Ll90cmFjZXI7XG4gICAgfTtcblxuICAgIHJvb3QudHJhY2UgPSB0cmFjZTtcbiAgICByb290W1N5bWJvbC5mb3IoJ0BoYXBpL2xhYi9jb3ZlcmFnZS9pbml0aWFsaXplJyldID0gdHJhY2U7XG5cbiAgICByb290LnVudHJhY2UgPSAoKSA9PiB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gbnVsbDtcbiAgICB9O1xufTtcblxuXG5leHBvcnRzLmxvY2F0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgcmV0dXJuIHNjaGVtYS4kX3NldEZsYWcoJ190cmFjZXJMb2NhdGlvbicsIFBpbnBvaW50LmxvY2F0aW9uKDIpKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2UudHJhY2VyKCksIGNhbGxlclxufTtcblxuXG5pbnRlcm5hbHMuVHJhY2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0pvaSc7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyKHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fc2NoZW1hcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmcuc3RvcmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBpbnRlcm5hbHMuU3RvcmUoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgeyBmaWxlbmFtZSwgbGluZSB9ID0gc2NoZW1hLl9mbGFncy5fdHJhY2VyTG9jYXRpb24gfHwgUGlucG9pbnQubG9jYXRpb24oNSk7ICAgLy8gaW50ZXJuYWxzLnRyYWNlcigpLCBpbnRlcm5hbHMuZW50cnkoKSwgZXhwb3J0cy5lbnRyeSgpLCB2YWxpZGF0ZSgpLCBjYWxsZXJcbiAgICAgICAgdGhpcy5fc2NoZW1hcy5zZXQoc2NoZW1hLCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN0b3JlLl9jb21iaW5lKG1lcmdlZCwgc291cmNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXBvcnQoZmlsZSkge1xuXG4gICAgICAgIGNvbnN0IGNvdmVyYWdlID0gW107XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHJlZ2lzdGVyZWQgc2NoZW1hXG5cbiAgICAgICAgZm9yIChjb25zdCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChmaWxlICYmXG4gICAgICAgICAgICAgICAgZmlsZSAhPT0gZmlsZW5hbWUpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHN1YiBzY2hlbWFzIG9mIHRoZSByZWdpc3RlcmVkIHJvb3RcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzY2hlbWEsIGxvZ10gb2Ygc3RvcmUuX3NvdXJjZXMuZW50cmllcygpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzdWIgc2NoZW1hIHBhcmVudCBza2lwcGVkXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLnN1Yihsb2cucGF0aHMsIHNraXBwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHN1YiBzY2hlbWEgcmVhY2hlZFxuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2cuZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ25ldmVyIHJlYWNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsuLi5sb2cucGF0aHNdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCguLi5sb2cucGF0aHMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB2YWx1ZXNcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ3ZhbGlkJywgJ2ludmFsaWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBzY2hlbWFbYF8ke3R5cGV9c2BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KHNldC5fdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IG5ldyBTZXQoc2V0Ll9yZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlLCByZWYgfSBvZiBsb2dbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuc2l6ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5zaXplKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBbLi4udmFsdWVzLCAuLi5bLi4ucmVmc10ubWFwKChyZWYpID0+IHJlZi5kaXNwbGF5KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYCR7dHlwZX1zYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBydWxlcyBzdGF0dXNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gc2NoZW1hLl9ydWxlcy5tYXAoKHJ1bGUpID0+IHJ1bGUubmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFsnZGVmYXVsdCcsICdmYWlsb3ZlciddKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gaW50ZXJuYWxzLmxhYmVsc1tsb2cucnVsZVtuYW1lXSB8fCAwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0geyBydWxlOiBuYW1lLCBzdGF0dXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cucGF0aHMuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRocyA9IFsuLi5sb2cucGF0aHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFNjaGVtYSBtaXNzaW5nIHRlc3RzIGZvciAke21pc3NpbmcubWFwKGludGVybmFscy5tZXNzYWdlKS5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3ZlcmFnZS5sZW5ndGggPyBjb3ZlcmFnZSA6IG51bGw7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuU3RvcmUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgIC8vIHNjaGVtYSAtPiB7IHBhdGhzLCBlbnRyeSwgcnVsZSwgdmFsaWQsIGludmFsaWQgfVxuICAgICAgICB0aGlzLl9jb21ib3MgPSBuZXcgTWFwKCk7ICAgICAgICAgICAvLyBtZXJnZWQgLT4gW3NvdXJjZXNdXG4gICAgICAgIHRoaXMuX3NjYW4oc2NoZW1hKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhzdGF0ZSwgc291cmNlLCBuYW1lLCByZXN1bHQpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1ZyAmJiBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKHsgdHlwZTogc291cmNlLCBuYW1lLCByZXN1bHQsIHBhdGg6IHN0YXRlLnBhdGggfSk7XG4gICAgfVxuXG4gICAgZW50cnkoc2NoZW1hLCBzdGF0ZSkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiAnZW50cnknIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nLmVudHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmlsdGVyKHNjaGVtYSwgc3RhdGUsIHNvdXJjZSwgdmFsdWUpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogc291cmNlLCAuLi52YWx1ZSB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZ1tzb3VyY2VdLmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvZyhzY2hlbWEsIHN0YXRlLCBzb3VyY2UsIG5hbWUsIHJlc3VsdCkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiBzb3VyY2UsIG5hbWUsIHJlc3VsdDogcmVzdWx0ID09PSAnZnVsbCcgPyAncGFzcycgOiByZXN1bHQgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSA9IGxvZ1tzb3VyY2VdW25hbWVdIHx8IDA7XG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSB8PSBpbnRlcm5hbHMuY29kZXNbcmVzdWx0XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZShzdGF0ZSwgcmVmLCB0bykge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZyA9IHsgdHlwZTogJ3Jlc29sdmUnLCByZWY6IHJlZi5kaXNwbGF5LCB0bywgcGF0aDogc3RhdGUucGF0aCB9O1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgdmFsdWUoc3RhdGUsIGJ5LCBmcm9tLCB0bywgbmFtZSkge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcgfHxcbiAgICAgICAgICAgIERlZXBFcXVhbChmcm9tLCB0bykpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9nID0geyB0eXBlOiAndmFsdWUnLCBieSwgZnJvbSwgdG8sIHBhdGg6IHN0YXRlLnBhdGggfTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGxvZy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2gobG9nKTtcbiAgICB9XG5cbiAgICBfcmVjb3JkKHNjaGVtYSwgZWFjaCkge1xuXG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX3NvdXJjZXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGVhY2gobG9nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9jb21ib3MuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZChzb3VyY2UsIGVhY2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NjYW4oc2NoZW1hLCBfcGF0aCkge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgICAgICBsZXQgbG9nID0gdGhpcy5fc291cmNlcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKCFsb2cpIHtcbiAgICAgICAgICAgIGxvZyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoczogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydWxlOiB7fSxcbiAgICAgICAgICAgICAgICB2YWxpZDogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fc291cmNlcy5zZXQoc2NoZW1hLCBsb2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2cucGF0aHMuYWRkKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChzdWIsIHNvdXJjZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IGludGVybmFscy5pZChzdWIsIHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9zY2FuKHN1YiwgcGF0aC5jb25jYXQoc3ViSWQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY2hlbWEuJF9tb2RpZnkoeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIHRoaXMuX2NvbWJvcy5zZXQobWVyZ2VkLCBzb3VyY2VzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5tZXNzYWdlID0gZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgIGNvbnN0IHBhdGggPSBpdGVtLnBhdGhzID8gRXJyb3JzLnBhdGgoaXRlbS5wYXRoc1swXSkgKyAoaXRlbS5ydWxlID8gJzonIDogJycpIDogJyc7XG4gICAgcmV0dXJuIGAke3BhdGh9JHtpdGVtLnJ1bGUgfHwgJyd9ICgke2l0ZW0uc3RhdHVzfSlgO1xufTtcblxuXG5pbnRlcm5hbHMuaWQgPSBmdW5jdGlvbiAoc2NoZW1hLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pIHtcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLmlkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBuYW1lID0gYEAke25hbWV9YDtcblxuICAgIGlmIChzb3VyY2UgPT09ICd0ZXJtcycpIHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCBwYXRoW01hdGgubWluKHBhdGgubGVuZ3RoIC0gMSwgMSldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cblxuaW50ZXJuYWxzLnN1YiA9IGZ1bmN0aW9uIChwYXRocywgc2tpcHBlZCkge1xuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2tpcCBvZiBza2lwcGVkKSB7XG4gICAgICAgICAgICBpZiAoRGVlcEVxdWFsKHBhdGguc2xpY2UoMCwgc2tpcC5sZW5ndGgpLCBza2lwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuZGVidWcgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XG5cbiAgICBpZiAoc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgZXZlbnQucGF0aCA9IHN0YXRlLmRlYnVnID8gWy4uLnN0YXRlLnBhdGgsIHN0YXRlLmRlYnVnXSA6IHN0YXRlLnBhdGg7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2goZXZlbnQpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiRGVlcEVxdWFsIiwicmVxdWlyZSIsIlBpbnBvaW50IiwiRXJyb3JzIiwiaW50ZXJuYWxzIiwiY29kZXMiLCJlcnJvciIsInBhc3MiLCJmdWxsIiwibGFiZWxzIiwiZXhwb3J0cyIsInNldHVwIiwicm9vdCIsInRyYWNlIiwiX3RyYWNlciIsIlRyYWNlciIsIlN5bWJvbCIsImZvciIsInVudHJhY2UiLCJsb2NhdGlvbiIsInNjaGVtYSIsIiRfc2V0RmxhZyIsImNvbnN0cnVjdG9yIiwibmFtZSIsIl9zY2hlbWFzIiwiTWFwIiwiX3JlZ2lzdGVyIiwiZXhpc3RpbmciLCJnZXQiLCJzdG9yZSIsIlN0b3JlIiwiZmlsZW5hbWUiLCJsaW5lIiwiX2ZsYWdzIiwiX3RyYWNlckxvY2F0aW9uIiwic2V0IiwiX2NvbWJpbmUiLCJtZXJnZWQiLCJzb3VyY2VzIiwidmFsdWVzIiwicmVwb3J0IiwiZmlsZSIsImNvdmVyYWdlIiwibWlzc2luZyIsInNraXBwZWQiLCJsb2ciLCJfc291cmNlcyIsImVudHJpZXMiLCJzdWIiLCJwYXRocyIsImVudHJ5IiwicHVzaCIsInN0YXR1cyIsInR5cGUiLCJTZXQiLCJfdmFsdWVzIiwicmVmcyIsIl9yZWZzIiwidmFsdWUiLCJyZWYiLCJkZWxldGUiLCJzaXplIiwibWFwIiwiZGlzcGxheSIsInJ1bGUiLCJydWxlcyIsIl9ydWxlcyIsInVuZGVmaW5lZCIsImxlbmd0aCIsInNldmVyaXR5IiwibWVzc2FnZSIsImpvaW4iLCJhY3RpdmUiLCJfY29tYm9zIiwiX3NjYW4iLCJkZWJ1ZyIsInN0YXRlIiwic291cmNlIiwicmVzdWx0IiwibWFpbnN0YXkiLCJwYXRoIiwiX3JlY29yZCIsImZpbHRlciIsImFkZCIsInJlc29sdmUiLCJ0byIsImJ5IiwiZnJvbSIsImVhY2giLCJfcGF0aCIsInZhbGlkIiwiaW52YWxpZCIsInN1YklkIiwiaWQiLCJjb25jYXQiLCIkX21vZGlmeSIsIml0ZW0iLCJrZXkiLCJNYXRoIiwibWluIiwic2tpcCIsInNsaWNlIiwiZXZlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/trace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/alternatives.js":
/*!****************************************************!*\
  !*** ./node_modules/joi/lib/types/alternatives.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ \"(rsc)/./node_modules/@hapi/hoek/lib/merge.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ../ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst internals = {};\nmodule.exports = Any.extend({\n    type: \"alternatives\",\n    flags: {\n        match: {\n            default: \"any\"\n        } // 'any', 'one', 'all'\n    },\n    terms: {\n        matches: {\n            init: [],\n            register: Ref.toSibling\n        }\n    },\n    args (schema, ...schemas) {\n        if (schemas.length === 1) {\n            if (Array.isArray(schemas[0])) {\n                return schema.try(...schemas[0]);\n            }\n        }\n        return schema.try(...schemas);\n    },\n    validate (value, helpers) {\n        const { schema, error, state, prefs } = helpers;\n        // Match all or one\n        if (schema._flags.match) {\n            const matched = [];\n            const failed = [];\n            for(let i = 0; i < schema.$_terms.matches.length; ++i){\n                const item = schema.$_terms.matches[i];\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    matched.push(result.value);\n                    localState.commit();\n                } else {\n                    failed.push(result.errors);\n                    localState.restore();\n                }\n            }\n            if (matched.length === 0) {\n                const context = {\n                    details: failed.map((f)=>Errors.details(f, {\n                            override: false\n                        }))\n                };\n                return {\n                    errors: error(\"alternatives.any\", context)\n                };\n            }\n            // Match one\n            if (schema._flags.match === \"one\") {\n                return matched.length === 1 ? {\n                    value: matched[0]\n                } : {\n                    errors: error(\"alternatives.one\")\n                };\n            }\n            // Match all\n            if (matched.length !== schema.$_terms.matches.length) {\n                const context = {\n                    details: failed.map((f)=>Errors.details(f, {\n                            override: false\n                        }))\n                };\n                return {\n                    errors: error(\"alternatives.all\", context)\n                };\n            }\n            const isAnyObj = (alternative)=>{\n                return alternative.$_terms.matches.some((v)=>{\n                    return v.schema.type === \"object\" || v.schema.type === \"alternatives\" && isAnyObj(v.schema);\n                });\n            };\n            return isAnyObj(schema) ? {\n                value: matched.reduce((acc, v)=>Merge(acc, v, {\n                        mergeArrays: false\n                    }))\n            } : {\n                value: matched[matched.length - 1]\n            };\n        }\n        // Match any\n        const errors = [];\n        for(let i = 0; i < schema.$_terms.matches.length; ++i){\n            const item = schema.$_terms.matches[i];\n            // Try\n            if (item.schema) {\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    localState.commit();\n                    return result;\n                }\n                localState.restore();\n                errors.push({\n                    schema: item.schema,\n                    reports: result.errors\n                });\n                continue;\n            }\n            // Conditional\n            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;\n            const tests = item.is ? [\n                item\n            ] : item.switch;\n            for(let j = 0; j < tests.length; ++j){\n                const test = tests[j];\n                const { is, then, otherwise } = test;\n                const id = `match.${i}${item.switch ? \".\" + j : \"\"}`;\n                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {\n                    if (otherwise) {\n                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);\n                    }\n                } else if (then) {\n                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);\n                }\n            }\n        }\n        return internals.errors(errors, helpers);\n    },\n    rules: {\n        conditional: {\n            method (condition, options) {\n                Assert(!this._flags._endedSwitch, \"Unreachable condition\");\n                Assert(!this._flags.match, \"Cannot combine match mode\", this._flags.match, \"with conditional rule\");\n                Assert(options.break === undefined, \"Cannot use break option with alternatives conditional\");\n                const obj = this.clone();\n                const match = Compile.when(obj, condition, options);\n                const conditions = match.is ? [\n                    match\n                ] : match.switch;\n                for (const item of conditions){\n                    if (item.then && item.otherwise) {\n                        obj.$_setFlag(\"_endedSwitch\", true, {\n                            clone: false\n                        });\n                        break;\n                    }\n                }\n                obj.$_terms.matches.push(match);\n                return obj.$_mutateRebuild();\n            }\n        },\n        match: {\n            method (mode) {\n                Assert([\n                    \"any\",\n                    \"one\",\n                    \"all\"\n                ].includes(mode), \"Invalid alternatives match mode\", mode);\n                if (mode !== \"any\") {\n                    for (const match of this.$_terms.matches){\n                        Assert(match.schema, \"Cannot combine match mode\", mode, \"with conditional rules\");\n                    }\n                }\n                return this.$_setFlag(\"match\", mode);\n            }\n        },\n        try: {\n            method (...schemas) {\n                Assert(schemas.length, \"Missing alternative schemas\");\n                Common.verifyFlat(schemas, \"try\");\n                Assert(!this._flags._endedSwitch, \"Unreachable condition\");\n                const obj = this.clone();\n                for (const schema of schemas){\n                    obj.$_terms.matches.push({\n                        schema: obj.$_compile(schema)\n                    });\n                }\n                return obj.$_mutateRebuild();\n            }\n        }\n    },\n    overrides: {\n        label (name) {\n            const obj = this.$_parent(\"label\", name);\n            const each = (item, source)=>{\n                return source.path[0] !== \"is\" && typeof item._flags.label !== \"string\" ? item.label(name) : undefined;\n            };\n            return obj.$_modify({\n                each,\n                ref: false\n            });\n        }\n    },\n    rebuild (schema) {\n        // Flag when an alternative type is an array\n        const each = (item)=>{\n            if (Common.isSchema(item) && item.type === \"array\") {\n                schema.$_setFlag(\"_arrayItems\", true, {\n                    clone: false\n                });\n            }\n        };\n        schema.$_modify({\n            each\n        });\n    },\n    manifest: {\n        build (obj, desc) {\n            if (desc.matches) {\n                for (const match of desc.matches){\n                    const { schema, ref, is, not, then, otherwise } = match;\n                    if (schema) {\n                        obj = obj.try(schema);\n                    } else if (ref) {\n                        obj = obj.conditional(ref, {\n                            is,\n                            then,\n                            not,\n                            otherwise,\n                            switch: match.switch\n                        });\n                    } else {\n                        obj = obj.conditional(is, {\n                            then,\n                            otherwise\n                        });\n                    }\n                }\n            }\n            return obj;\n        }\n    },\n    messages: {\n        \"alternatives.all\": \"{{#label}} does not match all of the required types\",\n        \"alternatives.any\": \"{{#label}} does not match any of the allowed types\",\n        \"alternatives.match\": \"{{#label}} does not match any of the allowed types\",\n        \"alternatives.one\": \"{{#label}} matches more than one allowed type\",\n        \"alternatives.types\": \"{{#label}} must be one of {{#types}}\"\n    }\n});\n// Helpers\ninternals.errors = function(failures, { error, state }) {\n    // Nothing matched due to type criteria rules\n    if (!failures.length) {\n        return {\n            errors: error(\"alternatives.any\")\n        };\n    }\n    // Single error\n    if (failures.length === 1) {\n        return {\n            errors: failures[0].reports\n        };\n    }\n    // Analyze reasons\n    const valids = new Set();\n    const complex = [];\n    for (const { reports, schema } of failures){\n        // Multiple errors (!abortEarly)\n        if (reports.length > 1) {\n            return internals.unmatched(failures, error);\n        }\n        // Custom error\n        const report = reports[0];\n        if (report instanceof Errors.Report === false) {\n            return internals.unmatched(failures, error);\n        }\n        // Internal object or array error\n        if (report.state.path.length !== state.path.length) {\n            complex.push({\n                type: schema.type,\n                report\n            });\n            continue;\n        }\n        // Valids\n        if (report.code === \"any.only\") {\n            for (const valid of report.local.valids){\n                valids.add(valid);\n            }\n            continue;\n        }\n        // Base type\n        const [type, code] = report.code.split(\".\");\n        if (code !== \"base\") {\n            complex.push({\n                type: schema.type,\n                report\n            });\n        } else if (report.code === \"object.base\") {\n            valids.add(report.local.type);\n        } else {\n            valids.add(type);\n        }\n    }\n    // All errors are base types or valids\n    if (!complex.length) {\n        return {\n            errors: error(\"alternatives.types\", {\n                types: [\n                    ...valids\n                ]\n            })\n        };\n    }\n    // Single complex error\n    if (complex.length === 1) {\n        return {\n            errors: complex[0].report\n        };\n    }\n    return internals.unmatched(failures, error);\n};\ninternals.unmatched = function(failures, error) {\n    const errors = [];\n    for (const failure of failures){\n        errors.push(...failure.reports);\n    }\n    return {\n        errors: error(\"alternatives.match\", Errors.details(errors, {\n            override: false\n        }))\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUV0QixNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQztBQUNwQixNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQztBQUN4QixNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNTSxNQUFNTixtQkFBT0EsQ0FBQztBQUdwQixNQUFNTyxZQUFZLENBQUM7QUFHbkJDLE9BQU9DLE9BQU8sR0FBR1AsSUFBSVEsTUFBTSxDQUFDO0lBRXhCQyxNQUFNO0lBRU5DLE9BQU87UUFFSEMsT0FBTztZQUFFQyxTQUFTO1FBQU0sRUFBa0Isc0JBQXNCO0lBQ3BFO0lBRUFDLE9BQU87UUFFSEMsU0FBUztZQUFFQyxNQUFNLEVBQUU7WUFBRUMsVUFBVVosSUFBSWEsU0FBUztRQUFDO0lBQ2pEO0lBRUFDLE1BQUtDLE1BQU0sRUFBRSxHQUFHQyxPQUFPO1FBRW5CLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxHQUFHO1lBQ3RCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsT0FBTyxDQUFDLEVBQUUsR0FBRztnQkFDM0IsT0FBT0QsT0FBT0ssR0FBRyxJQUFJSixPQUFPLENBQUMsRUFBRTtZQUNuQztRQUNKO1FBRUEsT0FBT0QsT0FBT0ssR0FBRyxJQUFJSjtJQUN6QjtJQUVBSyxVQUFTQyxLQUFLLEVBQUVDLE9BQU87UUFFbkIsTUFBTSxFQUFFUixNQUFNLEVBQUVTLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUUsR0FBR0g7UUFFeEMsbUJBQW1CO1FBRW5CLElBQUlSLE9BQU9ZLE1BQU0sQ0FBQ3BCLEtBQUssRUFBRTtZQUNyQixNQUFNcUIsVUFBVSxFQUFFO1lBQ2xCLE1BQU1DLFNBQVMsRUFBRTtZ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QUcsQ0FBQ3pHO1FBQ2Y7SUFDSjtJQUVBLHNDQUFzQztJQUV0QyxJQUFJLENBQUNrRyxRQUFRdEYsTUFBTSxFQUFFO1FBQ2pCLE9BQU87WUFBRXFCLFFBQVFkLE1BQU0sc0JBQXNCO2dCQUFFd0YsT0FBTzt1QkFBSVg7aUJBQU87WUFBQztRQUFHO0lBQ3pFO0lBRUEsdUJBQXVCO0lBRXZCLElBQUlFLFFBQVF0RixNQUFNLEtBQUssR0FBRztRQUN0QixPQUFPO1lBQUVxQixRQUFRaUUsT0FBTyxDQUFDLEVBQUUsQ0FBQ0UsTUFBTTtRQUFDO0lBQ3ZDO0lBRUEsT0FBT3hHLFVBQVV1RyxTQUFTLENBQUNKLFVBQVU1RTtBQUN6QztBQUdBdkIsVUFBVXVHLFNBQVMsR0FBRyxTQUFVSixRQUFRLEVBQUU1RSxLQUFLO0lBRTNDLE1BQU1jLFNBQVMsRUFBRTtJQUNqQixLQUFLLE1BQU0yRSxXQUFXYixTQUFVO1FBQzVCOUQsT0FBT0MsSUFBSSxJQUFJMEUsUUFBUTNELE9BQU87SUFDbEM7SUFFQSxPQUFPO1FBQUVoQixRQUFRZCxNQUFNLHNCQUFzQnpCLE9BQU80QyxPQUFPLENBQUNMLFFBQVE7WUFBRVEsVUFBVTtRQUFNO0lBQUk7QUFDOUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2FsdGVybmF0aXZlcy5qcz83YTE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL21lcmdlJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYWx0ZXJuYXRpdmVzJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgbWF0Y2g6IHsgZGVmYXVsdDogJ2FueScgfSAgICAgICAgICAgICAgICAgLy8gJ2FueScsICdvbmUnLCAnYWxsJ1xuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIG1hdGNoZXM6IHsgaW5pdDogW10sIHJlZ2lzdGVyOiBSZWYudG9TaWJsaW5nIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIC4uLnNjaGVtYXMpIHtcblxuICAgICAgICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NoZW1hLnRyeSguLi5zY2hlbWFzKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgICAgICAvLyBNYXRjaCBhbGwgb3Igb25lXG5cbiAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MubWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLiRfdGVybXMubWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubmVzdChpdGVtLnNjaGVtYSwgYG1hdGNoLiR7aX1gKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLnNjaGVtYS4kX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkLnB1c2gocmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZmFpbGVkLm1hcCgoZikgPT4gRXJyb3JzLmRldGFpbHMoZiwgeyBvdmVycmlkZTogZmFsc2UgfSkpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknLCBjb250ZXh0KSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYXRjaCBvbmVcblxuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MubWF0Y2ggPT09ICdvbmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQubGVuZ3RoID09PSAxID8geyB2YWx1ZTogbWF0Y2hlZFswXSB9IDogeyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMub25lJykgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2ggYWxsXG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCAhPT0gc2NoZW1hLiRfdGVybXMubWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBmYWlsZWQubWFwKChmKSA9PiBFcnJvcnMuZGV0YWlscyhmLCB7IG92ZXJyaWRlOiBmYWxzZSB9KSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLmFsbCcsIGNvbnRleHQpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlzQW55T2JqID0gKGFsdGVybmF0aXZlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRpdmUuJF90ZXJtcy5tYXRjaGVzLnNvbWUoKHYpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5zY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh2LnNjaGVtYS50eXBlID09PSAnYWx0ZXJuYXRpdmVzJyAmJiBpc0FueU9iaih2LnNjaGVtYSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzQW55T2JqKHNjaGVtYSkgPyB7IHZhbHVlOiBtYXRjaGVkLnJlZHVjZSgoYWNjLCB2KSA9PiBNZXJnZShhY2MsIHYsIHsgbWVyZ2VBcnJheXM6IGZhbHNlIH0pKSB9IDogeyB2YWx1ZTogbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXRjaCBhbnlcblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLiRfdGVybXMubWF0Y2hlc1tpXTtcblxuICAgICAgICAgICAgLy8gVHJ5XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5uZXN0KGl0ZW0uc2NoZW1hLCBgbWF0Y2guJHtpfWApO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uc2NoZW1hLiRfdmFsaWRhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5jb21taXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHNjaGVtYTogaXRlbS5zY2hlbWEsIHJlcG9ydHM6IHJlc3VsdC5lcnJvcnMgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbmRpdGlvbmFsXG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gaXRlbS5yZWYgPyBpdGVtLnJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIDogdmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IGl0ZW0uaXMgPyBbaXRlbV0gOiBpdGVtLnN3aXRjaDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzLCB0aGVuLCBvdGhlcndpc2UgfSA9IHRlc3Q7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGBtYXRjaC4ke2l9JHtpdGVtLnN3aXRjaCA/ICcuJyArIGogOiAnJ31gO1xuICAgICAgICAgICAgICAgIGlmICghaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7aWR9LmlzYCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXJ3aXNlLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3Qob3RoZXJ3aXNlLCBgJHtpZH0ub3RoZXJ3aXNlYCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGVuLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3QodGhlbiwgYCR7aWR9LnRoZW5gKSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3JzKGVycm9ycywgaGVscGVycyk7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29uZGl0aW9uYWw6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MuX2VuZGVkU3dpdGNoLCAnVW5yZWFjaGFibGUgY29uZGl0aW9uJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9mbGFncy5tYXRjaCwgJ0Nhbm5vdCBjb21iaW5lIG1hdGNoIG1vZGUnLCB0aGlzLl9mbGFncy5tYXRjaCwgJ3dpdGggY29uZGl0aW9uYWwgcnVsZScpO1xuICAgICAgICAgICAgICAgIEFzc2VydChvcHRpb25zLmJyZWFrID09PSB1bmRlZmluZWQsICdDYW5ub3QgdXNlIGJyZWFrIG9wdGlvbiB3aXRoIGFsdGVybmF0aXZlcyBjb25kaXRpb25hbCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21waWxlLndoZW4ob2JqLCBjb25kaXRpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBtYXRjaC5pcyA/IFttYXRjaF0gOiBtYXRjaC5zd2l0Y2g7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGhlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vdGhlcndpc2UpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRfc2V0RmxhZygnX2VuZGVkU3dpdGNoJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXRjaDoge1xuICAgICAgICAgICAgbWV0aG9kKG1vZGUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2FueScsICdvbmUnLCAnYWxsJ10uaW5jbHVkZXMobW9kZSksICdJbnZhbGlkIGFsdGVybmF0aXZlcyBtYXRjaCBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPT0gJ2FueScpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiB0aGlzLiRfdGVybXMubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KG1hdGNoLnNjaGVtYSwgJ0Nhbm5vdCBjb21iaW5lIG1hdGNoIG1vZGUnLCBtb2RlLCAnd2l0aCBjb25kaXRpb25hbCBydWxlcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdtYXRjaCcsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWFzLmxlbmd0aCwgJ01pc3NpbmcgYWx0ZXJuYXRpdmUgc2NoZW1hcycpO1xuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICd0cnknKTtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MuX2VuZGVkU3dpdGNoLCAnVW5yZWFjaGFibGUgY29uZGl0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXRjaGVzLnB1c2goeyBzY2hlbWE6IG9iai4kX2NvbXBpbGUoc2NoZW1hKSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG92ZXJyaWRlczoge1xuXG4gICAgICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX3BhcmVudCgnbGFiZWwnLCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgc291cmNlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnBhdGhbMF0gIT09ICdpcycgJiYgdHlwZW9mIGl0ZW0uX2ZsYWdzLmxhYmVsICE9PSAnc3RyaW5nJyA/IGl0ZW0ubGFiZWwobmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gb2JqLiRfbW9kaWZ5KHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWJ1aWxkKHNjaGVtYSkge1xuXG4gICAgICAgIC8vIEZsYWcgd2hlbiBhbiBhbHRlcm5hdGl2ZSB0eXBlIGlzIGFuIGFycmF5XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoaXRlbSkgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09ICdhcnJheScpIHtcblxuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3NldEZsYWcoJ19hcnJheUl0ZW1zJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NoZW1hLiRfbW9kaWZ5KHsgZWFjaCB9KTtcbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZGVzYy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCByZWYsIGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnkoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChyZWYsIHsgaXMsIHRoZW4sIG5vdCwgb3RoZXJ3aXNlLCBzd2l0Y2g6IG1hdGNoLnN3aXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChpcywgeyB0aGVuLCBvdGhlcndpc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbGwnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbGwgb2YgdGhlIHJlcXVpcmVkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbnknOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYWx0ZXJuYXRpdmVzLm1hdGNoJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5vbmUnOiAne3sjbGFiZWx9fSBtYXRjaGVzIG1vcmUgdGhhbiBvbmUgYWxsb3dlZCB0eXBlJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy50eXBlcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgb25lIG9mIHt7I3R5cGVzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZXJyb3JzID0gZnVuY3Rpb24gKGZhaWx1cmVzLCB7IGVycm9yLCBzdGF0ZSB9KSB7XG5cbiAgICAvLyBOb3RoaW5nIG1hdGNoZWQgZHVlIHRvIHR5cGUgY3JpdGVyaWEgcnVsZXNcblxuICAgIGlmICghZmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknKSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBlcnJvclxuXG4gICAgaWYgKGZhaWx1cmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGZhaWx1cmVzWzBdLnJlcG9ydHMgfTtcbiAgICB9XG5cbiAgICAvLyBBbmFseXplIHJlYXNvbnNcblxuICAgIGNvbnN0IHZhbGlkcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBjb21wbGV4ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHsgcmVwb3J0cywgc2NoZW1hIH0gb2YgZmFpbHVyZXMpIHtcblxuICAgICAgICAvLyBNdWx0aXBsZSBlcnJvcnMgKCFhYm9ydEVhcmx5KVxuXG4gICAgICAgIGlmIChyZXBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gZXJyb3JcblxuICAgICAgICBjb25zdCByZXBvcnQgPSByZXBvcnRzWzBdO1xuICAgICAgICBpZiAocmVwb3J0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcm5hbCBvYmplY3Qgb3IgYXJyYXkgZXJyb3JcblxuICAgICAgICBpZiAocmVwb3J0LnN0YXRlLnBhdGgubGVuZ3RoICE9PSBzdGF0ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcGxleC5wdXNoKHsgdHlwZTogc2NoZW1hLnR5cGUsIHJlcG9ydCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRzXG5cbiAgICAgICAgaWYgKHJlcG9ydC5jb2RlID09PSAnYW55Lm9ubHknKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkIG9mIHJlcG9ydC5sb2NhbC52YWxpZHMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZHMuYWRkKHZhbGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlIHR5cGVcblxuICAgICAgICBjb25zdCBbdHlwZSwgY29kZV0gPSByZXBvcnQuY29kZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY29kZSAhPT0gJ2Jhc2UnKSB7XG4gICAgICAgICAgICBjb21wbGV4LnB1c2goeyB0eXBlOiBzY2hlbWEudHlwZSwgcmVwb3J0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcG9ydC5jb2RlID09PSAnb2JqZWN0LmJhc2UnKSB7XG4gICAgICAgICAgICB2YWxpZHMuYWRkKHJlcG9ydC5sb2NhbC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkcy5hZGQodHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGwgZXJyb3JzIGFyZSBiYXNlIHR5cGVzIG9yIHZhbGlkc1xuXG4gICAgaWYgKCFjb21wbGV4Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMudHlwZXMnLCB7IHR5cGVzOiBbLi4udmFsaWRzXSB9KSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBjb21wbGV4IGVycm9yXG5cbiAgICBpZiAoY29tcGxleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBjb21wbGV4WzBdLnJlcG9ydCB9O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG59O1xuXG5cbmludGVybmFscy51bm1hdGNoZWQgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIGVycm9yKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4uZmFpbHVyZS5yZXBvcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMubWF0Y2gnLCBFcnJvcnMuZGV0YWlscyhlcnJvcnMsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pKSB9O1xufTtcbiJdLCJuYW1lcyI6WyJBc3NlcnQiLCJyZXF1aXJlIiwiTWVyZ2UiLCJBbnkiLCJDb21tb24iLCJDb21waWxlIiwiRXJyb3JzIiwiUmVmIiwiaW50ZXJuYWxzIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4dGVuZCIsInR5cGUiLCJmbGFncyIsIm1hdGNoIiwiZGVmYXVsdCIsInRlcm1zIiwibWF0Y2hlcyIsImluaXQiLCJyZWdpc3RlciIsInRvU2libGluZyIsImFyZ3MiLCJzY2hlbWEiLCJzY2hlbWFzIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwidHJ5IiwidmFsaWRhdGUiLCJ2YWx1ZSIsImhlbHBlcnMiLCJlcnJvciIsInN0YXRlIiwicHJlZnMiLCJfZmxhZ3MiLCJtYXRjaGVkIiwiZmFpbGVkIiwiaSIsIiRfdGVybXMiLCJpdGVtIiwibG9jYWxTdGF0ZSIsIm5lc3QiLCJzbmFwc2hvdCIsInJlc3VsdCIsIiRfdmFsaWRhdGUiLCJlcnJvcnMiLCJwdXNoIiwiY29tbWl0IiwicmVzdG9yZSIsImNvbnRleHQiLCJkZXRhaWxzIiwibWFwIiwiZiIsIm92ZXJyaWRlIiwiaXNBbnlPYmoiLCJhbHRlcm5hdGl2ZSIsInNvbWUiLCJ2IiwicmVkdWNlIiwiYWNjIiwibWVyZ2VBcnJheXMiLCJyZXBvcnRzIiwiaW5wdXQiLCJyZWYiLCJyZXNvbHZlIiwidGVzdHMiLCJpcyIsInN3aXRjaCIsImoiLCJ0ZXN0IiwidGhlbiIsIm90aGVyd2lzZSIsImlkIiwiJF9tYXRjaCIsInJ1bGVzIiwiY29uZGl0aW9uYWwiLCJtZXRob2QiLCJjb25kaXRpb24iLCJvcHRpb25zIiwiX2VuZGVkU3dpdGNoIiwiYnJlYWsiLCJ1bmRlZmluZWQiLCJvYmoiLCJjbG9uZSIsIndoZW4iLCJjb25kaXRpb25zIiwiJF9zZXRGbGFnIiwiJF9tdXRhdGVSZWJ1aWxkIiwibW9kZSIsImluY2x1ZGVzIiwidmVyaWZ5RmxhdCIsIiRfY29tcGlsZSIsIm92ZXJyaWRlcyIsImxhYmVsIiwibmFtZSIsIiRfcGFyZW50IiwiZWFjaCIsInNvdXJjZSIsInBhdGgiLCIkX21vZGlmeSIsInJlYnVpbGQiLCJpc1NjaGVtYSIsIm1hbmlmZXN0IiwiYnVpbGQiLCJkZXNjIiwibm90IiwibWVzc2FnZXMiLCJmYWlsdXJlcyIsInZhbGlkcyIsIlNldCIsImNvbXBsZXgiLCJ1bm1hdGNoZWQiLCJyZXBvcnQiLCJSZXBvcnQiLCJjb2RlIiwidmFsaWQiLCJsb2NhbCIsImFkZCIsInNwbGl0IiwidHlwZXMiLCJmYWlsdXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/alternatives.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/any.js":
/*!*******************************************!*\
  !*** ./node_modules/joi/lib/types/any.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Base = __webpack_require__(/*! ../base */ \"(rsc)/./node_modules/joi/lib/base.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Messages = __webpack_require__(/*! ../messages */ \"(rsc)/./node_modules/joi/lib/messages.js\");\nconst internals = {};\nmodule.exports = Base.extend({\n    type: \"any\",\n    flags: {\n        only: {\n            default: false\n        }\n    },\n    terms: {\n        alterations: {\n            init: null\n        },\n        examples: {\n            init: null\n        },\n        externals: {\n            init: null\n        },\n        metas: {\n            init: []\n        },\n        notes: {\n            init: []\n        },\n        shared: {\n            init: null\n        },\n        tags: {\n            init: []\n        },\n        whens: {\n            init: null\n        }\n    },\n    rules: {\n        custom: {\n            method (method, description) {\n                Assert(typeof method === \"function\", \"Method must be a function\");\n                Assert(description === undefined || description && typeof description === \"string\", \"Description must be a non-empty string\");\n                return this.$_addRule({\n                    name: \"custom\",\n                    args: {\n                        method,\n                        description\n                    }\n                });\n            },\n            validate (value, helpers, { method }) {\n                try {\n                    return method(value, helpers);\n                } catch (err) {\n                    return helpers.error(\"any.custom\", {\n                        error: err\n                    });\n                }\n            },\n            args: [\n                \"method\",\n                \"description\"\n            ],\n            multi: true\n        },\n        messages: {\n            method (messages) {\n                return this.prefs({\n                    messages\n                });\n            }\n        },\n        shared: {\n            method (schema) {\n                Assert(Common.isSchema(schema) && schema._flags.id, \"Schema must be a schema with an id\");\n                const obj = this.clone();\n                obj.$_terms.shared = obj.$_terms.shared || [];\n                obj.$_terms.shared.push(schema);\n                obj.$_mutateRegister(schema);\n                return obj;\n            }\n        },\n        warning: {\n            method (code, local) {\n                Assert(code && typeof code === \"string\", \"Invalid warning code\");\n                return this.$_addRule({\n                    name: \"warning\",\n                    args: {\n                        code,\n                        local\n                    },\n                    warn: true\n                });\n            },\n            validate (value, helpers, { code, local }) {\n                return helpers.error(code, local);\n            },\n            args: [\n                \"code\",\n                \"local\"\n            ],\n            multi: true\n        }\n    },\n    modifiers: {\n        keep (rule, enabled = true) {\n            rule.keep = enabled;\n        },\n        message (rule, message) {\n            rule.message = Messages.compile(message);\n        },\n        warn (rule, enabled = true) {\n            rule.warn = enabled;\n        }\n    },\n    manifest: {\n        build (obj, desc) {\n            for(const key in desc){\n                const values = desc[key];\n                if ([\n                    \"examples\",\n                    \"externals\",\n                    \"metas\",\n                    \"notes\",\n                    \"tags\"\n                ].includes(key)) {\n                    for (const value of values){\n                        obj = obj[key.slice(0, -1)](value);\n                    }\n                    continue;\n                }\n                if (key === \"alterations\") {\n                    const alter = {};\n                    for (const { target, adjuster } of values){\n                        alter[target] = adjuster;\n                    }\n                    obj = obj.alter(alter);\n                    continue;\n                }\n                if (key === \"whens\") {\n                    for (const value of values){\n                        const { ref, is, not, then, otherwise, concat } = value;\n                        if (concat) {\n                            obj = obj.concat(concat);\n                        } else if (ref) {\n                            obj = obj.when(ref, {\n                                is,\n                                not,\n                                then,\n                                otherwise,\n                                switch: value.switch,\n                                break: value.break\n                            });\n                        } else {\n                            obj = obj.when(is, {\n                                then,\n                                otherwise,\n                                break: value.break\n                            });\n                        }\n                    }\n                    continue;\n                }\n                if (key === \"shared\") {\n                    for (const value of values){\n                        obj = obj.shared(value);\n                    }\n                }\n            }\n            return obj;\n        }\n    },\n    messages: {\n        \"any.custom\": \"{{#label}} failed custom validation because {{#error.message}}\",\n        \"any.default\": \"{{#label}} threw an error when running default method\",\n        \"any.failover\": \"{{#label}} threw an error when running failover method\",\n        \"any.invalid\": \"{{#label}} contains an invalid value\",\n        \"any.only\": '{{#label}} must be {if(#valids.length == 1, \"\", \"one of \")}{{#valids}}',\n        \"any.ref\": \"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}\",\n        \"any.required\": \"{{#label}} is required\",\n        \"any.unknown\": \"{{#label}} is not allowed\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUV2QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUN2QixNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQztBQUd6QixNQUFNSSxZQUFZLENBQUM7QUFHbkJDLE9BQU9DLE9BQU8sR0FBR0wsS0FBS00sTUFBTSxDQUFDO0lBRXpCQyxNQUFNO0lBRU5DLE9BQU87UUFFSEMsTUFBTTtZQUFFQyxTQUFTO1FBQU07SUFDM0I7SUFFQUMsT0FBTztRQUVIQyxhQUFhO1lBQUVDLE1BQU07UUFBSztRQUMxQkMsVUFBVTtZQUFFRCxNQUFNO1FBQUs7UUFDdkJFLFdBQVc7WUFBRUYsTUFBTTtRQUFLO1FBQ3hCRyxPQUFPO1lBQUVILE1BQU0sRUFBRTtRQUFDO1FBQ2xCSSxPQUFPO1lBQUVKLE1BQU0sRUFBRTtRQUFDO1FBQ2xCSyxRQUFRO1lBQUVMLE1BQU07UUFBSztRQUNyQk0sTUFBTTtZQUFFTixNQUFNLEVBQUU7UUFBQztRQUNqQk8sT0FBTztZQUFFUCxNQUFNO1FBQUs7SUFDeEI7SUFFQVEsT0FBTztRQUVIQyxRQUFRO1lBQ0pDLFFBQU9BLE1BQU0sRUFBRUMsV0FBVztnQkFFdEIxQixPQUFPLE9BQU95QixXQUFXLFlBQVk7Z0JBQ3JDekIsT0FBTzBCLGdCQUFnQkMsYUFBYUQsZUFBZSxPQUFPQSxnQkFBZ0IsVUFBVTtnQkFFcEYsT0FBTyxJQUFJLENBQUNFLFNBQVMsQ0FBQztvQkFBRUMsTUFBTTtvQkFBVUMsTUFBTTt3QkFBRUw7d0JBQVFDO29CQUFZO2dCQUFFO1lBQzFFO1lBQ0FLLFVBQVNDLEtBQUssRUFBRUMsT0FBTyxFQUFFLEVBQUVSLE1BQU0sRUFBRTtnQkFFL0IsSUFBSTtvQkFDQSxPQUFPQSxPQUFPTyxPQUFPQztnQkFDekIsRUFDQSxPQUFPQyxL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QU1DO2dDQUFXRyxRQUFRM0MsTUFBTTJDLE1BQU07Z0NBQUVDLE9BQU81QyxNQUFNNEMsS0FBSzs0QkFBQzt3QkFDN0YsT0FDSzs0QkFDRGpDLE1BQU1BLElBQUkrQixJQUFJLENBQUNMLElBQUk7Z0NBQUVFO2dDQUFNQztnQ0FBV0ksT0FBTzVDLE1BQU00QyxLQUFLOzRCQUFDO3dCQUM3RDtvQkFDSjtvQkFFQTtnQkFDSjtnQkFFQSxJQUFJZixRQUFRLFVBQVU7b0JBQ2xCLEtBQUssTUFBTTdCLFNBQVM4QixPQUFRO3dCQUN4Qm5CLE1BQU1BLElBQUl2QixNQUFNLENBQUNZO29CQUNyQjtnQkFDSjtZQUNKO1lBRUEsT0FBT1c7UUFDWDtJQUNKO0lBRUFOLFVBQVU7UUFDTixjQUFjO1FBQ2QsZUFBZTtRQUNmLGdCQUFnQjtRQUNoQixlQUFlO1FBQ2YsWUFBWTtRQUNaLFdBQVc7UUFDWCxnQkFBZ0I7UUFDaEIsZUFBZTtJQUNuQjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hbnkuanM/ODhmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4uL21lc3NhZ2VzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYW55JyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgb25seTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgYWx0ZXJhdGlvbnM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBleGFtcGxlczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIGV4dGVybmFsczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIG1ldGFzOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIG5vdGVzOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIHNoYXJlZDogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIHRhZ3M6IHsgaW5pdDogW10gfSxcbiAgICAgICAgd2hlbnM6IHsgaW5pdDogbnVsbCB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBtZXRob2QobWV0aG9kLCBkZXNjcmlwdGlvbikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicsICdNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRpb24gJiYgdHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJywgJ0Rlc2NyaXB0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnY3VzdG9tJywgYXJnczogeyBtZXRob2QsIGRlc2NyaXB0aW9uIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbWV0aG9kIH0pIHtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdhbnkuY3VzdG9tJywgeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ21ldGhvZCcsICdkZXNjcmlwdGlvbiddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgbWV0aG9kKG1lc3NhZ2VzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVmcyh7IG1lc3NhZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNoYXJlZDoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShzY2hlbWEpICYmIHNjaGVtYS5fZmxhZ3MuaWQsICdTY2hlbWEgbXVzdCBiZSBhIHNjaGVtYSB3aXRoIGFuIGlkJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuc2hhcmVkID0gb2JqLiRfdGVybXMuc2hhcmVkIHx8IFtdO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnNoYXJlZC5wdXNoKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb2RlLCBsb2NhbCkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGNvZGUgJiYgdHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnLCAnSW52YWxpZCB3YXJuaW5nIGNvZGUnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICd3YXJuaW5nJywgYXJnczogeyBjb2RlLCBsb2NhbCB9LCB3YXJuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGNvZGUsIGxvY2FsIH0pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGNvZGUsIGxvY2FsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvZGUnLCAnbG9jYWwnXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW9kaWZpZXJzOiB7XG5cbiAgICAgICAga2VlcChydWxlLCBlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBydWxlLmtlZXAgPSBlbmFibGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lc3NhZ2UocnVsZSwgbWVzc2FnZSkge1xuXG4gICAgICAgICAgICBydWxlLm1lc3NhZ2UgPSBNZXNzYWdlcy5jb21waWxlKG1lc3NhZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdhcm4ocnVsZSwgZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgcnVsZS53YXJuID0gZW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZGVzY1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKFsnZXhhbXBsZXMnLCAnZXh0ZXJuYWxzJywgJ21ldGFzJywgJ25vdGVzJywgJ3RhZ3MnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmpba2V5LnNsaWNlKDAsIC0xKV0odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2FsdGVyYXRpb25zJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHRlciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0LCBhZGp1c3RlciB9IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJbdGFyZ2V0XSA9IGFkanVzdGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLmFsdGVyKGFsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3doZW5zJykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWYsIGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSwgY29uY2F0IH0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25jYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouY29uY2F0KGNvbmNhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoud2hlbihyZWYsIHsgaXMsIG5vdCwgdGhlbiwgb3RoZXJ3aXNlLCBzd2l0Y2g6IHZhbHVlLnN3aXRjaCwgYnJlYWs6IHZhbHVlLmJyZWFrIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLndoZW4oaXMsIHsgdGhlbiwgb3RoZXJ3aXNlLCBicmVhazogdmFsdWUuYnJlYWsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnc2hhcmVkJykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnNoYXJlZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FueS5jdXN0b20nOiAne3sjbGFiZWx9fSBmYWlsZWQgY3VzdG9tIHZhbGlkYXRpb24gYmVjYXVzZSB7eyNlcnJvci5tZXNzYWdlfX0nLFxuICAgICAgICAnYW55LmRlZmF1bHQnOiAne3sjbGFiZWx9fSB0aHJldyBhbiBlcnJvciB3aGVuIHJ1bm5pbmcgZGVmYXVsdCBtZXRob2QnLFxuICAgICAgICAnYW55LmZhaWxvdmVyJzogJ3t7I2xhYmVsfX0gdGhyZXcgYW4gZXJyb3Igd2hlbiBydW5uaW5nIGZhaWxvdmVyIG1ldGhvZCcsXG4gICAgICAgICdhbnkuaW52YWxpZCc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGFuIGludmFsaWQgdmFsdWUnLFxuICAgICAgICAnYW55Lm9ubHknOiAne3sjbGFiZWx9fSBtdXN0IGJlIHtpZigjdmFsaWRzLmxlbmd0aCA9PSAxLCBcIlwiLCBcIm9uZSBvZiBcIil9e3sjdmFsaWRzfX0nLFxuICAgICAgICAnYW55LnJlZic6ICd7eyNsYWJlbH19IHt7I2FyZ319IHJlZmVyZW5jZXMge3s6I3JlZn19IHdoaWNoIHt7I3JlYXNvbn19JyxcbiAgICAgICAgJ2FueS5yZXF1aXJlZCc6ICd7eyNsYWJlbH19IGlzIHJlcXVpcmVkJyxcbiAgICAgICAgJ2FueS51bmtub3duJzogJ3t7I2xhYmVsfX0gaXMgbm90IGFsbG93ZWQnXG4gICAgfVxufSk7XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkJhc2UiLCJDb21tb24iLCJNZXNzYWdlcyIsImludGVybmFscyIsIm1vZHVsZSIsImV4cG9ydHMiLCJleHRlbmQiLCJ0eXBlIiwiZmxhZ3MiLCJvbmx5IiwiZGVmYXVsdCIsInRlcm1zIiwiYWx0ZXJhdGlvbnMiLCJpbml0IiwiZXhhbXBsZXMiLCJleHRlcm5hbHMiLCJtZXRhcyIsIm5vdGVzIiwic2hhcmVkIiwidGFncyIsIndoZW5zIiwicnVsZXMiLCJjdXN0b20iLCJtZXRob2QiLCJkZXNjcmlwdGlvbiIsInVuZGVmaW5lZCIsIiRfYWRkUnVsZSIsIm5hbWUiLCJhcmdzIiwidmFsaWRhdGUiLCJ2YWx1ZSIsImhlbHBlcnMiLCJlcnIiLCJlcnJvciIsIm11bHRpIiwibWVzc2FnZXMiLCJwcmVmcyIsInNjaGVtYSIsImlzU2NoZW1hIiwiX2ZsYWdzIiwiaWQiLCJvYmoiLCJjbG9uZSIsIiRfdGVybXMiLCJwdXNoIiwiJF9tdXRhdGVSZWdpc3RlciIsIndhcm5pbmciLCJjb2RlIiwibG9jYWwiLCJ3YXJuIiwibW9kaWZpZXJzIiwia2VlcCIsInJ1bGUiLCJlbmFibGVkIiwibWVzc2FnZSIsImNvbXBpbGUiLCJtYW5pZmVzdCIsImJ1aWxkIiwiZGVzYyIsImtleSIsInZhbHVlcyIsImluY2x1ZGVzIiwic2xpY2UiLCJhbHRlciIsInRhcmdldCIsImFkanVzdGVyIiwicmVmIiwiaXMiLCJub3QiLCJ0aGVuIiwib3RoZXJ3aXNlIiwiY29uY2F0Iiwid2hlbiIsInN3aXRjaCIsImJyZWFrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/any.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/array.js":
/*!*********************************************!*\
  !*** ./node_modules/joi/lib/types/array.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"(rsc)/./node_modules/@hapi/hoek/lib/deepEqual.js\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"(rsc)/./node_modules/@hapi/hoek/lib/reach.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst internals = {};\nmodule.exports = Any.extend({\n    type: \"array\",\n    flags: {\n        single: {\n            default: false\n        },\n        sparse: {\n            default: false\n        }\n    },\n    terms: {\n        items: {\n            init: [],\n            manifest: \"schema\"\n        },\n        ordered: {\n            init: [],\n            manifest: \"schema\"\n        },\n        _exclusions: {\n            init: []\n        },\n        _inclusions: {\n            init: []\n        },\n        _requireds: {\n            init: []\n        }\n    },\n    coerce: {\n        from: \"object\",\n        method (value, { schema, state, prefs }) {\n            if (!Array.isArray(value)) {\n                return;\n            }\n            const sort = schema.$_getRule(\"sort\");\n            if (!sort) {\n                return;\n            }\n            return internals.sort(schema, value, sort.args.options, state, prefs);\n        }\n    },\n    validate (value, { schema, error }) {\n        if (!Array.isArray(value)) {\n            if (schema._flags.single) {\n                const single = [\n                    value\n                ];\n                single[Common.symbols.arraySingle] = true;\n                return {\n                    value: single\n                };\n            }\n            return {\n                errors: error(\"array.base\")\n            };\n        }\n        if (!schema.$_getRule(\"items\") && !schema.$_terms.externals) {\n            return;\n        }\n        return {\n            value: value.slice()\n        }; // Clone the array so that we don't modify the original\n    },\n    rules: {\n        has: {\n            method (schema) {\n                schema = this.$_compile(schema, {\n                    appendPath: true\n                });\n                const obj = this.$_addRule({\n                    name: \"has\",\n                    args: {\n                        schema\n                    }\n                });\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate (value, { state, prefs, error }, { schema: has }) {\n                const ancestors = [\n                    value,\n                    ...state.ancestors\n                ];\n                for(let i = 0; i < value.length; ++i){\n                    const localState = state.localize([\n                        ...state.path,\n                        i\n                    ], ancestors, has);\n                    if (has.$_match(value[i], localState, prefs)) {\n                        return value;\n                    }\n                }\n                const patternLabel = has._flags.label;\n                if (patternLabel) {\n                    return error(\"array.hasKnown\", {\n                        patternLabel\n                    });\n                }\n                return error(\"array.hasUnknown\", null);\n            },\n            multi: true\n        },\n        items: {\n            method (...schemas) {\n                Common.verifyFlat(schemas, \"items\");\n                const obj = this.$_addRule(\"items\");\n                for(let i = 0; i < schemas.length; ++i){\n                    const type = Common.tryWithPath(()=>this.$_compile(schemas[i]), i, {\n                        append: true\n                    });\n                    obj.$_terms.items.push(type);\n                }\n                return obj.$_mutateRebuild();\n            },\n            validate (value, { schema, error, state, prefs, errorsArray }) {\n                const requireds = schema.$_terms._requireds.slice();\n                const ordereds = schema.$_terms.ordered.slice();\n                const inclusions = [\n                    ...schema.$_terms._inclusions,\n                    ...requireds\n                ];\n                const wasArray = !value[Common.symbols.arraySingle];\n                delete value[Common.symbols.arraySingle];\n                const errors = errorsArray();\n                let il = value.length;\n                for(let i = 0; i < il; ++i){\n                    const item = value[i];\n                    let errored = false;\n                    let isValid = false;\n                    const key = wasArray ? i : new Number(i); // eslint-disable-line no-new-wrappers\n                    const path = [\n                        ...state.path,\n                        key\n                    ];\n                    // Sparse\n                    if (!schema._flags.sparse && item === undefined) {\n                        errors.push(error(\"array.sparse\", {\n                            key,\n                            path,\n                            pos: i,\n                            value: undefined\n                        }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n                        ordereds.shift();\n                        continue;\n                    }\n                    // Exclusions\n                    const ancestors = [\n                        value,\n                        ...state.ancestors\n                    ];\n                    for (const exclusion of schema.$_terms._exclusions){\n                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, {\n                            presence: \"ignore\"\n                        })) {\n                            continue;\n                        }\n                        errors.push(error(\"array.excludes\", {\n                            pos: i,\n                            value: item\n                        }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n                        errored = true;\n                        ordereds.shift();\n                        break;\n                    }\n                    if (errored) {\n                        continue;\n                    }\n                    // Ordered\n                    if (schema.$_terms.ordered.length) {\n                        if (ordereds.length) {\n                            const ordered = ordereds.shift();\n                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);\n                            if (!res.errors) {\n                                if (ordered._flags.result === \"strip\") {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                } else if (!schema._flags.sparse && res.value === undefined) {\n                                    errors.push(error(\"array.sparse\", {\n                                        key,\n                                        path,\n                                        pos: i,\n                                        value: undefined\n                                    }, state.localize(path)));\n                                    if (prefs.abortEarly) {\n                                        return errors;\n                                    }\n                                    continue;\n                                } else {\n                                    value[i] = res.value;\n                                }\n                            } else {\n                                errors.push(...res.errors);\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n                            continue;\n                        } else if (!schema.$_terms.items.length) {\n                            errors.push(error(\"array.orderedLength\", {\n                                pos: i,\n                                limit: schema.$_terms.ordered.length\n                            }));\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n                            break; // No reason to continue since there are no other rules to validate other than array.orderedLength\n                        }\n                    }\n                    // Requireds\n                    const requiredChecks = [];\n                    let jl = requireds.length;\n                    for(let j = 0; j < jl; ++j){\n                        const localState = state.localize(path, ancestors, requireds[j]);\n                        localState.snapshot();\n                        const res = requireds[j].$_validate(item, localState, prefs);\n                        requiredChecks[j] = res;\n                        if (!res.errors) {\n                            localState.commit();\n                            value[i] = res.value;\n                            isValid = true;\n                            internals.fastSplice(requireds, j);\n                            --j;\n                            --jl;\n                            if (!schema._flags.sparse && res.value === undefined) {\n                                errors.push(error(\"array.sparse\", {\n                                    key,\n                                    path,\n                                    pos: i,\n                                    value: undefined\n                                }, state.localize(path)));\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n                            break;\n                        }\n                        localState.restore();\n                    }\n                    if (isValid) {\n                        continue;\n                    }\n                    // Inclusions\n                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;\n                    jl = inclusions.length;\n                    for (const inclusion of inclusions){\n                        // Avoid re-running requireds that already didn't match in the previous loop\n                        let res;\n                        const previousCheck = requireds.indexOf(inclusion);\n                        if (previousCheck !== -1) {\n                            res = requiredChecks[previousCheck];\n                        } else {\n                            const localState = state.localize(path, ancestors, inclusion);\n                            localState.snapshot();\n                            res = inclusion.$_validate(item, localState, prefs);\n                            if (!res.errors) {\n                                localState.commit();\n                                if (inclusion._flags.result === \"strip\") {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                } else if (!schema._flags.sparse && res.value === undefined) {\n                                    errors.push(error(\"array.sparse\", {\n                                        key,\n                                        path,\n                                        pos: i,\n                                        value: undefined\n                                    }, state.localize(path)));\n                                    errored = true;\n                                } else {\n                                    value[i] = res.value;\n                                }\n                                isValid = true;\n                                break;\n                            }\n                            localState.restore();\n                        }\n                        // Return the actual error if only one inclusion defined\n                        if (jl === 1) {\n                            if (stripUnknown) {\n                                internals.fastSplice(value, i);\n                                --i;\n                                --il;\n                                isValid = true;\n                                break;\n                            }\n                            errors.push(...res.errors);\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n                            errored = true;\n                            break;\n                        }\n                    }\n                    if (errored) {\n                        continue;\n                    }\n                    if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) && !isValid) {\n                        if (stripUnknown) {\n                            internals.fastSplice(value, i);\n                            --i;\n                            --il;\n                            continue;\n                        }\n                        errors.push(error(\"array.includes\", {\n                            pos: i,\n                            value: item\n                        }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n                    }\n                }\n                if (requireds.length) {\n                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);\n                }\n                if (ordereds.length) {\n                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);\n                    if (!errors.length) {\n                        internals.fillDefault(ordereds, value, state, prefs);\n                    }\n                }\n                return errors.length ? errors : value;\n            },\n            priority: true,\n            manifest: false\n        },\n        length: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \"=\"\n                });\n            },\n            validate (value, helpers, { limit }, { name, operator, args }) {\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n                return helpers.error(\"array.\" + name, {\n                    limit: args.limit,\n                    value\n                });\n            },\n            args: [\n                {\n                    name: \"limit\",\n                    ref: true,\n                    assert: Common.limit,\n                    message: \"must be a positive integer\"\n                }\n            ]\n        },\n        max: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"max\",\n                    method: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \"<=\"\n                });\n            }\n        },\n        min: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"min\",\n                    method: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \">=\"\n                });\n            }\n        },\n        ordered: {\n            method (...schemas) {\n                Common.verifyFlat(schemas, \"ordered\");\n                const obj = this.$_addRule(\"items\");\n                for(let i = 0; i < schemas.length; ++i){\n                    const type = Common.tryWithPath(()=>this.$_compile(schemas[i]), i, {\n                        append: true\n                    });\n                    internals.validateSingle(type, obj);\n                    obj.$_mutateRegister(type);\n                    obj.$_terms.ordered.push(type);\n                }\n                return obj.$_mutateRebuild();\n            }\n        },\n        single: {\n            method (enabled) {\n                const value = enabled === undefined ? true : !!enabled;\n                Assert(!value || !this._flags._arrayItems, \"Cannot specify single rule when array has array items\");\n                return this.$_setFlag(\"single\", value);\n            }\n        },\n        sort: {\n            method (options = {}) {\n                Common.assertOptions(options, [\n                    \"by\",\n                    \"order\"\n                ]);\n                const settings = {\n                    order: options.order || \"ascending\"\n                };\n                if (options.by) {\n                    settings.by = Compile.ref(options.by, {\n                        ancestor: 0\n                    });\n                    Assert(!settings.by.ancestor, \"Cannot sort by ancestor\");\n                }\n                return this.$_addRule({\n                    name: \"sort\",\n                    args: {\n                        options: settings\n                    }\n                });\n            },\n            validate (value, { error, state, prefs, schema }, { options }) {\n                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);\n                if (errors) {\n                    return errors;\n                }\n                for(let i = 0; i < value.length; ++i){\n                    if (value[i] !== sorted[i]) {\n                        return error(\"array.sort\", {\n                            order: options.order,\n                            by: options.by ? options.by.key : \"value\"\n                        });\n                    }\n                }\n                return value;\n            },\n            convert: true\n        },\n        sparse: {\n            method (enabled) {\n                const value = enabled === undefined ? true : !!enabled;\n                if (this._flags.sparse === value) {\n                    return this;\n                }\n                const obj = value ? this.clone() : this.$_addRule(\"items\");\n                return obj.$_setFlag(\"sparse\", value, {\n                    clone: false\n                });\n            }\n        },\n        unique: {\n            method (comparator, options = {}) {\n                Assert(!comparator || typeof comparator === \"function\" || typeof comparator === \"string\", \"comparator must be a function or a string\");\n                Common.assertOptions(options, [\n                    \"ignoreUndefined\",\n                    \"separator\"\n                ]);\n                const rule = {\n                    name: \"unique\",\n                    args: {\n                        options,\n                        comparator\n                    }\n                };\n                if (comparator) {\n                    if (typeof comparator === \"string\") {\n                        const separator = Common.default(options.separator, \".\");\n                        rule.path = separator ? comparator.split(separator) : [\n                            comparator\n                        ];\n                    } else {\n                        rule.comparator = comparator;\n                    }\n                }\n                return this.$_addRule(rule);\n            },\n            validate (value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {\n                const found = {\n                    string: Object.create(null),\n                    number: Object.create(null),\n                    undefined: Object.create(null),\n                    boolean: Object.create(null),\n                    bigint: Object.create(null),\n                    object: new Map(),\n                    function: new Map(),\n                    custom: new Map()\n                };\n                const compare = comparator || DeepEqual;\n                const ignoreUndefined = options.ignoreUndefined;\n                for(let i = 0; i < value.length; ++i){\n                    const item = path ? Reach(value[i], path) : value[i];\n                    const records = comparator ? found.custom : found[typeof item];\n                    Assert(records, \"Failed to find unique map container for type\", typeof item);\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while(!(current = entries.next()).done){\n                            if (compare(current.value[0], item)) {\n                                const localState = state.localize([\n                                    ...state.path,\n                                    i\n                                ], [\n                                    value,\n                                    ...state.ancestors\n                                ]);\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n                                if (path) {\n                                    context.path = raw;\n                                }\n                                return error(\"array.unique\", context, localState);\n                            }\n                        }\n                        records.set(item, i);\n                    } else {\n                        if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n                            if (path) {\n                                context.path = raw;\n                            }\n                            const localState = state.localize([\n                                ...state.path,\n                                i\n                            ], [\n                                value,\n                                ...state.ancestors\n                            ]);\n                            return error(\"array.unique\", context, localState);\n                        }\n                        records[item] = i;\n                    }\n                }\n                return value;\n            },\n            args: [\n                \"comparator\",\n                \"options\"\n            ],\n            multi: true\n        }\n    },\n    cast: {\n        set: {\n            from: Array.isArray,\n            to (value, helpers) {\n                return new Set(value);\n            }\n        }\n    },\n    rebuild (schema) {\n        schema.$_terms._inclusions = [];\n        schema.$_terms._exclusions = [];\n        schema.$_terms._requireds = [];\n        for (const type of schema.$_terms.items){\n            internals.validateSingle(type, schema);\n            if (type._flags.presence === \"required\") {\n                schema.$_terms._requireds.push(type);\n            } else if (type._flags.presence === \"forbidden\") {\n                schema.$_terms._exclusions.push(type);\n            } else {\n                schema.$_terms._inclusions.push(type);\n            }\n        }\n        for (const type of schema.$_terms.ordered){\n            internals.validateSingle(type, schema);\n        }\n    },\n    manifest: {\n        build (obj, desc) {\n            if (desc.items) {\n                obj = obj.items(...desc.items);\n            }\n            if (desc.ordered) {\n                obj = obj.ordered(...desc.ordered);\n            }\n            return obj;\n        }\n    },\n    messages: {\n        \"array.base\": \"{{#label}} must be an array\",\n        \"array.excludes\": \"{{#label}} contains an excluded value\",\n        \"array.hasKnown\": \"{{#label}} does not contain at least one required match for type {:#patternLabel}\",\n        \"array.hasUnknown\": \"{{#label}} does not contain at least one required match\",\n        \"array.includes\": \"{{#label}} does not match any of the allowed types\",\n        \"array.includesRequiredBoth\": \"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)\",\n        \"array.includesRequiredKnowns\": \"{{#label}} does not contain {{#knownMisses}}\",\n        \"array.includesRequiredUnknowns\": \"{{#label}} does not contain {{#unknownMisses}} required value(s)\",\n        \"array.length\": \"{{#label}} must contain {{#limit}} items\",\n        \"array.max\": \"{{#label}} must contain less than or equal to {{#limit}} items\",\n        \"array.min\": \"{{#label}} must contain at least {{#limit}} items\",\n        \"array.orderedLength\": \"{{#label}} must contain at most {{#limit}} items\",\n        \"array.sort\": \"{{#label}} must be sorted in {#order} order by {{#by}}\",\n        \"array.sort.mismatching\": \"{{#label}} cannot be sorted due to mismatching types\",\n        \"array.sort.unsupported\": \"{{#label}} cannot be sorted due to unsupported type {#type}\",\n        \"array.sparse\": \"{{#label}} must not be a sparse array item\",\n        \"array.unique\": \"{{#label}} contains a duplicate value\"\n    }\n});\n// Helpers\ninternals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {\n    const knownMisses = [];\n    let unknownMisses = 0;\n    for (const required of requireds){\n        const label = required._flags.label;\n        if (label) {\n            knownMisses.push(label);\n        } else {\n            ++unknownMisses;\n        }\n    }\n    if (knownMisses.length) {\n        if (unknownMisses) {\n            errors.push(schema.$_createError(\"array.includesRequiredBoth\", value, {\n                knownMisses,\n                unknownMisses\n            }, state, prefs));\n        } else {\n            errors.push(schema.$_createError(\"array.includesRequiredKnowns\", value, {\n                knownMisses\n            }, state, prefs));\n        }\n    } else {\n        errors.push(schema.$_createError(\"array.includesRequiredUnknowns\", value, {\n            unknownMisses\n        }, state, prefs));\n    }\n};\ninternals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {\n    const requiredOrdereds = [];\n    for (const ordered of ordereds){\n        if (ordered._flags.presence === \"required\") {\n            requiredOrdereds.push(ordered);\n        }\n    }\n    if (requiredOrdereds.length) {\n        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);\n    }\n};\ninternals.fillDefault = function(ordereds, value, state, prefs) {\n    const overrides = [];\n    let trailingUndefined = true;\n    for(let i = ordereds.length - 1; i >= 0; --i){\n        const ordered = ordereds[i];\n        const ancestors = [\n            value,\n            ...state.ancestors\n        ];\n        const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;\n        if (trailingUndefined) {\n            if (override === undefined) {\n                continue;\n            }\n            trailingUndefined = false;\n        }\n        overrides.unshift(override);\n    }\n    if (overrides.length) {\n        value.push(...overrides);\n    }\n};\ninternals.fastSplice = function(arr, i) {\n    let pos = i;\n    while(pos < arr.length){\n        arr[pos++] = arr[pos];\n    }\n    --arr.length;\n};\ninternals.validateSingle = function(type, obj) {\n    if (type.type === \"array\" || type._flags._arrayItems) {\n        Assert(!obj._flags.single, \"Cannot specify array item with single rule enabled\");\n        obj.$_setFlag(\"_arrayItems\", true, {\n            clone: false\n        });\n    }\n};\ninternals.sort = function(schema, value, settings, state, prefs) {\n    const order = settings.order === \"ascending\" ? 1 : -1;\n    const aFirst = -1 * order;\n    const bFirst = order;\n    const sort = (a, b)=>{\n        let compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n        if (settings.by) {\n            a = settings.by.resolve(a, state, prefs);\n            b = settings.by.resolve(b, state, prefs);\n        }\n        compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n        const type = typeof a;\n        if (type !== typeof b) {\n            throw schema.$_createError(\"array.sort.mismatching\", value, null, state, prefs);\n        }\n        if (type !== \"number\" && type !== \"string\") {\n            throw schema.$_createError(\"array.sort.unsupported\", value, {\n                type\n            }, state, prefs);\n        }\n        if (type === \"number\") {\n            return (a - b) * order;\n        }\n        return a < b ? aFirst : bFirst;\n    };\n    try {\n        return {\n            value: value.slice().sort(sort)\n        };\n    } catch (err) {\n        return {\n            errors: err\n        };\n    }\n};\ninternals.compare = function(a, b, aFirst, bFirst) {\n    if (a === b) {\n        return 0;\n    }\n    if (a === undefined) {\n        return 1; // Always last regardless of sort order\n    }\n    if (b === undefined) {\n        return -1; // Always last regardless of sort order\n    }\n    if (a === null) {\n        return bFirst;\n    }\n    if (b === null) {\n        return aFirst;\n    }\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDO0FBRXRCLE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDO0FBR3hCLE1BQU1NLFlBQVksQ0FBQztBQUduQkMsT0FBT0MsT0FBTyxHQUFHTCxJQUFJTSxNQUFNLENBQUM7SUFFeEJDLE1BQU07SUFFTkMsT0FBTztRQUVIQyxRQUFRO1lBQUVDLFNBQVM7UUFBTTtRQUN6QkMsUUFBUTtZQUFFRCxTQUFTO1FBQU07SUFDN0I7SUFFQUUsT0FBTztRQUVIQyxPQUFPO1lBQUVDLE1BQU0sRUFBRTtZQUFFQyxVQUFVO1FBQVM7UUFDdENDLFNBQVM7WUFBRUYsTUFBTSxFQUFFO1lBQUVDLFVBQVU7UUFBUztRQUV4Q0UsYUFBYTtZQUFFSCxNQUFNLEVBQUU7UUFBQztRQUN4QkksYUFBYTtZQUFFSixNQUFNLEVBQUU7UUFBQztRQUN4QkssWUFBWTtZQUFFTCxNQUFNLEVBQUU7UUFBQztJQUMzQjtJQUVBTSxRQUFRO1FBQ0pDLE1BQU07UUFDTkMsUUFBT0MsS0FBSyxFQUFFLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7WUFFbEMsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNMLFFBQVE7Z0JBQ3ZCO1lBQ0o7WUFFQSxNQUFNTSxPQUFPTCxPQUFPTSxTQUFTLENBQUM7WUFDOUIsSUFBSSxDQUFDRCxNQUFNO2dCQUNQO1lBQ0o7WUFFQSxPQUFPMUIsVUFBVTBCLElBQUksQ0FBQ0wsUUFBUUQsT0FBT00sS0FBS0UsSUFBSSxDQUFDQyxPQUFPLEVBQUVQLE9BQU9DO1FBQ25FO0lBQ0o7SUFF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Q25CLE1BQU1sSixPQUFPd0ksYUFBYSxDQUFDLDBCQUEwQnpJLE9BQU8sTUFBTUUsT0FBT0M7UUFDN0U7UUFFQSxJQUFJbkIsU0FBUyxZQUNUQSxTQUFTLFVBQVU7WUFFbkIsTUFBTWlCLE9BQU93SSxhQUFhLENBQUMsMEJBQTBCekksT0FBTztnQkFBRWhCO1lBQUssR0FBR2tCLE9BQU9DO1FBQ2pGO1FBRUEsSUFBSW5CLFNBQVMsVUFBVTtZQUNuQixPQUFPLENBQUNrSyxJQUFJQyxDQUFBQSxJQUFLckQ7UUFDckI7UUFFQSxPQUFPb0QsSUFBSUMsSUFBSUgsU0FBU0M7SUFDNUI7SUFFQSxJQUFJO1FBQ0EsT0FBTztZQUFFakosT0FBT0EsTUFBTWtCLEtBQUssR0FBR1osSUFBSSxDQUFDQTtRQUFNO0lBQzdDLEVBQ0EsT0FBTytJLEtBQUs7UUFDUixPQUFPO1lBQUV0SSxRQUFRc0k7UUFBSTtJQUN6QjtBQUNKO0FBR0F6SyxVQUFVc0csT0FBTyxHQUFHLFNBQVVnRSxDQUFDLEVBQUVDLENBQUMsRUFBRUgsTUFBTSxFQUFFQyxNQUFNO0lBRTlDLElBQUlDLE1BQU1DLEdBQUc7UUFDVCxPQUFPO0lBQ1g7SUFFQSxJQUFJRCxNQUFNNUYsV0FBVztRQUNqQixPQUFPLEdBQWEsdUNBQXVDO0lBQy9EO0lBRUEsSUFBSTZGLE1BQU03RixXQUFXO1FBQ2pCLE9BQU8sQ0FBQyxHQUFhLHVDQUF1QztJQUNoRTtJQUVBLElBQUk0RixNQUFNLE1BQU07UUFDWixPQUFPRDtJQUNYO0lBRUEsSUFBSUUsTUFBTSxNQUFNO1FBQ1osT0FBT0g7SUFDWDtJQUVBLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvYXJyYXkuanM/Y2FjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdhcnJheScsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHNpbmdsZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICBzcGFyc2U6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGl0ZW1zOiB7IGluaXQ6IFtdLCBtYW5pZmVzdDogJ3NjaGVtYScgfSxcbiAgICAgICAgb3JkZXJlZDogeyBpbml0OiBbXSwgbWFuaWZlc3Q6ICdzY2hlbWEnIH0sXG5cbiAgICAgICAgX2V4Y2x1c2lvbnM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgX2luY2x1c2lvbnM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgX3JlcXVpcmVkczogeyBpbml0OiBbXSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnb2JqZWN0JyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc29ydCA9IHNjaGVtYS4kX2dldFJ1bGUoJ3NvcnQnKTtcbiAgICAgICAgICAgIGlmICghc29ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5zb3J0KHNjaGVtYSwgdmFsdWUsIHNvcnQuYXJncy5vcHRpb25zLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLnNpbmdsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbmdsZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgc2luZ2xlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHNpbmdsZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhcnJheS5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfZ2V0UnVsZSgnaXRlbXMnKSAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKSB9OyAgICAgICAgLy8gQ2xvbmUgdGhlIGFycmF5IHNvIHRoYXQgd2UgZG9uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbFxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGhhczoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gdGhpcy4kX2NvbXBpbGUoc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaGFzJywgYXJnczogeyBzY2hlbWEgfSB9KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgc3RhdGUsIHByZWZzLCBlcnJvciB9LCB7IHNjaGVtYTogaGFzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIGFuY2VzdG9ycywgaGFzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcy4kX21hdGNoKHZhbHVlW2ldLCBsb2NhbFN0YXRlLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5MYWJlbCA9IGhhcy5fZmxhZ3MubGFiZWw7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5MYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5Lmhhc0tub3duJywgeyBwYXR0ZXJuTGFiZWwgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5oYXNVbmtub3duJywgbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICdpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0aGlzLiRfY29tcGlsZShzY2hlbWFzW2ldKSwgaSwgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLml0ZW1zLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMsIGVycm9yc0FycmF5IH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkcyA9IHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkcyA9IHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNsdXNpb25zID0gWy4uLnNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLCAuLi5yZXF1aXJlZHNdO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzQXJyYXkgPSAhdmFsdWVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtDb21tb24uc3ltYm9scy5hcnJheVNpbmdsZV07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBlcnJvcnNBcnJheSgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGlsID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB3YXNBcnJheSA/IGkgOiBuZXcgTnVtYmVyKGkpOyAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gWy4uLnN0YXRlLnBhdGgsIGtleV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3BhcnNlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1c2lvbnNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBleGNsdXNpb24gb2Ygc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhjbHVzaW9uLiRfbWF0Y2goaXRlbSwgc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBleGNsdXNpb24pLCBwcmVmcywgeyBwcmVzZW5jZTogJ2lnbm9yZScgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LmV4Y2x1ZGVzJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3JkZXJlZFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWQgPSBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IG9yZGVyZWQuJF92YWxpZGF0ZShpdGVtLCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIG9yZGVyZWQpLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuJF90ZXJtcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkub3JkZXJlZExlbmd0aCcsIHsgcG9zOiBpLCBsaW1pdDogc2NoZW1hLiRfdGVybXMub3JkZXJlZC5sZW5ndGggfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgLy8gTm8gcmVhc29uIHRvIGNvbnRpbnVlIHNpbmNlIHRoZXJlIGFyZSBubyBvdGhlciBydWxlcyB0byB2YWxpZGF0ZSBvdGhlciB0aGFuIGFycmF5Lm9yZGVyZWRMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcXVpcmVkc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQ2hlY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBqbCA9IHJlcXVpcmVkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgamw7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgcmVxdWlyZWRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gcmVxdWlyZWRzW2pdLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRDaGVja3Nbal0gPSByZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UocmVxdWlyZWRzLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1qbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1c2lvbnNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpcFVua25vd24gPSBwcmVmcy5zdHJpcFVua25vd24gJiYgISFwcmVmcy5zdHJpcFVua25vd24uYXJyYXlzIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGpsID0gaW5jbHVzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5jbHVzaW9uIG9mIGluY2x1c2lvbnMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgcmUtcnVubmluZyByZXF1aXJlZHMgdGhhdCBhbHJlYWR5IGRpZG4ndCBtYXRjaCBpbiB0aGUgcHJldmlvdXMgbG9vcFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDaGVjayA9IHJlcXVpcmVkcy5pbmRleE9mKGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNDaGVjayAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXF1aXJlZENoZWNrc1twcmV2aW91c0NoZWNrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gaW5jbHVzaW9uLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLmNvbW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgZXJyb3IgaWYgb25seSBvbmUgaW5jbHVzaW9uIGRlZmluZWRcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlcy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLmxlbmd0aCB8fCBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzLmxlbmd0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc1ZhbGlkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5pbmNsdWRlcycsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbE9yZGVyZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5maWxsRGVmYXVsdChvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICBtYW5pZmVzdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc9JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdhcnJheS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9yZGVyZWQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAnb3JkZXJlZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0aGlzLiRfY29tcGlsZShzY2hlbWFzW2ldKSwgaSwgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy52YWxpZGF0ZVNpbmdsZSh0eXBlLCBvYmopO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5vcmRlcmVkLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaW5nbGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF2YWx1ZSB8fCAhdGhpcy5fZmxhZ3MuX2FycmF5SXRlbXMsICdDYW5ub3Qgc3BlY2lmeSBzaW5nbGUgcnVsZSB3aGVuIGFycmF5IGhhcyBhcnJheSBpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdzaW5nbGUnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc29ydDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydieScsICdvcmRlciddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogb3B0aW9ucy5vcmRlciB8fCAnYXNjZW5kaW5nJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ieSA9IENvbXBpbGUucmVmKG9wdGlvbnMuYnksIHsgYW5jZXN0b3I6IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghc2V0dGluZ3MuYnkuYW5jZXN0b3IsICdDYW5ub3Qgc29ydCBieSBhbmNlc3RvcicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdzb3J0JywgYXJnczogeyBvcHRpb25zOiBzZXR0aW5ncyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYSB9LCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogc29ydGVkLCBlcnJvcnMgfSA9IGludGVybmFscy5zb3J0KHNjaGVtYSwgdmFsdWUsIG9wdGlvbnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldICE9PSBzb3J0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuc29ydCcsIHsgb3JkZXI6IG9wdGlvbnMub3JkZXIsIGJ5OiBvcHRpb25zLmJ5ID8gb3B0aW9ucy5ieS5rZXkgOiAndmFsdWUnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBzcGFyc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3Muc3BhcnNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB2YWx1ZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXMuJF9hZGRSdWxlKCdpdGVtcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9zZXRGbGFnKCdzcGFyc2UnLCB2YWx1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pcXVlOiB7XG4gICAgICAgICAgICBtZXRob2QoY29tcGFyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIWNvbXBhcmF0b3IgfHwgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnLCAnY29tcGFyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2lnbm9yZVVuZGVmaW5lZCcsICdzZXBhcmF0b3InXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0geyBuYW1lOiAndW5pcXVlJywgYXJnczogeyBvcHRpb25zLCBjb21wYXJhdG9yIH0gfTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IENvbW1vbi5kZWZhdWx0KG9wdGlvbnMuc2VwYXJhdG9yLCAnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5wYXRoID0gc2VwYXJhdG9yID8gY29tcGFyYXRvci5zcGxpdChzZXBhcmF0b3IpIDogW2NvbXBhcmF0b3JdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZShydWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzdGF0ZSwgZXJyb3IsIHNjaGVtYSB9LCB7IGNvbXBhcmF0b3I6IHJhdywgb3B0aW9ucyB9LCB7IGNvbXBhcmF0b3IsIHBhdGggfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZzogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGJpZ2ludDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbTogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSBjb21wYXJhdG9yIHx8IERlZXBFcXVhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHBhdGggPyBSZWFjaCh2YWx1ZVtpXSwgcGF0aCkgOiB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IGNvbXBhcmF0b3IgPyBmb3VuZC5jdXN0b20gOiBmb3VuZFt0eXBlb2YgaXRlbV07XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChyZWNvcmRzLCAnRmFpbGVkIHRvIGZpbmQgdW5pcXVlIG1hcCBjb250YWluZXIgZm9yIHR5cGUnLCB0eXBlb2YgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSByZWNvcmRzLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEoY3VycmVudCA9IGVudHJpZXMubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoY3VycmVudC52YWx1ZVswXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IGN1cnJlbnQudmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlVmFsdWU6IHZhbHVlW2N1cnJlbnQudmFsdWVbMV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aCA9IHJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkudW5pcXVlJywgY29udGV4dCwgbG9jYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChpdGVtLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIWlnbm9yZVVuZGVmaW5lZCB8fCBpdGVtICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVBvczogcmVjb3Jkc1tpdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtyZWNvcmRzW2l0ZW1dXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSByYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzW2l0ZW1dID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbXBhcmF0b3InLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHNldDoge1xuICAgICAgICAgICAgZnJvbTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fZXhjbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHNjaGVtYS4kX3Rlcm1zLml0ZW1zKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUodHlwZSwgc2NoZW1hKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5fZmxhZ3MucHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygc2NoZW1hLiRfdGVybXMub3JkZXJlZCkge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouaXRlbXMoLi4uZGVzYy5pdGVtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoub3JkZXJlZCguLi5kZXNjLm9yZGVyZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhcnJheS5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhbiBhcnJheScsXG4gICAgICAgICdhcnJheS5leGNsdWRlcyc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGFuIGV4Y2x1ZGVkIHZhbHVlJyxcbiAgICAgICAgJ2FycmF5Lmhhc0tub3duJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2ggZm9yIHR5cGUgezojcGF0dGVybkxhYmVsfScsXG4gICAgICAgICdhcnJheS5oYXNVbmtub3duJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2gnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXMnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnOiAne3sjbGFiZWx9fSBkb2VzIG5vdCBjb250YWluIHt7I2tub3duTWlzc2VzfX0gYW5kIHt7I3Vua25vd25NaXNzZXN9fSBvdGhlciByZXF1aXJlZCB2YWx1ZShzKScsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJzogJ3t7I2xhYmVsfX0gZG9lcyBub3QgY29udGFpbiB7eyNrbm93bk1pc3Nlc319JyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRVbmtub3ducyc6ICd7eyNsYWJlbH19IGRvZXMgbm90IGNvbnRhaW4ge3sjdW5rbm93bk1pc3Nlc319IHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgJ2FycmF5Lmxlbmd0aCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm1heCc6ICd7eyNsYWJlbH19IG11c3QgY29udGFpbiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5vcmRlcmVkTGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBjb250YWluIGF0IG1vc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5zb3J0JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBzb3J0ZWQgaW4geyNvcmRlcn0gb3JkZXIgYnkge3sjYnl9fScsXG4gICAgICAgICdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJzogJ3t7I2xhYmVsfX0gY2Fubm90IGJlIHNvcnRlZCBkdWUgdG8gbWlzbWF0Y2hpbmcgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuc29ydC51bnN1cHBvcnRlZCc6ICd7eyNsYWJlbH19IGNhbm5vdCBiZSBzb3J0ZWQgZHVlIHRvIHVuc3VwcG9ydGVkIHR5cGUgeyN0eXBlfScsXG4gICAgICAgICdhcnJheS5zcGFyc2UnOiAne3sjbGFiZWx9fSBtdXN0IG5vdCBiZSBhIHNwYXJzZSBhcnJheSBpdGVtJyxcbiAgICAgICAgJ2FycmF5LnVuaXF1ZSc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgZHVwbGljYXRlIHZhbHVlJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qga25vd25NaXNzZXMgPSBbXTtcbiAgICBsZXQgdW5rbm93bk1pc3NlcyA9IDA7XG4gICAgZm9yIChjb25zdCByZXF1aXJlZCBvZiByZXF1aXJlZHMpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSByZXF1aXJlZC5fZmxhZ3MubGFiZWw7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAga25vd25NaXNzZXMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK3Vua25vd25NaXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa25vd25NaXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh1bmtub3duTWlzc2VzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnLCB2YWx1ZSwgeyBrbm93bk1pc3NlcywgdW5rbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJywgdmFsdWUsIHsga25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnLCB2YWx1ZSwgeyB1bmtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZpbGxPcmRlcmVkRXJyb3JzID0gZnVuY3Rpb24gKHNjaGVtYSwgZXJyb3JzLCBvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3QgcmVxdWlyZWRPcmRlcmVkcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBvcmRlcmVkIG9mIG9yZGVyZWRzKSB7XG4gICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmVxdWlyZWRPcmRlcmVkcy5wdXNoKG9yZGVyZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmVkT3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgIGludGVybmFscy5maWxsTWlzc2VkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZE9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5maWxsRGVmYXVsdCA9IGZ1bmN0aW9uIChvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gW107XG4gICAgbGV0IHRyYWlsaW5nVW5kZWZpbmVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSBvcmRlcmVkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gb3JkZXJlZHNbaV07XG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBvcmRlcmVkLiRfdmFsaWRhdGUodW5kZWZpbmVkLCBzdGF0ZS5sb2NhbGl6ZShzdGF0ZS5wYXRoLCBhbmNlc3RvcnMsIG9yZGVyZWQpLCBwcmVmcykudmFsdWU7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFpbGluZ1VuZGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3ZlcnJpZGVzLnVuc2hpZnQob3ZlcnJpZGUpO1xuICAgIH1cblxuICAgIGlmIChvdmVycmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlLnB1c2goLi4ub3ZlcnJpZGVzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mYXN0U3BsaWNlID0gZnVuY3Rpb24gKGFyciwgaSkge1xuXG4gICAgbGV0IHBvcyA9IGk7XG4gICAgd2hpbGUgKHBvcyA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgYXJyW3BvcysrXSA9IGFycltwb3NdO1xuICAgIH1cblxuICAgIC0tYXJyLmxlbmd0aDtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlID0gZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuXG4gICAgaWYgKHR5cGUudHlwZSA9PT0gJ2FycmF5JyB8fFxuICAgICAgICB0eXBlLl9mbGFncy5fYXJyYXlJdGVtcykge1xuXG4gICAgICAgIEFzc2VydCghb2JqLl9mbGFncy5zaW5nbGUsICdDYW5ub3Qgc3BlY2lmeSBhcnJheSBpdGVtIHdpdGggc2luZ2xlIHJ1bGUgZW5hYmxlZCcpO1xuICAgICAgICBvYmouJF9zZXRGbGFnKCdfYXJyYXlJdGVtcycsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNvcnQgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc2V0dGluZ3MsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3JkZXIgPSBzZXR0aW5ncy5vcmRlciA9PT0gJ2FzY2VuZGluZycgPyAxIDogLTE7XG4gICAgY29uc3QgYUZpcnN0ID0gLTEgKiBvcmRlcjtcbiAgICBjb25zdCBiRmlyc3QgPSBvcmRlcjtcblxuICAgIGNvbnN0IHNvcnQgPSAoYSwgYikgPT4ge1xuXG4gICAgICAgIGxldCBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUoYSwgYiwgYUZpcnN0LCBiRmlyc3QpO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuYnkpIHtcbiAgICAgICAgICAgIGEgPSBzZXR0aW5ncy5ieS5yZXNvbHZlKGEsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBiID0gc2V0dGluZ3MuYnkucmVzb2x2ZShiLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGFyZSA9IGludGVybmFscy5jb21wYXJlKGEsIGIsIGFGaXJzdCwgYkZpcnN0KTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhO1xuICAgICAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJywgdmFsdWUsIG51bGwsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0LnVuc3VwcG9ydGVkJywgdmFsdWUsIHsgdHlwZSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgLSBiKSAqIG9yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPCBiID8gYUZpcnN0IDogYkZpcnN0O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKS5zb3J0KHNvcnQpIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnIgfTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIsIGFGaXJzdCwgYkZpcnN0KSB7XG5cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxOyAgICAgICAgICAgLy8gQWx3YXlzIGxhc3QgcmVnYXJkbGVzcyBvZiBzb3J0IG9yZGVyXG4gICAgfVxuXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTE7ICAgICAgICAgICAvLyBBbHdheXMgbGFzdCByZWdhcmRsZXNzIG9mIHNvcnQgb3JkZXJcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYkZpcnN0O1xuICAgIH1cblxuICAgIGlmIChiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhRmlyc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuIl0sIm5hbWVzIjpbIkFzc2VydCIsInJlcXVpcmUiLCJEZWVwRXF1YWwiLCJSZWFjaCIsIkFueSIsIkNvbW1vbiIsIkNvbXBpbGUiLCJpbnRlcm5hbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXh0ZW5kIiwidHlwZSIsImZsYWdzIiwic2luZ2xlIiwiZGVmYXVsdCIsInNwYXJzZSIsInRlcm1zIiwiaXRlbXMiLCJpbml0IiwibWFuaWZlc3QiLCJvcmRlcmVkIiwiX2V4Y2x1c2lvbnMiLCJfaW5jbHVzaW9ucyIsIl9yZXF1aXJlZHMiLCJjb2VyY2UiLCJmcm9tIiwibWV0aG9kIiwidmFsdWUiLCJzY2hlbWEiLCJzdGF0ZSIsInByZWZzIiwiQXJyYXkiLCJpc0FycmF5Iiwic29ydCIsIiRfZ2V0UnVsZSIsImFyZ3MiLCJvcHRpb25zIiwidmFsaWRhdGUiLCJlcnJvciIsIl9mbGFncyIsInN5bWJvbHMiLCJhcnJheVNpbmdsZSIsImVycm9ycyIsIiRfdGVybXMiLCJleHRlcm5hbHMiLCJzbGljZSIsInJ1bGVzIiwiaGFzIiwiJF9jb21waWxlIiwiYXBwZW5kUGF0aCIsIm9iaiIsIiRfYWRkUnVsZSIsIm5hbWUiLCIkX211dGF0ZVJlZ2lzdGVyIiwiYW5jZXN0b3JzIiwiaSIsImxlbmd0aCIsImxvY2FsU3RhdGUiLCJsb2NhbGl6ZSIsInBhdGgiLCIkX21hdGNoIiwicGF0dGVybkxhYmVsIiwibGFiZWwiLCJtdWx0aSIsInNjaGVtYXMiLCJ2ZXJpZnlGbGF0IiwidHJ5V2l0aFBhdGgiLCJhcHBlbmQiLCJwdXNoIiwiJF9tdXRhdGVSZWJ1aWxkIiwiZXJyb3JzQXJyYXkiLCJyZXF1aXJlZHMiLCJvcmRlcmVkcyIsImluY2x1c2lvbnMiLCJ3YXNBcnJheSIsImlsIiwiaXRlbSIsImVycm9yZWQiLCJpc1ZhbGlkIiwia2V5IiwiTnVtYmVyIiwidW5kZWZpbmVkIiwicG9zIiwiYWJvcnRFYXJseSIsInNoaWZ0IiwiZXhjbHVzaW9uIiwicHJlc2VuY2UiLCJyZXMiLCIkX3ZhbGlkYXRlIiwicmVzdWx0IiwiZmFzdFNwbGljZSIsImxpbWl0IiwicmVxdWlyZWRDaGVja3MiLCJqbCIsImoiLCJzbmFwc2hvdCIsImNvbW1pdCIsInJlc3RvcmUiLCJzdHJpcFVua25vd24iLCJhcnJheXMiLCJpbmNsdXNpb24iLCJwcmV2aW91c0NoZWNrIiwiaW5kZXhPZiIsImZpbGxNaXNzZWRFcnJvcnMiLCJmaWxsT3JkZXJlZEVycm9ycyIsImZpbGxEZWZhdWx0IiwicHJpb3JpdHkiLCJvcGVyYXRvciIsImhlbHBlcnMiLCJjb21wYXJlIiwicmVmIiwiYXNzZXJ0IiwibWVzc2FnZSIsIm1heCIsIm1pbiIsInZhbGlkYXRlU2luZ2xlIiwiZW5hYmxlZCIsIl9hcnJheUl0ZW1zIiwiJF9zZXRGbGFnIiwiYXNzZXJ0T3B0aW9ucyIsInNldHRpbmdzIiwib3JkZXIiLCJieSIsImFuY2VzdG9yIiwic29ydGVkIiwiY29udmVydCIsImNsb25lIiwidW5pcXVlIiwiY29tcGFyYXRvciIsInJ1bGUiLCJzZXBhcmF0b3IiLCJzcGxpdCIsInJhdyIsImZvdW5kIiwic3RyaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibnVtYmVyIiwiYm9vbGVhbiIsImJpZ2ludCIsIm9iamVjdCIsIk1hcCIsImZ1bmN0aW9uIiwiY3VzdG9tIiwiaWdub3JlVW5kZWZpbmVkIiwicmVjb3JkcyIsImVudHJpZXMiLCJjdXJyZW50IiwibmV4dCIsImRvbmUiLCJjb250ZXh0IiwiZHVwZVBvcyIsImR1cGVWYWx1ZSIsInNldCIsImNhc3QiLCJ0byIsIlNldCIsInJlYnVpbGQiLCJidWlsZCIsImRlc2MiLCJtZXNzYWdlcyIsImtub3duTWlzc2VzIiwidW5rbm93bk1pc3NlcyIsInJlcXVpcmVkIiwiJF9jcmVhdGVFcnJvciIsInJlcXVpcmVkT3JkZXJlZHMiLCJvdmVycmlkZXMiLCJ0cmFpbGluZ1VuZGVmaW5lZCIsIm92ZXJyaWRlIiwidW5zaGlmdCIsImFyciIsImFGaXJzdCIsImJGaXJzdCIsImEiLCJiIiwicmVzb2x2ZSIsImVyciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/array.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/binary.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/binary.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst internals = {};\nmodule.exports = Any.extend({\n    type: \"binary\",\n    coerce: {\n        from: [\n            \"string\",\n            \"object\"\n        ],\n        method (value, { schema }) {\n            if (typeof value === \"string\" || value !== null && value.type === \"Buffer\") {\n                try {\n                    return {\n                        value: Buffer.from(value, schema._flags.encoding)\n                    };\n                } catch (ignoreErr) {}\n            }\n        }\n    },\n    validate (value, { error }) {\n        if (!Buffer.isBuffer(value)) {\n            return {\n                value,\n                errors: error(\"binary.base\")\n            };\n        }\n    },\n    rules: {\n        encoding: {\n            method (encoding) {\n                Assert(Buffer.isEncoding(encoding), \"Invalid encoding:\", encoding);\n                return this.$_setFlag(\"encoding\", encoding);\n            }\n        },\n        length: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"length\",\n                    method: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \"=\"\n                });\n            },\n            validate (value, helpers, { limit }, { name, operator, args }) {\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n                return helpers.error(\"binary.\" + name, {\n                    limit: args.limit,\n                    value\n                });\n            },\n            args: [\n                {\n                    name: \"limit\",\n                    ref: true,\n                    assert: Common.limit,\n                    message: \"must be a positive integer\"\n                }\n            ]\n        },\n        max: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"max\",\n                    method: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \"<=\"\n                });\n            }\n        },\n        min: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"min\",\n                    method: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \">=\"\n                });\n            }\n        }\n    },\n    cast: {\n        string: {\n            from: (value)=>Buffer.isBuffer(value),\n            to (value, helpers) {\n                return value.toString();\n            }\n        }\n    },\n    messages: {\n        \"binary.base\": \"{{#label}} must be a buffer or a string\",\n        \"binary.length\": \"{{#label}} must be {{#limit}} bytes\",\n        \"binary.max\": \"{{#label}} must be less than or equal to {{#limit}} bytes\",\n        \"binary.min\": \"{{#label}} must be at least {{#limit}} bytes\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9iaW5hcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUV2QixNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUd2QixNQUFNRyxZQUFZLENBQUM7QUFHbkJDLE9BQU9DLE9BQU8sR0FBR0osSUFBSUssTUFBTSxDQUFDO0lBRXhCQyxNQUFNO0lBRU5DLFFBQVE7UUFDSkMsTUFBTTtZQUFDO1lBQVU7U0FBUztRQUMxQkMsUUFBT0MsS0FBSyxFQUFFLEVBQUVDLE1BQU0sRUFBRTtZQUVwQixJQUFJLE9BQU9ELFVBQVUsWUFBYUEsVUFBVSxRQUFRQSxNQUFNSixJQUFJLEtBQUssVUFBVztnQkFDMUUsSUFBSTtvQkFDQSxPQUFPO3dCQUFFSSxPQUFPRSxPQUFPSixJQUFJLENBQUNFLE9BQU9DLE9BQU9FLE1BQU0sQ0FBQ0MsUUFBUTtvQkFBRTtnQkFDL0QsRUFDQSxPQUFPQyxXQUFXLENBQUU7WUFDeEI7UUFDSjtJQUNKO0lBRUFDLFVBQVNOLEtBQUssRUFBRSxFQUFFTyxLQUFLLEVBQUU7UUFFckIsSUFBSSxDQUFDTCxPQUFPTSxRQUFRLENBQUNSLFFBQVE7WUFDekIsT0FBTztnQkFBRUE7Z0JBQU9TLFFBQVFGLE1BQU07WUFBZTtRQUNqRDtJQUNKO0lBRUFHLE9BQU87UUFDSE4sVUFBVTtZQUNOTCxRQUFPSyxRQUFRO2dCQUVYaEIsT0FBT2MsT0FBT1MsVUFBVSxDQUFDUCxXQUFXLHFCQUFxQkE7Z0JBRXpELE9BQU8sSUFBSSxDQUFDUSxTQUFTLENBQUMsWUFBWVI7WUFDdEM7UUFDSjtRQUVBUyxRQUFRO1lBQ0pkLFFBQU9lLEtBQUs7Z0JBRVIsT0FBTyxJQUFJLENBQUNDLFNBQVMsQ0FBQztvQkFBRUMsTUFBTTtvQkFBVWpCLFFBQVE7b0JBQVVrQixNQUFNO3dCQUFFSDtvQkFBTTtvQkFBR0ksVUFBVTtnQkFBSTtZQUM3RjtZQUNBWixVQUFTTixLQUFLLEVBQUVtQixPQUFPLEVBQUUsRUFBRUwsS0FBSyxFQUFFLEVBQUUsRUFBRUUsSUFBSSxFQUFFRSxRQUFRLEVBQUVELElBQUksRUFBRTtnQkFFeEQsSUFBSTFCLE9BQU82QixPQUFPLENBQUNwQixNQUFNYSxNQUFNLEVBQUVDLE9BQU9JLFdBQVc7b0JBQy9DLE9BQU9sQjtnQkFDWDtnQkFFQSxPQUFPbUIsUUFBUVosS0FBSyxDQUFDLFlBQVlTLE1BQU07b0JBQUVGLE9BQU9HLEtBQUtILEtBQUs7b0JBQUVkO2dCQUFNO1lBQ3RFO1lBQ0FpQixNQUFNO2dCQUNGO29CQUNJRCxNQUFNO29CQUNOSyxLQUFLO29CQUNMQyxRQUFRL0IsT0FBT3VCLEtBQUs7b0JBQ3BCUyxTQUFTO2dCQUNiO2FBQ0g7UUFDTDtRQUVBQyxLQUFLO1lBQ0R6QixRQUFPZSxLQUFLO2dCQUVSLE9BQU8sSUFBSSxDQUFDQyxTQUFTLENBQUM7b0JBQUVDLE1BQU07b0JBQU9qQixRQUFRO29CQUFVa0IsTUFBTTt3QkFBRUg7b0JBQU07b0JBQUdJLFVBQVU7Z0JBQUs7WUFDM0Y7UUFDSjtRQUVBTyxLQUFLO1lBQ0QxQixRQUFPZSxLQUFLO2dCQUVSLE9BQU8sSUFBSSxDQUFDQyxTQUFTLENBQUM7b0JBQUVDLE1BQU07b0JBQU9qQixRQUFRO29CQUFVa0IsTUFBTTt3QkFBRUg7b0JBQU07b0JBQUdJLFVBQVU7Z0JBQUs7WUFDM0Y7UUFDSjtJQUNKO0lBRUFRLE1BQU07UUFDRkMsUUFBUTtZQUNKN0IsTUFBTSxDQUFDRSxRQUFVRSxPQUFPTSxRQUFRLENBQUNSO1lBQ2pDNEIsSUFBRzVCLEtBQUssRUFBRW1CLE9BQU87Z0JBRWIsT0FBT25CLE1BQU02QixRQUFRO1lBQ3pCO1FBQ0o7SUFDSjtJQUVBQyxVQUFVO1FBQ04sZUFBZTtRQUNmLGlCQUFpQjtRQUNqQixjQUFjO1FBQ2QsY0FBYztJQUNsQjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9iaW5hcnkuanM/NjU1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdiaW5hcnknLFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206IFsnc3RyaW5nJywgJ29iamVjdCddLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlLnR5cGUgPT09ICdCdWZmZXInKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBCdWZmZXIuZnJvbSh2YWx1ZSwgc2NoZW1hLl9mbGFncy5lbmNvZGluZykgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZUVycikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2JpbmFyeS5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBlbmNvZGluZzoge1xuICAgICAgICAgICAgbWV0aG9kKGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2VuY29kaW5nJywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2JpbmFyeS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2JpbmFyeS5iYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZycsXG4gICAgICAgICdiaW5hcnkubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSB7eyNsaW1pdH19IGJ5dGVzJyxcbiAgICAgICAgJ2JpbmFyeS5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGJ5dGVzJyxcbiAgICAgICAgJ2JpbmFyeS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGF0IGxlYXN0IHt7I2xpbWl0fX0gYnl0ZXMnXG4gICAgfVxufSk7XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkFueSIsIkNvbW1vbiIsImludGVybmFscyIsIm1vZHVsZSIsImV4cG9ydHMiLCJleHRlbmQiLCJ0eXBlIiwiY29lcmNlIiwiZnJvbSIsIm1ldGhvZCIsInZhbHVlIiwic2NoZW1hIiwiQnVmZmVyIiwiX2ZsYWdzIiwiZW5jb2RpbmciLCJpZ25vcmVFcnIiLCJ2YWxpZGF0ZSIsImVycm9yIiwiaXNCdWZmZXIiLCJlcnJvcnMiLCJydWxlcyIsImlzRW5jb2RpbmciLCIkX3NldEZsYWciLCJsZW5ndGgiLCJsaW1pdCIsIiRfYWRkUnVsZSIsIm5hbWUiLCJhcmdzIiwib3BlcmF0b3IiLCJoZWxwZXJzIiwiY29tcGFyZSIsInJlZiIsImFzc2VydCIsIm1lc3NhZ2UiLCJtYXgiLCJtaW4iLCJjYXN0Iiwic3RyaW5nIiwidG8iLCJ0b1N0cmluZyIsIm1lc3NhZ2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/binary.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/boolean.js":
/*!***********************************************!*\
  !*** ./node_modules/joi/lib/types/boolean.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Values = __webpack_require__(/*! ../values */ \"(rsc)/./node_modules/joi/lib/values.js\");\nconst internals = {};\ninternals.isBool = function(value) {\n    return typeof value === \"boolean\";\n};\nmodule.exports = Any.extend({\n    type: \"boolean\",\n    flags: {\n        sensitive: {\n            default: false\n        }\n    },\n    terms: {\n        falsy: {\n            init: null,\n            manifest: \"values\"\n        },\n        truthy: {\n            init: null,\n            manifest: \"values\"\n        }\n    },\n    coerce (value, { schema }) {\n        if (typeof value === \"boolean\") {\n            return;\n        }\n        if (typeof value === \"string\") {\n            const normalized = schema._flags.sensitive ? value : value.toLowerCase();\n            value = normalized === \"true\" ? true : normalized === \"false\" ? false : value;\n        }\n        if (typeof value !== \"boolean\") {\n            value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);\n        }\n        return {\n            value\n        };\n    },\n    validate (value, { error }) {\n        if (typeof value !== \"boolean\") {\n            return {\n                value,\n                errors: error(\"boolean.base\")\n            };\n        }\n    },\n    rules: {\n        truthy: {\n            method (...values) {\n                Common.verifyFlat(values, \"truthy\");\n                const obj = this.clone();\n                obj.$_terms.truthy = obj.$_terms.truthy || new Values();\n                for(let i = 0; i < values.length; ++i){\n                    const value = values[i];\n                    Assert(value !== undefined, \"Cannot call truthy with undefined\");\n                    obj.$_terms.truthy.add(value);\n                }\n                return obj;\n            }\n        },\n        falsy: {\n            method (...values) {\n                Common.verifyFlat(values, \"falsy\");\n                const obj = this.clone();\n                obj.$_terms.falsy = obj.$_terms.falsy || new Values();\n                for(let i = 0; i < values.length; ++i){\n                    const value = values[i];\n                    Assert(value !== undefined, \"Cannot call falsy with undefined\");\n                    obj.$_terms.falsy.add(value);\n                }\n                return obj;\n            }\n        },\n        sensitive: {\n            method (enabled = true) {\n                return this.$_setFlag(\"sensitive\", enabled);\n            }\n        }\n    },\n    cast: {\n        number: {\n            from: internals.isBool,\n            to (value, helpers) {\n                return value ? 1 : 0;\n            }\n        },\n        string: {\n            from: internals.isBool,\n            to (value, helpers) {\n                return value ? \"true\" : \"false\";\n            }\n        }\n    },\n    manifest: {\n        build (obj, desc) {\n            if (desc.truthy) {\n                obj = obj.truthy(...desc.truthy);\n            }\n            if (desc.falsy) {\n                obj = obj.falsy(...desc.falsy);\n            }\n            return obj;\n        }\n    },\n    messages: {\n        \"boolean.base\": \"{{#label}} must be a boolean\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFFdkIsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFHdkIsTUFBTUksWUFBWSxDQUFDO0FBR25CQSxVQUFVQyxNQUFNLEdBQUcsU0FBVUMsS0FBSztJQUU5QixPQUFPLE9BQU9BLFVBQVU7QUFDNUI7QUFHQUMsT0FBT0MsT0FBTyxHQUFHUCxJQUFJUSxNQUFNLENBQUM7SUFFeEJDLE1BQU07SUFFTkMsT0FBTztRQUVIQyxXQUFXO1lBQUVDLFNBQVM7UUFBTTtJQUNoQztJQUVBQyxPQUFPO1FBRUhDLE9BQU87WUFDSEMsTUFBTTtZQUNOQyxVQUFVO1FBQ2Q7UUFFQUMsUUFBUTtZQUNKRixNQUFNO1lBQ05DLFVBQVU7UUFDZDtJQUNKO0lBRUFFLFFBQU9iLEtBQUssRUFBRSxFQUFFYyxNQUFNLEVBQUU7UUFFcEIsSUFBSSxPQUFPZCxVQUFVLFdBQVc7WUFDNUI7UUFDSjtRQUVBLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzNCLE1BQU1lLGFBQWFELE9BQU9FLE1BQU0sQ0FBQ1YsU0FBUyxHQUFHTixRQUFRQSxNQUFNaUIsV0FBVztZQUN0RWpCLFFBQVFlLGVBQWUsU0FBUyxPQUFRQSxlQUFlLFVBQVUsUUFBUWY7UUFDN0U7UUFFQSxJQUFJLE9BQU9BLFVBQVUsV0FBVztZQUM1QkEsUUFBUWMsT0FBT0ksT0FBTyxDQUFDTixNQUFNLElBQUlFLE9BQU9JLE9BQU8sQ0FBQ04sTUFBTSxDQUFDTyxHQUFHLENBQUNuQixPQUFPLE1BQU0sTUFBTSxDQUFDYyxPQUFPRSxNQUFNLENBQUNWLFNBQVMsS0FDakdRLENBQUFBLE9BQU9JLE9BQU8sQ0FBQ1QsS0FBSyxJQUFJSyxPQUFPSSxPQUFPLENBQUNULEtBQUssQ0FBQ1UsR0FBRyxDQUFDbkIsT0FBTyxNQUFNLE1BQU0sQ0FBQ2MsT0FBT0UsTUFBTSxDQUFDVixTQUFTLElBQUksUUFBUU4sS0FBSTtRQUNySDtRQUVBLE9BQU87WUFBRUE7UUFBTTtJQUNuQjtJQUVBb0IsVUFBU3BCLEtBQUssRUFBRSxFQUFFcUIsS0FBSyxFQUFFO1FBRXJCLElBQUksT0FBT3JCLFVBQVUsV0FBVztZQUM1QixPQUFPO2dCQUFFQTtnQkFBT3NCLFFBQVFELE1BQU07WUFBZ0I7UUFDbEQ7SUFDSjtJQUVBRSxPQUFPO1FBQ0hYLFFBQVE7WUFDSlksUUFBTyxHQUFHQyxNQUFNO2dCQUVaN0IsT0FBTzhCLFVBQVUsQ0FBQ0QsUUFBUTtnQkFFMUIsTUFBTUUsTUFBTSxJQUFJLENBQUNDLEtBQUs7Z0JBQ3RCRCxJQUFJVCxPQUFPLENBQUNOLE1BQU0sR0FBR2UsSUFBSVQsT0FBTyxDQUFDTixNQUFNLElBQUksSUFBSWY7Z0JBRS9DLElBQUssSUFBSWdDLElBQUksR0FBR0EsSUFBSUosT0FBT0ssTUFBTSxFQUFFLEVBQUVELEVBQUc7b0JBQ3BDLE1BQU03QixRQUFReUIsTUFBTSxDQUFDSSxFQUFFO29CQUV2QnBDLE9BQU9PLFVBQVUrQixXQUFXO29CQUM1QkosSUFBSVQsT0FBTyxDQUFDTixNQUFNLENBQUNvQixHQUFHLENBQUNoQztnQkFDM0I7Z0JBRUEsT0FBTzJCO1lBQ1g7UUFDSjtRQUVBbEIsT0FBTztZQUNIZSxRQUFPLEdBQUdDLE1BQU07Z0JBRVo3QixPQUFPOEIsVUFBVSxDQUFDRCxRQUFRO2dCQUUxQixNQUFNRSxNQUFNLElBQUksQ0FBQ0MsS0FBSztnQkFDdEJELElBQUlULE9BQU8sQ0FBQ1QsS0FBSyxHQUFHa0IsSUFBSVQsT0FBTyxDQUFDVCxLQUFLLElBQUksSUFBSVo7Z0JBRTdDLElBQUssSUFBSWdDLElBQUksR0FBR0EsSUFBSUosT0FBT0ssTUFBTSxFQUFFLEVBQUVELEVBQUc7b0JBQ3BDLE1BQU03QixRQUFReUIsTUFBTSxDQUFDSSxFQUFFO29CQUV2QnBDLE9BQU9PLFVBQVUrQixXQUFXO29CQUM1QkosSUFBSVQsT0FBTyxDQUFDVCxLQUFLLENBQUN1QixHQUFHLENBQUNoQztnQkFDMUI7Z0JBRUEsT0FBTzJCO1lBQ1g7UUFDSjtRQUVBckIsV0FBVztZQUNQa0IsUUFBT1MsVUFBVSxJQUFJO2dCQUVqQixPQUFPLElBQUksQ0FBQ0MsU0FBUyxDQUFDLGFBQWFEO1lBQ3ZDO1FBQ0o7SUFDSjtJQUVBRSxNQUFNO1FBQ0ZDLFFBQVE7WUFDSkMsTUFBTXZDLFVBQVVDLE1BQU07WUFDdEJ1QyxJQUFHdEMsS0FBSyxFQUFFdUMsT0FBTztnQkFFYixPQUFPdkMsUUFBUSxJQUFJO1lBQ3ZCO1FBQ0o7UUFDQXdDLFFBQVE7WUFDSkgsTUFBTXZDLFVBQVVDLE1BQU07WUFDdEJ1QyxJQUFHdEMsS0FBSyxFQUFFdUMsT0FBTztnQkFFYixPQUFPdkMsUUFBUSxTQUFTO1lBQzVCO1FBQ0o7SUFDSjtJQUVBVyxVQUFVO1FBRU44QixPQUFNZCxHQUFHLEVBQUVlLElBQUk7WUFFWCxJQUFJQSxLQUFLOUIsTUFBTSxFQUFFO2dCQUNiZSxNQUFNQSxJQUFJZixNQUFNLElBQUk4QixLQUFLOUIsTUFBTTtZQUNuQztZQUVBLElBQUk4QixLQUFLakMsS0FBSyxFQUFFO2dCQUNaa0IsTUFBTUEsSUFBSWxCLEtBQUssSUFBSWlDLEtBQUtqQyxLQUFLO1lBQ2pDO1lBRUEsT0FBT2tCO1FBQ1g7SUFDSjtJQUVBZ0IsVUFBVTtRQUNOLGdCQUFnQjtJQUNwQjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9ib29sZWFuLmpzP2UzMmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgVmFsdWVzID0gcmVxdWlyZSgnLi4vdmFsdWVzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLmlzQm9vbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBzZW5zaXRpdmU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGZhbHN5OiB7XG4gICAgICAgICAgICBpbml0OiBudWxsLFxuICAgICAgICAgICAgbWFuaWZlc3Q6ICd2YWx1ZXMnXG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJ1dGh5OiB7XG4gICAgICAgICAgICBpbml0OiBudWxsLFxuICAgICAgICAgICAgbWFuaWZlc3Q6ICd2YWx1ZXMnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlKHZhbHVlLCB7IHNjaGVtYSB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHNjaGVtYS5fZmxhZ3Muc2Vuc2l0aXZlID8gdmFsdWUgOiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVkID09PSAndHJ1ZScgPyB0cnVlIDogKG5vcm1hbGl6ZWQgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdmFsdWUgPSBzY2hlbWEuJF90ZXJtcy50cnV0aHkgJiYgc2NoZW1hLiRfdGVybXMudHJ1dGh5Lmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgIXNjaGVtYS5fZmxhZ3Muc2Vuc2l0aXZlKSB8fFxuICAgICAgICAgICAgICAgIChzY2hlbWEuJF90ZXJtcy5mYWxzeSAmJiBzY2hlbWEuJF90ZXJtcy5mYWxzeS5oYXModmFsdWUsIG51bGwsIG51bGwsICFzY2hlbWEuX2ZsYWdzLnNlbnNpdGl2ZSkgPyBmYWxzZSA6IHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdib29sZWFuLmJhc2UnKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIHRydXRoeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnZhbHVlcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAndHJ1dGh5Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMudHJ1dGh5ID0gb2JqLiRfdGVybXMudHJ1dGh5IHx8IG5ldyBWYWx1ZXMoKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgdHJ1dGh5IHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnRydXRoeS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmFsc3k6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi52YWx1ZXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ2ZhbHN5Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuZmFsc3kgPSBvYmouJF90ZXJtcy5mYWxzeSB8fCBuZXcgVmFsdWVzKCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIGZhbHN5IHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmZhbHN5LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZW5zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdzZW5zaXRpdmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzQm9vbCxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNCb29sLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MudHJ1dGh5KSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLnRydXRoeSguLi5kZXNjLnRydXRoeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmZhbHN5KSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLmZhbHN5KC4uLmRlc2MuZmFsc3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdib29sZWFuLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgYm9vbGVhbidcbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6WyJBc3NlcnQiLCJyZXF1aXJlIiwiQW55IiwiQ29tbW9uIiwiVmFsdWVzIiwiaW50ZXJuYWxzIiwiaXNCb29sIiwidmFsdWUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXh0ZW5kIiwidHlwZSIsImZsYWdzIiwic2Vuc2l0aXZlIiwiZGVmYXVsdCIsInRlcm1zIiwiZmFsc3kiLCJpbml0IiwibWFuaWZlc3QiLCJ0cnV0aHkiLCJjb2VyY2UiLCJzY2hlbWEiLCJub3JtYWxpemVkIiwiX2ZsYWdzIiwidG9Mb3dlckNhc2UiLCIkX3Rlcm1zIiwiaGFzIiwidmFsaWRhdGUiLCJlcnJvciIsImVycm9ycyIsInJ1bGVzIiwibWV0aG9kIiwidmFsdWVzIiwidmVyaWZ5RmxhdCIsIm9iaiIsImNsb25lIiwiaSIsImxlbmd0aCIsInVuZGVmaW5lZCIsImFkZCIsImVuYWJsZWQiLCIkX3NldEZsYWciLCJjYXN0IiwibnVtYmVyIiwiZnJvbSIsInRvIiwiaGVscGVycyIsInN0cmluZyIsImJ1aWxkIiwiZGVzYyIsIm1lc3NhZ2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/boolean.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/date.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/date.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Template = __webpack_require__(/*! ../template */ \"(rsc)/./node_modules/joi/lib/template.js\");\nconst internals = {};\ninternals.isDate = function(value) {\n    return value instanceof Date;\n};\nmodule.exports = Any.extend({\n    type: \"date\",\n    coerce: {\n        from: [\n            \"number\",\n            \"string\"\n        ],\n        method (value, { schema }) {\n            return {\n                value: internals.parse(value, schema._flags.format) || value\n            };\n        }\n    },\n    validate (value, { schema, error, prefs }) {\n        if (value instanceof Date && !isNaN(value.getTime())) {\n            return;\n        }\n        const format = schema._flags.format;\n        if (!prefs.convert || !format || typeof value !== \"string\") {\n            return {\n                value,\n                errors: error(\"date.base\")\n            };\n        }\n        return {\n            value,\n            errors: error(\"date.format\", {\n                format\n            })\n        };\n    },\n    rules: {\n        compare: {\n            method: false,\n            validate (value, helpers, { date }, { name, operator, args }) {\n                const to = date === \"now\" ? Date.now() : date.getTime();\n                if (Common.compare(value.getTime(), to, operator)) {\n                    return value;\n                }\n                return helpers.error(\"date.\" + name, {\n                    limit: args.date,\n                    value\n                });\n            },\n            args: [\n                {\n                    name: \"date\",\n                    ref: true,\n                    normalize: (date)=>{\n                        return date === \"now\" ? date : internals.parse(date);\n                    },\n                    assert: (date)=>date !== null,\n                    message: \"must have a valid date format\"\n                }\n            ]\n        },\n        format: {\n            method (format) {\n                Assert([\n                    \"iso\",\n                    \"javascript\",\n                    \"unix\"\n                ].includes(format), \"Unknown date format\", format);\n                return this.$_setFlag(\"format\", format);\n            }\n        },\n        greater: {\n            method (date) {\n                return this.$_addRule({\n                    name: \"greater\",\n                    method: \"compare\",\n                    args: {\n                        date\n                    },\n                    operator: \">\"\n                });\n            }\n        },\n        iso: {\n            method () {\n                return this.format(\"iso\");\n            }\n        },\n        less: {\n            method (date) {\n                return this.$_addRule({\n                    name: \"less\",\n                    method: \"compare\",\n                    args: {\n                        date\n                    },\n                    operator: \"<\"\n                });\n            }\n        },\n        max: {\n            method (date) {\n                return this.$_addRule({\n                    name: \"max\",\n                    method: \"compare\",\n                    args: {\n                        date\n                    },\n                    operator: \"<=\"\n                });\n            }\n        },\n        min: {\n            method (date) {\n                return this.$_addRule({\n                    name: \"min\",\n                    method: \"compare\",\n                    args: {\n                        date\n                    },\n                    operator: \">=\"\n                });\n            }\n        },\n        timestamp: {\n            method (type = \"javascript\") {\n                Assert([\n                    \"javascript\",\n                    \"unix\"\n                ].includes(type), '\"type\" must be one of \"javascript, unix\"');\n                return this.format(type);\n            }\n        }\n    },\n    cast: {\n        number: {\n            from: internals.isDate,\n            to (value, helpers) {\n                return value.getTime();\n            }\n        },\n        string: {\n            from: internals.isDate,\n            to (value, { prefs }) {\n                return Template.date(value, prefs);\n            }\n        }\n    },\n    messages: {\n        \"date.base\": \"{{#label}} must be a valid date\",\n        \"date.format\": '{{#label}} must be in {msg(\"date.format.\" + #format) || #format} format',\n        \"date.greater\": \"{{#label}} must be greater than {{:#limit}}\",\n        \"date.less\": \"{{#label}} must be less than {{:#limit}}\",\n        \"date.max\": \"{{#label}} must be less than or equal to {{:#limit}}\",\n        \"date.min\": \"{{#label}} must be greater than or equal to {{:#limit}}\",\n        // Messages used in date.format\n        \"date.format.iso\": \"ISO 8601 date\",\n        \"date.format.javascript\": \"timestamp or number of milliseconds\",\n        \"date.format.unix\": \"timestamp or number of seconds\"\n    }\n});\n// Helpers\ninternals.parse = function(value, format) {\n    if (value instanceof Date) {\n        return value;\n    }\n    if (typeof value !== \"string\" && (isNaN(value) || !isFinite(value))) {\n        return null;\n    }\n    if (/^\\s*$/.test(value)) {\n        return null;\n    }\n    // ISO\n    if (format === \"iso\") {\n        if (!Common.isIsoDate(value)) {\n            return null;\n        }\n        return internals.date(value.toString());\n    }\n    // Normalize number string\n    const original = value;\n    if (typeof value === \"string\" && /^[+-]?\\d+(\\.\\d+)?$/.test(value)) {\n        value = parseFloat(value);\n    }\n    // Timestamp\n    if (format) {\n        if (format === \"javascript\") {\n            return internals.date(1 * value); // Casting to number\n        }\n        if (format === \"unix\") {\n            return internals.date(1000 * value);\n        }\n        if (typeof original === \"string\") {\n            return null;\n        }\n    }\n    // Plain\n    return internals.date(value);\n};\ninternals.date = function(value) {\n    const date = new Date(value);\n    if (!isNaN(date.getTime())) {\n        return date;\n    }\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9kYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFFdkIsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUM7QUFHekIsTUFBTUksWUFBWSxDQUFDO0FBR25CQSxVQUFVQyxNQUFNLEdBQUcsU0FBVUMsS0FBSztJQUU5QixPQUFPQSxpQkFBaUJDO0FBQzVCO0FBR0FDLE9BQU9DLE9BQU8sR0FBR1IsSUFBSVMsTUFBTSxDQUFDO0lBRXhCQyxNQUFNO0lBRU5DLFFBQVE7UUFDSkMsTUFBTTtZQUFDO1lBQVU7U0FBUztRQUMxQkMsUUFBT1IsS0FBSyxFQUFFLEVBQUVTLE1BQU0sRUFBRTtZQUVwQixPQUFPO2dCQUFFVCxPQUFPRixVQUFVWSxLQUFLLENBQUNWLE9BQU9TLE9BQU9FLE1BQU0sQ0FBQ0MsTUFBTSxLQUFLWjtZQUFNO1FBQzFFO0lBQ0o7SUFFQWEsVUFBU2IsS0FBSyxFQUFFLEVBQUVTLE1BQU0sRUFBRUssS0FBSyxFQUFFQyxLQUFLLEVBQUU7UUFFcEMsSUFBSWYsaUJBQWlCQyxRQUNqQixDQUFDZSxNQUFNaEIsTUFBTWlCLE9BQU8sS0FBSztZQUV6QjtRQUNKO1FBRUEsTUFBTUwsU0FBU0gsT0FBT0UsTUFBTSxDQUFDQyxNQUFNO1FBRW5DLElBQUksQ0FBQ0csTUFBTUcsT0FBTyxJQUNkLENBQUNOLFVBQ0QsT0FBT1osVUFBVSxVQUFVO1lBRTNCLE9BQU87Z0JBQUVBO2dCQUFPbUIsUUFBUUwsTUFBTTtZQUFhO1FBQy9DO1FBRUEsT0FBTztZQUFFZDtZQUFPbUIsUUFBUUwsTUFBTSxlQUFlO2dCQUFFRjtZQUFPO1FBQUc7SUFDN0Q7SUFFQVEsT0FBTztRQUVIQyxTQUFTO1lBQ0xiLFFBQVE7WUFDUkssVUFBU2IsS0FBSyxFQUFFc0IsT0FBTyxF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L2pvaS9saWIvdHlwZXMvZGF0ZS5qcz80MTE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuaXNEYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2RhdGUnLFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206IFsnbnVtYmVyJywgJ3N0cmluZyddLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGludGVybmFscy5wYXJzZSh2YWx1ZSwgc2NoZW1hLl9mbGFncy5mb3JtYXQpIHx8IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICAgICAgICAgICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHNjaGVtYS5fZmxhZ3MuZm9ybWF0O1xuXG4gICAgICAgIGlmICghcHJlZnMuY29udmVydCB8fFxuICAgICAgICAgICAgIWZvcm1hdCB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignZGF0ZS5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdkYXRlLmZvcm1hdCcsIHsgZm9ybWF0IH0pIH07XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29tcGFyZToge1xuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGRhdGUgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0byA9IGRhdGUgPT09ICdub3cnID8gRGF0ZS5ub3coKSA6IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5nZXRUaW1lKCksIHRvLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdkYXRlLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmRhdGUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemU6IChkYXRlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlID09PSAnbm93JyA/IGRhdGUgOiBpbnRlcm5hbHMucGFyc2UoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogKGRhdGUpID0+IGRhdGUgIT09IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGhhdmUgYSB2YWxpZCBkYXRlIGZvcm1hdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICBtZXRob2QoZm9ybWF0KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydpc28nLCAnamF2YXNjcmlwdCcsICd1bml4J10uaW5jbHVkZXMoZm9ybWF0KSwgJ1Vua25vd24gZGF0ZSBmb3JtYXQnLCBmb3JtYXQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdmb3JtYXQnLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdyZWF0ZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZChkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3JlYXRlcicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc+JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc286IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCgnaXNvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVzczoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZXNzJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJzwnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRpbWVzdGFtcDoge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnamF2YXNjcmlwdCcpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2phdmFzY3JpcHQnLCAndW5peCddLmluY2x1ZGVzKHR5cGUpLCAnXCJ0eXBlXCIgbXVzdCBiZSBvbmUgb2YgXCJqYXZhc2NyaXB0LCB1bml4XCInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzRGF0ZSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0RhdGUsXG4gICAgICAgICAgICB0byh2YWx1ZSwgeyBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gVGVtcGxhdGUuZGF0ZSh2YWx1ZSwgcHJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdkYXRlLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgZGF0ZScsXG4gICAgICAgICdkYXRlLmZvcm1hdCc6ICd7eyNsYWJlbH19IG11c3QgYmUgaW4ge21zZyhcImRhdGUuZm9ybWF0LlwiICsgI2Zvcm1hdCkgfHwgI2Zvcm1hdH0gZm9ybWF0JyxcbiAgICAgICAgJ2RhdGUuZ3JlYXRlcic6ICd7eyNsYWJlbH19IG11c3QgYmUgZ3JlYXRlciB0aGFuIHt7OiNsaW1pdH19JyxcbiAgICAgICAgJ2RhdGUubGVzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgbGVzcyB0aGFuIHt7OiNsaW1pdH19JyxcbiAgICAgICAgJ2RhdGUubWF4JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3s6I2xpbWl0fX0nLFxuICAgICAgICAnZGF0ZS5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7ezojbGltaXR9fScsXG5cbiAgICAgICAgLy8gTWVzc2FnZXMgdXNlZCBpbiBkYXRlLmZvcm1hdFxuXG4gICAgICAgICdkYXRlLmZvcm1hdC5pc28nOiAnSVNPIDg2MDEgZGF0ZScsXG4gICAgICAgICdkYXRlLmZvcm1hdC5qYXZhc2NyaXB0JzogJ3RpbWVzdGFtcCBvciBudW1iZXIgb2YgbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LnVuaXgnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBzZWNvbmRzJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLnBhcnNlID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoL15cXHMqJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSVNPXG5cbiAgICBpZiAoZm9ybWF0ID09PSAnaXNvJykge1xuICAgICAgICBpZiAoIUNvbW1vbi5pc0lzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgbnVtYmVyIHN0cmluZ1xuXG4gICAgY29uc3Qgb3JpZ2luYWwgPSB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAvXlsrLV0/XFxkKyhcXC5cXGQrKT8kLy50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gVGltZXN0YW1wXG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdqYXZhc2NyaXB0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKDEgKiB2YWx1ZSk7ICAgICAgICAvLyBDYXN0aW5nIHRvIG51bWJlclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3VuaXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMTAwMCAqIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBsYWluXG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUodmFsdWUpO1xufTtcblxuXG5pbnRlcm5hbHMuZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkFueSIsIkNvbW1vbiIsIlRlbXBsYXRlIiwiaW50ZXJuYWxzIiwiaXNEYXRlIiwidmFsdWUiLCJEYXRlIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4dGVuZCIsInR5cGUiLCJjb2VyY2UiLCJmcm9tIiwibWV0aG9kIiwic2NoZW1hIiwicGFyc2UiLCJfZmxhZ3MiLCJmb3JtYXQiLCJ2YWxpZGF0ZSIsImVycm9yIiwicHJlZnMiLCJpc05hTiIsImdldFRpbWUiLCJjb252ZXJ0IiwiZXJyb3JzIiwicnVsZXMiLCJjb21wYXJlIiwiaGVscGVycyIsImRhdGUiLCJuYW1lIiwib3BlcmF0b3IiLCJhcmdzIiwidG8iLCJub3ciLCJsaW1pdCIsInJlZiIsIm5vcm1hbGl6ZSIsImFzc2VydCIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIiRfc2V0RmxhZyIsImdyZWF0ZXIiLCIkX2FkZFJ1bGUiLCJpc28iLCJsZXNzIiwibWF4IiwibWluIiwidGltZXN0YW1wIiwiY2FzdCIsIm51bWJlciIsInN0cmluZyIsIm1lc3NhZ2VzIiwiaXNGaW5pdGUiLCJ0ZXN0IiwiaXNJc29EYXRlIiwidG9TdHJpbmciLCJvcmlnaW5hbCIsInBhcnNlRmxvYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/date.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/function.js":
/*!************************************************!*\
  !*** ./node_modules/joi/lib/types/function.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Keys = __webpack_require__(/*! ./keys */ \"(rsc)/./node_modules/joi/lib/types/keys.js\");\nconst internals = {};\nmodule.exports = Keys.extend({\n    type: \"function\",\n    properties: {\n        typeof: \"function\"\n    },\n    rules: {\n        arity: {\n            method (n) {\n                Assert(Number.isSafeInteger(n) && n >= 0, \"n must be a positive integer\");\n                return this.$_addRule({\n                    name: \"arity\",\n                    args: {\n                        n\n                    }\n                });\n            },\n            validate (value, helpers, { n }) {\n                if (value.length === n) {\n                    return value;\n                }\n                return helpers.error(\"function.arity\", {\n                    n\n                });\n            }\n        },\n        class: {\n            method () {\n                return this.$_addRule(\"class\");\n            },\n            validate (value, helpers) {\n                if (/^\\s*class\\s/.test(value.toString())) {\n                    return value;\n                }\n                return helpers.error(\"function.class\", {\n                    value\n                });\n            }\n        },\n        minArity: {\n            method (n) {\n                Assert(Number.isSafeInteger(n) && n > 0, \"n must be a strict positive integer\");\n                return this.$_addRule({\n                    name: \"minArity\",\n                    args: {\n                        n\n                    }\n                });\n            },\n            validate (value, helpers, { n }) {\n                if (value.length >= n) {\n                    return value;\n                }\n                return helpers.error(\"function.minArity\", {\n                    n\n                });\n            }\n        },\n        maxArity: {\n            method (n) {\n                Assert(Number.isSafeInteger(n) && n >= 0, \"n must be a positive integer\");\n                return this.$_addRule({\n                    name: \"maxArity\",\n                    args: {\n                        n\n                    }\n                });\n            },\n            validate (value, helpers, { n }) {\n                if (value.length <= n) {\n                    return value;\n                }\n                return helpers.error(\"function.maxArity\", {\n                    n\n                });\n            }\n        }\n    },\n    messages: {\n        \"function.arity\": \"{{#label}} must have an arity of {{#n}}\",\n        \"function.class\": \"{{#label}} must be a class\",\n        \"function.maxArity\": \"{{#label}} must have an arity lesser or equal to {{#n}}\",\n        \"function.minArity\": \"{{#label}} must have an arity greater or equal to {{#n}}\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9mdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBR3JCLE1BQU1FLFlBQVksQ0FBQztBQUduQkMsT0FBT0MsT0FBTyxHQUFHSCxLQUFLSSxNQUFNLENBQUM7SUFFekJDLE1BQU07SUFFTkMsWUFBWTtRQUNSQyxRQUFRO0lBQ1o7SUFFQUMsT0FBTztRQUNIQyxPQUFPO1lBQ0hDLFFBQU9DLENBQUM7Z0JBRUpiLE9BQU9jLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsS0FBSyxHQUFHO2dCQUUxQyxPQUFPLElBQUksQ0FBQ0csU0FBUyxDQUFDO29CQUFFQyxNQUFNO29CQUFTQyxNQUFNO3dCQUFFTDtvQkFBRTtnQkFBRTtZQUN2RDtZQUNBTSxVQUFTQyxLQUFLLEVBQUVDLE9BQU8sRUFBRSxFQUFFUixDQUFDLEVBQUU7Z0JBRTFCLElBQUlPLE1BQU1FLE1BQU0sS0FBS1QsR0FBRztvQkFDcEIsT0FBT087Z0JBQ1g7Z0JBRUEsT0FBT0MsUUFBUUUsS0FBSyxDQUFDLGtCQUFrQjtvQkFBRVY7Z0JBQUU7WUFDL0M7UUFDSjtRQUVBVyxPQUFPO1lBQ0haO2dCQUVJLE9BQU8sSUFBSSxDQUFDSSxTQUFTLENBQUM7WUFDMUI7WUFDQUcsVUFBU0MsS0FBSyxFQUFFQyxPQUFPO2dCQUVuQixJQUFJLGNBQWdCSSxJQUFJLENBQUNMLE1BQU1NLFFBQVEsS0FBSztvQkFDeEMsT0FBT047Z0JBQ1g7Z0JBRUEsT0FBT0MsUUFBUUUsS0FBSyxDQUFDLGtCQUFrQjtvQkFBRUg7Z0JBQU07WUFDbkQ7UUFDSjtRQUVBTyxVQUFVO1lBQ05mLFFBQU9DLENBQUM7Z0JBRUpiLE9BQU9jLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUFHO2dCQUV6QyxPQUFPLElBQUksQ0FBQ0csU0FBUyxDQUFDO29CQUFFQyxNQUFNO29CQUFZQyxNQUFNO3dCQUFFTDtvQkFBRTtnQkFBRTtZQUMxRDtZQUNBTSxVQUFTQyxLQUFLLEVBQUVDLE9BQU8sRUFBRSxFQUFFUixDQUFDLEVBQUU7Z0JBRTFCLElBQUlPLE1BQU1FLE1BQU0sSUFBSVQsR0FBRztvQkFDbkIsT0FBT087Z0JBQ1g7Z0JBRUEsT0FBT0MsUUFBUUUsS0FBSyxDQUFDLHFCQUFxQjtvQkFBRVY7Z0JBQUU7WUFDbEQ7UUFDSjtRQUVBZSxVQUFVO1lBQ05oQixRQUFPQyxDQUFDO2dCQUVKYixPQUFPYyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLEtBQUssR0FBRztnQkFFMUMsT0FBTyxJQUFJLENBQUNHLFNBQVMsQ0FBQztvQkFBRUMsTUFBTTtvQkFBWUMsTUFBTTt3QkFBRUw7b0JBQUU7Z0JBQUU7WUFDMUQ7WUFDQU0sVUFBU0MsS0FBSyxFQUFFQyxPQUFPLEVBQUUsRUFBRVIsQ0FBQyxFQUFFO2dCQUUxQixJQUFJTyxNQUFNRSxNQUFNLElBQUlULEdBQUc7b0JBQ25CLE9BQU9PO2dCQUNYO2dCQUVBLE9BQU9DLFFBQVFFLEtBQUssQ0FBQyxxQkFBcUI7b0JBQUVWO2dCQUFFO1lBQ2xEO1FBQ0o7SUFDSjtJQUVBZ0IsVUFBVTtRQUNOLGtCQUFrQjtRQUNsQixrQkFBa0I7UUFDbEIscUJBQXFCO1FBQ3JCLHFCQUFxQjtJQUN6QjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9mdW5jdGlvbi5qcz8yYmFiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXMuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGVvZjogJ2Z1bmN0aW9uJ1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBhcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5hcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdjbGFzcycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKC9eXFxzKmNsYXNzXFxzLykudGVzdCh2YWx1ZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLmNsYXNzJywgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW5Bcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID4gMCwgJ24gbXVzdCBiZSBhIHN0cmljdCBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluQXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLm1pbkFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heEFyaXR5OiB7XG4gICAgICAgICAgICBtZXRob2Qobikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPj0gMCwgJ24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXhBcml0eScsIGFyZ3M6IHsgbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG4gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24ubWF4QXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Z1bmN0aW9uLmFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IG9mIHt7I259fScsXG4gICAgICAgICdmdW5jdGlvbi5jbGFzcyc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBjbGFzcycsXG4gICAgICAgICdmdW5jdGlvbi5tYXhBcml0eSc6ICd7eyNsYWJlbH19IG11c3QgaGF2ZSBhbiBhcml0eSBsZXNzZXIgb3IgZXF1YWwgdG8ge3sjbn19JyxcbiAgICAgICAgJ2Z1bmN0aW9uLm1pbkFyaXR5JzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIGFuIGFyaXR5IGdyZWF0ZXIgb3IgZXF1YWwgdG8ge3sjbn19J1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbIkFzc2VydCIsInJlcXVpcmUiLCJLZXlzIiwiaW50ZXJuYWxzIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4dGVuZCIsInR5cGUiLCJwcm9wZXJ0aWVzIiwidHlwZW9mIiwicnVsZXMiLCJhcml0eSIsIm1ldGhvZCIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiJF9hZGRSdWxlIiwibmFtZSIsImFyZ3MiLCJ2YWxpZGF0ZSIsInZhbHVlIiwiaGVscGVycyIsImxlbmd0aCIsImVycm9yIiwiY2xhc3MiLCJ0ZXN0IiwidG9TdHJpbmciLCJtaW5Bcml0eSIsIm1heEFyaXR5IiwibWVzc2FnZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/function.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/keys.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/keys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst ApplyToDefaults = __webpack_require__(/*! @hapi/hoek/lib/applyToDefaults */ \"(rsc)/./node_modules/@hapi/hoek/lib/applyToDefaults.js\");\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Topo = __webpack_require__(/*! @hapi/topo */ \"(rsc)/./node_modules/@hapi/topo/lib/index.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst Ref = __webpack_require__(/*! ../ref */ \"(rsc)/./node_modules/joi/lib/ref.js\");\nconst Template = __webpack_require__(/*! ../template */ \"(rsc)/./node_modules/joi/lib/template.js\");\nconst internals = {\n    renameDefaults: {\n        alias: false,\n        multiple: false,\n        override: false // Overrides an existing key\n    }\n};\nmodule.exports = Any.extend({\n    type: \"_keys\",\n    properties: {\n        typeof: \"object\"\n    },\n    flags: {\n        unknown: {\n            default: undefined\n        }\n    },\n    terms: {\n        dependencies: {\n            init: null\n        },\n        keys: {\n            init: null,\n            manifest: {\n                mapped: {\n                    from: \"schema\",\n                    to: \"key\"\n                }\n            }\n        },\n        patterns: {\n            init: null\n        },\n        renames: {\n            init: null\n        }\n    },\n    args (schema, keys) {\n        return schema.keys(keys);\n    },\n    validate (value, { schema, error, state, prefs }) {\n        if (!value || typeof value !== schema.$_property(\"typeof\") || Array.isArray(value)) {\n            return {\n                value,\n                errors: error(\"object.base\", {\n                    type: schema.$_property(\"typeof\")\n                })\n            };\n        }\n        // Skip if there are no other rules to test\n        if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys\n        !schema.$_terms.patterns && !schema.$_terms.externals) {\n            return;\n        }\n        // Shallow clone value\n        value = internals.clone(value, prefs);\n        const errors = [];\n        // Rename keys\n        if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {\n            return {\n                value,\n                errors\n            };\n        }\n        // Anything allowed\n        if (!schema.$_terms.keys && // null allows any keys\n        !schema.$_terms.patterns && !schema.$_terms.dependencies) {\n            return {\n                value,\n                errors\n            };\n        }\n        // Defined keys\n        const unprocessed = new Set(Object.keys(value));\n        if (schema.$_terms.keys) {\n            const ancestors = [\n                value,\n                ...state.ancestors\n            ];\n            for (const child of schema.$_terms.keys){\n                const key = child.key;\n                const item = value[key];\n                unprocessed.delete(key);\n                const localState = state.localize([\n                    ...state.path,\n                    key\n                ], ancestors, child);\n                const result = child.schema.$_validate(item, localState, prefs);\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return {\n                            value,\n                            errors: result.errors\n                        };\n                    }\n                    if (result.value !== undefined) {\n                        value[key] = result.value;\n                    }\n                    errors.push(...result.errors);\n                } else if (child.schema._flags.result === \"strip\" || result.value === undefined && item !== undefined) {\n                    delete value[key];\n                } else if (result.value !== undefined) {\n                    value[key] = result.value;\n                }\n            }\n        }\n        // Unknown keys\n        if (unprocessed.size || schema._flags._hasPatternMatch) {\n            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);\n            if (early) {\n                return early;\n            }\n        }\n        // Validate dependencies\n        if (schema.$_terms.dependencies) {\n            for (const dep of schema.$_terms.dependencies){\n                if (dep.key !== null && internals.isPresent(dep.options)(dep.key.resolve(value, state, prefs, null, {\n                    shadow: false\n                })) === false) {\n                    continue;\n                }\n                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);\n                if (failed) {\n                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);\n                    if (prefs.abortEarly) {\n                        return {\n                            value,\n                            errors: report\n                        };\n                    }\n                    errors.push(report);\n                }\n            }\n        }\n        return {\n            value,\n            errors\n        };\n    },\n    rules: {\n        and: {\n            method (...peers /*, [options] */ ) {\n                Common.verifyFlat(peers, \"and\");\n                return internals.dependency(this, \"and\", null, peers);\n            }\n        },\n        append: {\n            method (schema) {\n                if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n                    return this;\n                }\n                return this.keys(schema);\n            }\n        },\n        assert: {\n            method (subject, schema, message) {\n                if (!Template.isTemplate(subject)) {\n                    subject = Compile.ref(subject);\n                }\n                Assert(message === undefined || typeof message === \"string\", \"Message must be a string\");\n                schema = this.$_compile(schema, {\n                    appendPath: true\n                });\n                const obj = this.$_addRule({\n                    name: \"assert\",\n                    args: {\n                        subject,\n                        schema,\n                        message\n                    }\n                });\n                obj.$_mutateRegister(subject);\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate (value, { error, prefs, state }, { subject, schema, message }) {\n                const about = subject.resolve(value, state, prefs);\n                const path = Ref.isRef(subject) ? subject.absolute(state) : [];\n                if (schema.$_match(about, state.localize(path, [\n                    value,\n                    ...state.ancestors\n                ], schema), prefs)) {\n                    return value;\n                }\n                return error(\"object.assert\", {\n                    subject,\n                    message\n                });\n            },\n            args: [\n                \"subject\",\n                \"schema\",\n                \"message\"\n            ],\n            multi: true\n        },\n        instance: {\n            method (constructor, name) {\n                Assert(typeof constructor === \"function\", \"constructor must be a function\");\n                name = name || constructor.name;\n                return this.$_addRule({\n                    name: \"instance\",\n                    args: {\n                        constructor,\n                        name\n                    }\n                });\n            },\n            validate (value, helpers, { constructor, name }) {\n                if (value instanceof constructor) {\n                    return value;\n                }\n                return helpers.error(\"object.instance\", {\n                    type: name,\n                    value\n                });\n            },\n            args: [\n                \"constructor\",\n                \"name\"\n            ]\n        },\n        keys: {\n            method (schema) {\n                Assert(schema === undefined || typeof schema === \"object\", \"Object schema must be a valid object\");\n                Assert(!Common.isSchema(schema), \"Object schema cannot be a joi schema\");\n                const obj = this.clone();\n                if (!schema) {\n                    obj.$_terms.keys = null;\n                } else if (!Object.keys(schema).length) {\n                    obj.$_terms.keys = new internals.Keys();\n                } else {\n                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child)=>!schema.hasOwnProperty(child.key)) : new internals.Keys();\n                    for(const key in schema){\n                        Common.tryWithPath(()=>obj.$_terms.keys.push({\n                                key,\n                                schema: this.$_compile(schema[key])\n                            }), key);\n                    }\n                }\n                return obj.$_mutateRebuild();\n            }\n        },\n        length: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \"=\"\n                });\n            },\n            validate (value, helpers, { limit }, { name, operator, args }) {\n                if (Common.compare(Object.keys(value).length, limit, operator)) {\n                    return value;\n                }\n                return helpers.error(\"object.\" + name, {\n                    limit: args.limit,\n                    value\n                });\n            },\n            args: [\n                {\n                    name: \"limit\",\n                    ref: true,\n                    assert: Common.limit,\n                    message: \"must be a positive integer\"\n                }\n            ]\n        },\n        max: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"max\",\n                    method: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \"<=\"\n                });\n            }\n        },\n        min: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"min\",\n                    method: \"length\",\n                    args: {\n                        limit\n                    },\n                    operator: \">=\"\n                });\n            }\n        },\n        nand: {\n            method (...peers /*, [options] */ ) {\n                Common.verifyFlat(peers, \"nand\");\n                return internals.dependency(this, \"nand\", null, peers);\n            }\n        },\n        or: {\n            method (...peers /*, [options] */ ) {\n                Common.verifyFlat(peers, \"or\");\n                return internals.dependency(this, \"or\", null, peers);\n            }\n        },\n        oxor: {\n            method (...peers /*, [options] */ ) {\n                return internals.dependency(this, \"oxor\", null, peers);\n            }\n        },\n        pattern: {\n            method (pattern, schema, options = {}) {\n                const isRegExp = pattern instanceof RegExp;\n                if (!isRegExp) {\n                    pattern = this.$_compile(pattern, {\n                        appendPath: true\n                    });\n                }\n                Assert(schema !== undefined, \"Invalid rule\");\n                Common.assertOptions(options, [\n                    \"fallthrough\",\n                    \"matches\"\n                ]);\n                if (isRegExp) {\n                    Assert(!pattern.flags.includes(\"g\") && !pattern.flags.includes(\"y\"), \"pattern should not use global or sticky mode\");\n                }\n                schema = this.$_compile(schema, {\n                    appendPath: true\n                });\n                const obj = this.clone();\n                obj.$_terms.patterns = obj.$_terms.patterns || [];\n                const config = {\n                    [isRegExp ? \"regex\" : \"schema\"]: pattern,\n                    rule: schema\n                };\n                if (options.matches) {\n                    config.matches = this.$_compile(options.matches);\n                    if (config.matches.type !== \"array\") {\n                        config.matches = config.matches.$_root.array().items(config.matches);\n                    }\n                    obj.$_mutateRegister(config.matches);\n                    obj.$_setFlag(\"_hasPatternMatch\", true, {\n                        clone: false\n                    });\n                }\n                if (options.fallthrough) {\n                    config.fallthrough = true;\n                }\n                obj.$_terms.patterns.push(config);\n                obj.$_mutateRegister(schema);\n                return obj;\n            }\n        },\n        ref: {\n            method () {\n                return this.$_addRule(\"ref\");\n            },\n            validate (value, helpers) {\n                if (Ref.isRef(value)) {\n                    return value;\n                }\n                return helpers.error(\"object.refType\", {\n                    value\n                });\n            }\n        },\n        regex: {\n            method () {\n                return this.$_addRule(\"regex\");\n            },\n            validate (value, helpers) {\n                if (value instanceof RegExp) {\n                    return value;\n                }\n                return helpers.error(\"object.regex\", {\n                    value\n                });\n            }\n        },\n        rename: {\n            method (from, to, options = {}) {\n                Assert(typeof from === \"string\" || from instanceof RegExp, \"Rename missing the from argument\");\n                Assert(typeof to === \"string\" || to instanceof Template, \"Invalid rename to argument\");\n                Assert(to !== from, \"Cannot rename key to same name:\", from);\n                Common.assertOptions(options, [\n                    \"alias\",\n                    \"ignoreUndefined\",\n                    \"override\",\n                    \"multiple\"\n                ]);\n                const obj = this.clone();\n                obj.$_terms.renames = obj.$_terms.renames || [];\n                for (const rename of obj.$_terms.renames){\n                    Assert(rename.from !== from, \"Cannot rename the same key multiple times\");\n                }\n                if (to instanceof Template) {\n                    obj.$_mutateRegister(to);\n                }\n                obj.$_terms.renames.push({\n                    from,\n                    to,\n                    options: ApplyToDefaults(internals.renameDefaults, options)\n                });\n                return obj;\n            }\n        },\n        schema: {\n            method (type = \"any\") {\n                return this.$_addRule({\n                    name: \"schema\",\n                    args: {\n                        type\n                    }\n                });\n            },\n            validate (value, helpers, { type }) {\n                if (Common.isSchema(value) && (type === \"any\" || value.type === type)) {\n                    return value;\n                }\n                return helpers.error(\"object.schema\", {\n                    type\n                });\n            }\n        },\n        unknown: {\n            method (allow) {\n                return this.$_setFlag(\"unknown\", allow !== false);\n            }\n        },\n        with: {\n            method (key, peers, options = {}) {\n                return internals.dependency(this, \"with\", key, peers, options);\n            }\n        },\n        without: {\n            method (key, peers, options = {}) {\n                return internals.dependency(this, \"without\", key, peers, options);\n            }\n        },\n        xor: {\n            method (...peers /*, [options] */ ) {\n                Common.verifyFlat(peers, \"xor\");\n                return internals.dependency(this, \"xor\", null, peers);\n            }\n        }\n    },\n    overrides: {\n        default (value, options) {\n            if (value === undefined) {\n                value = Common.symbols.deepDefault;\n            }\n            return this.$_parent(\"default\", value, options);\n        }\n    },\n    rebuild (schema) {\n        if (schema.$_terms.keys) {\n            const topo = new Topo.Sorter();\n            for (const child of schema.$_terms.keys){\n                Common.tryWithPath(()=>topo.add(child, {\n                        after: child.schema.$_rootReferences(),\n                        group: child.key\n                    }), child.key);\n            }\n            schema.$_terms.keys = new internals.Keys(...topo.nodes);\n        }\n    },\n    manifest: {\n        build (obj, desc) {\n            if (desc.keys) {\n                obj = obj.keys(desc.keys);\n            }\n            if (desc.dependencies) {\n                for (const { rel, key = null, peers, options } of desc.dependencies){\n                    obj = internals.dependency(obj, rel, key, peers, options);\n                }\n            }\n            if (desc.patterns) {\n                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns){\n                    obj = obj.pattern(regex || schema, rule, {\n                        fallthrough,\n                        matches\n                    });\n                }\n            }\n            if (desc.renames) {\n                for (const { from, to, options } of desc.renames){\n                    obj = obj.rename(from, to, options);\n                }\n            }\n            return obj;\n        }\n    },\n    messages: {\n        \"object.and\": \"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}\",\n        \"object.assert\": '{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}',\n        \"object.base\": \"{{#label}} must be of type {{#type}}\",\n        \"object.instance\": \"{{#label}} must be an instance of {{:#type}}\",\n        \"object.length\": '{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        \"object.max\": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        \"object.min\": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        \"object.missing\": \"{{#label}} must contain at least one of {{#peersWithLabels}}\",\n        \"object.nand\": \"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}\",\n        \"object.oxor\": \"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}\",\n        \"object.pattern.match\": \"{{#label}} keys failed to match pattern requirements\",\n        \"object.refType\": \"{{#label}} must be a Joi reference\",\n        \"object.regex\": \"{{#label}} must be a RegExp object\",\n        \"object.rename.multiple\": \"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}\",\n        \"object.rename.override\": \"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists\",\n        \"object.schema\": \"{{#label}} must be a Joi schema of {{#type}} type\",\n        \"object.unknown\": \"{{#label}} is not allowed\",\n        \"object.with\": \"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}\",\n        \"object.without\": \"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}\",\n        \"object.xor\": \"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}\"\n    }\n});\n// Helpers\ninternals.clone = function(value, prefs) {\n    // Object\n    if (typeof value === \"object\") {\n        if (prefs.nonEnumerables) {\n            return Clone(value, {\n                shallow: true\n            });\n        }\n        const clone = Object.create(Object.getPrototypeOf(value));\n        Object.assign(clone, value);\n        return clone;\n    }\n    // Function\n    const clone = function(...args) {\n        return value.apply(this, args);\n    };\n    clone.prototype = Clone(value.prototype);\n    Object.defineProperty(clone, \"name\", {\n        value: value.name,\n        writable: false\n    });\n    Object.defineProperty(clone, \"length\", {\n        value: value.length,\n        writable: false\n    });\n    Object.assign(clone, value);\n    return clone;\n};\ninternals.dependency = function(schema, rel, key, peers, options) {\n    Assert(key === null || typeof key === \"string\", rel, \"key must be a strings\");\n    // Extract options from peers array\n    if (!options) {\n        options = peers.length > 1 && typeof peers[peers.length - 1] === \"object\" ? peers.pop() : {};\n    }\n    Common.assertOptions(options, [\n        \"separator\",\n        \"isPresent\"\n    ]);\n    peers = [].concat(peers);\n    // Cast peer paths\n    const separator = Common.default(options.separator, \".\");\n    const paths = [];\n    for (const peer of peers){\n        Assert(typeof peer === \"string\", rel, \"peers must be strings\");\n        paths.push(Compile.ref(peer, {\n            separator,\n            ancestor: 0,\n            prefix: false\n        }));\n    }\n    // Cast key\n    if (key !== null) {\n        key = Compile.ref(key, {\n            separator,\n            ancestor: 0,\n            prefix: false\n        });\n    }\n    // Add rule\n    const obj = schema.clone();\n    obj.$_terms.dependencies = obj.$_terms.dependencies || [];\n    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers, options));\n    return obj;\n};\ninternals.dependencies = {\n    and (schema, dep, value, state, prefs) {\n        const missing = [];\n        const present = [];\n        const count = dep.peers.length;\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers){\n            if (isPresent(peer.resolve(value, state, prefs, null, {\n                shadow: false\n            })) === false) {\n                missing.push(peer.key);\n            } else {\n                present.push(peer.key);\n            }\n        }\n        if (missing.length !== count && present.length !== count) {\n            return {\n                code: \"object.and\",\n                context: {\n                    present,\n                    presentWithLabels: internals.keysToLabels(schema, present),\n                    missing,\n                    missingWithLabels: internals.keysToLabels(schema, missing)\n                }\n            };\n        }\n    },\n    nand (schema, dep, value, state, prefs) {\n        const present = [];\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers){\n            if (isPresent(peer.resolve(value, state, prefs, null, {\n                shadow: false\n            }))) {\n                present.push(peer.key);\n            }\n        }\n        if (present.length !== dep.peers.length) {\n            return;\n        }\n        const main = dep.paths[0];\n        const values = dep.paths.slice(1);\n        return {\n            code: \"object.nand\",\n            context: {\n                main,\n                mainWithLabel: internals.keysToLabels(schema, main),\n                peers: values,\n                peersWithLabels: internals.keysToLabels(schema, values)\n            }\n        };\n    },\n    or (schema, dep, value, state, prefs) {\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers){\n            if (isPresent(peer.resolve(value, state, prefs, null, {\n                shadow: false\n            }))) {\n                return;\n            }\n        }\n        return {\n            code: \"object.missing\",\n            context: {\n                peers: dep.paths,\n                peersWithLabels: internals.keysToLabels(schema, dep.paths)\n            }\n        };\n    },\n    oxor (schema, dep, value, state, prefs) {\n        const present = [];\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers){\n            if (isPresent(peer.resolve(value, state, prefs, null, {\n                shadow: false\n            }))) {\n                present.push(peer.key);\n            }\n        }\n        if (!present.length || present.length === 1) {\n            return;\n        }\n        const context = {\n            peers: dep.paths,\n            peersWithLabels: internals.keysToLabels(schema, dep.paths)\n        };\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return {\n            code: \"object.oxor\",\n            context\n        };\n    },\n    with (schema, dep, value, state, prefs) {\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers){\n            if (isPresent(peer.resolve(value, state, prefs, null, {\n                shadow: false\n            })) === false) {\n                return {\n                    code: \"object.with\",\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n    without (schema, dep, value, state, prefs) {\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers){\n            if (isPresent(peer.resolve(value, state, prefs, null, {\n                shadow: false\n            }))) {\n                return {\n                    code: \"object.without\",\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n    xor (schema, dep, value, state, prefs) {\n        const present = [];\n        const isPresent = internals.isPresent(dep.options);\n        for (const peer of dep.peers){\n            if (isPresent(peer.resolve(value, state, prefs, null, {\n                shadow: false\n            }))) {\n                present.push(peer.key);\n            }\n        }\n        if (present.length === 1) {\n            return;\n        }\n        const context = {\n            peers: dep.paths,\n            peersWithLabels: internals.keysToLabels(schema, dep.paths)\n        };\n        if (present.length === 0) {\n            return {\n                code: \"object.missing\",\n                context\n            };\n        }\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return {\n            code: \"object.xor\",\n            context\n        };\n    }\n};\ninternals.keysToLabels = function(schema, keys) {\n    if (Array.isArray(keys)) {\n        return keys.map((key)=>schema.$_mapLabels(key));\n    }\n    return schema.$_mapLabels(keys);\n};\ninternals.isPresent = function(options) {\n    return typeof options.isPresent === \"function\" ? options.isPresent : (resolved)=>resolved !== undefined;\n};\ninternals.rename = function(schema, value, state, prefs, errors) {\n    const renamed = {};\n    for (const rename of schema.$_terms.renames){\n        const matches = [];\n        const pattern = typeof rename.from !== \"string\";\n        if (!pattern) {\n            if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {\n                matches.push(rename);\n            }\n        } else {\n            for(const from in value){\n                if (value[from] === undefined && rename.options.ignoreUndefined) {\n                    continue;\n                }\n                if (from === rename.to) {\n                    continue;\n                }\n                const match = rename.from.exec(from);\n                if (!match) {\n                    continue;\n                }\n                matches.push({\n                    from,\n                    to: rename.to,\n                    match\n                });\n            }\n        }\n        for (const match of matches){\n            const from = match.from;\n            let to = match.to;\n            if (to instanceof Template) {\n                to = to.render(value, state, prefs, match.match);\n            }\n            if (from === to) {\n                continue;\n            }\n            if (!rename.options.multiple && renamed[to]) {\n                errors.push(schema.$_createError(\"object.rename.multiple\", value, {\n                    from,\n                    to,\n                    pattern\n                }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n            if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {\n                errors.push(schema.$_createError(\"object.rename.override\", value, {\n                    from,\n                    to,\n                    pattern\n                }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n            if (value[from] === undefined) {\n                delete value[to];\n            } else {\n                value[to] = value[from];\n            }\n            renamed[to] = true;\n            if (!rename.options.alias) {\n                delete value[from];\n            }\n        }\n    }\n    return true;\n};\ninternals.unknown = function(schema, value, unprocessed, errors, state, prefs) {\n    if (schema.$_terms.patterns) {\n        let hasMatches = false;\n        const matches = schema.$_terms.patterns.map((pattern)=>{\n            if (pattern.matches) {\n                hasMatches = true;\n                return [];\n            }\n        });\n        const ancestors = [\n            value,\n            ...state.ancestors\n        ];\n        for (const key of unprocessed){\n            const item = value[key];\n            const path = [\n                ...state.path,\n                key\n            ];\n            for(let i = 0; i < schema.$_terms.patterns.length; ++i){\n                const pattern = schema.$_terms.patterns[i];\n                if (pattern.regex) {\n                    const match = pattern.regex.test(key);\n                    state.mainstay.tracer.debug(state, \"rule\", `pattern.${i}`, match ? \"pass\" : \"error\");\n                    if (!match) {\n                        continue;\n                    }\n                } else {\n                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {\n                        continue;\n                    }\n                }\n                unprocessed.delete(key);\n                const localState = state.localize(path, ancestors, {\n                    schema: pattern.rule,\n                    key\n                });\n                const result = pattern.rule.$_validate(item, localState, prefs);\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return {\n                            value,\n                            errors: result.errors\n                        };\n                    }\n                    errors.push(...result.errors);\n                }\n                if (pattern.matches) {\n                    matches[i].push(key);\n                }\n                value[key] = result.value;\n                if (!pattern.fallthrough) {\n                    break;\n                }\n            }\n        }\n        // Validate pattern matches rules\n        if (hasMatches) {\n            for(let i = 0; i < matches.length; ++i){\n                const match = matches[i];\n                if (!match) {\n                    continue;\n                }\n                const stpm = schema.$_terms.patterns[i].matches;\n                const localState = state.localize(state.path, ancestors, stpm);\n                const result = stpm.$_validate(match, localState, prefs);\n                if (result.errors) {\n                    const details = Errors.details(result.errors, {\n                        override: false\n                    });\n                    details.matches = match;\n                    const report = schema.$_createError(\"object.pattern.match\", value, details, state, prefs);\n                    if (prefs.abortEarly) {\n                        return {\n                            value,\n                            errors: report\n                        };\n                    }\n                    errors.push(report);\n                }\n            }\n        }\n    }\n    if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {\n        return;\n    }\n    if (prefs.stripUnknown && typeof schema._flags.unknown === \"undefined\" || prefs.skipFunctions) {\n        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;\n        for (const key of unprocessed){\n            if (stripUnknown) {\n                delete value[key];\n                unprocessed.delete(key);\n            } else if (typeof value[key] === \"function\") {\n                unprocessed.delete(key);\n            }\n        }\n    }\n    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);\n    if (forbidUnknown) {\n        for (const unprocessedKey of unprocessed){\n            const localState = state.localize([\n                ...state.path,\n                unprocessedKey\n            ], []);\n            const report = schema.$_createError(\"object.unknown\", value[unprocessedKey], {\n                child: unprocessedKey\n            }, localState, prefs, {\n                flags: false\n            });\n            if (prefs.abortEarly) {\n                return {\n                    value,\n                    errors: report\n                };\n            }\n            errors.push(report);\n        }\n    }\n};\ninternals.Dependency = class {\n    constructor(rel, key, peers, paths, options){\n        this.rel = rel;\n        this.key = key;\n        this.peers = peers;\n        this.paths = paths;\n        this.options = options;\n    }\n    describe() {\n        const desc = {\n            rel: this.rel,\n            peers: this.paths\n        };\n        if (this.key !== null) {\n            desc.key = this.key.key;\n        }\n        if (this.peers[0].separator !== \".\") {\n            desc.options = {\n                ...desc.options,\n                separator: this.peers[0].separator\n            };\n        }\n        if (this.options.isPresent) {\n            desc.options = {\n                ...desc.options,\n                isPresent: this.options.isPresent\n            };\n        }\n        return desc;\n    }\n};\ninternals.Keys = class extends Array {\n    concat(source) {\n        const result = this.slice();\n        const keys = new Map();\n        for(let i = 0; i < result.length; ++i){\n            keys.set(result[i].key, i);\n        }\n        for (const item of source){\n            const key = item.key;\n            const pos = keys.get(key);\n            if (pos !== undefined) {\n                result[pos] = {\n                    key,\n                    schema: result[pos].schema.concat(item.schema)\n                };\n            } else {\n                result.push(item);\n            }\n        }\n        return result;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9rZXlzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsa0JBQWtCQyxtQkFBT0EsQ0FBQztBQUNoQyxNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUN0QixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUVyQixNQUFNSSxNQUFNSixtQkFBT0EsQ0FBQztBQUNwQixNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNTSxVQUFVTixtQkFBT0EsQ0FBQztBQUN4QixNQUFNTyxTQUFTUCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNUSxNQUFNUixtQkFBT0EsQ0FBQztBQUNwQixNQUFNUyxXQUFXVCxtQkFBT0EsQ0FBQztBQUd6QixNQUFNVSxZQUFZO0lBQ2RDLGdCQUFnQjtRQUNaQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsVUFBVSxNQUFzQiw0QkFBNEI7SUFDaEU7QUFDSjtBQUdBQyxPQUFPQyxPQUFPLEdBQUdaLElBQUlhLE1BQU0sQ0FBQztJQUV4QkMsTUFBTTtJQUVOQyxZQUFZO1FBRVJDLFFBQVE7SUFDWjtJQUVBQyxPQUFPO1FBRUhDLFNBQVM7WUFBRUMsU0FBU0M7UUFBVTtJQUNsQztJQUVBQyxPQUFPO1FBRUhDLGNBQWM7WUFBRUMsTUFBTTtRQUFLO1FBQzNCQyxNQUFNO1lBQUVELE1BQU07WUFBTUUsVUFBVTtnQkFBRUMsUUFBUTtvQkFBRUMsTUFBTTtvQkFBVUMsSUFBSTtnQkFBTTtZQUFFO1FBQUU7UUFDeEVDLFVBQVU7WUFBRU4sTUFBTTtRQUFLO1FBQ3ZCTyxTQUFTO1lBQUVQLE1BQU07UUFBSztJQUMxQjtJQUVBUSxNQUFLQyxNQUFNLEVBQUVSLElBQUk7UUFFYixPQUFPUSxPQUFPUixJQUFJLENBQUNBO0lBQ3ZCO0lBRUFTLFVBQVNDLEtBQUssRUFBRSxFQUFFRixNQUFNLEVBQUVHLEtBQUssRUFBRUMsS0FBSyxFQUFF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T0csSUFBSSxDQUFDUjtZQUNoQjtRQUNKO1FBRUEsT0FBT0s7SUFDWDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9rZXlzLmpzPzdjNjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBcHBseVRvRGVmYXVsdHMgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hcHBseVRvRGVmYXVsdHMnKTtcbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgVG9wbyA9IHJlcXVpcmUoJ0BoYXBpL3RvcG8nKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4uL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi4vcmVmJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlbmFtZURlZmF1bHRzOiB7XG4gICAgICAgIGFsaWFzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvbGQgdmFsdWUgaW4gcGxhY2VcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLCAgICAgICAgICAgICAgICAvLyBBbGxvdyByZW5hbWluZyBtdWx0aXBsZSBrZXlzIGludG8gdGhlIHNhbWUgdGFyZ2V0XG4gICAgICAgIG92ZXJyaWRlOiBmYWxzZSAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGFuIGV4aXN0aW5nIGtleVxuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdfa2V5cycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAgICAgdHlwZW9mOiAnb2JqZWN0J1xuICAgIH0sXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHVua25vd246IHsgZGVmYXVsdDogdW5kZWZpbmVkIH1cbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBkZXBlbmRlbmNpZXM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBrZXlzOiB7IGluaXQ6IG51bGwsIG1hbmlmZXN0OiB7IG1hcHBlZDogeyBmcm9tOiAnc2NoZW1hJywgdG86ICdrZXknIH0gfSB9LFxuICAgICAgICBwYXR0ZXJuczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIHJlbmFtZXM6IHsgaW5pdDogbnVsbCB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCBrZXlzKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5rZXlzKGtleXMpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gc2NoZW1hLiRfcHJvcGVydHkoJ3R5cGVvZicpIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignb2JqZWN0LmJhc2UnLCB7IHR5cGU6IHNjaGVtYS4kX3Byb3BlcnR5KCd0eXBlb2YnKSB9KSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBpZiB0aGVyZSBhcmUgbm8gb3RoZXIgcnVsZXMgdG8gdGVzdFxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfdGVybXMucmVuYW1lcyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmtleXMgJiYgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGwgYWxsb3dzIGFueSBrZXlzXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hhbGxvdyBjbG9uZSB2YWx1ZVxuXG4gICAgICAgIHZhbHVlID0gaW50ZXJuYWxzLmNsb25lKHZhbHVlLCBwcmVmcyk7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgICAgIC8vIFJlbmFtZSBrZXlzXG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMgJiZcbiAgICAgICAgICAgICFpbnRlcm5hbHMucmVuYW1lKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcywgZXJyb3JzKSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbnl0aGluZyBhbGxvd2VkXG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZWQga2V5c1xuXG4gICAgICAgIGNvbnN0IHVucHJvY2Vzc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBrZXldLCBhbmNlc3RvcnMsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGlsZC5zY2hlbWEuJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVzdWx0LmVycm9ycyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnNjaGVtYS5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVua25vd24ga2V5c1xuXG4gICAgICAgIGlmICh1bnByb2Nlc3NlZC5zaXplIHx8XG4gICAgICAgICAgICBzY2hlbWEuX2ZsYWdzLl9oYXNQYXR0ZXJuTWF0Y2gpIHtcblxuICAgICAgICAgICAgY29uc3QgZWFybHkgPSBpbnRlcm5hbHMudW5rbm93bihzY2hlbWEsIHZhbHVlLCB1bnByb2Nlc3NlZCwgZXJyb3JzLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKGVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhcmx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgZGVwZW5kZW5jaWVzXG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXAgb2Ygc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBkZXAua2V5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpKGRlcC5rZXkucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWxlZCA9IGludGVybmFscy5kZXBlbmRlbmNpZXNbZGVwLnJlbF0oc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoZmFpbGVkLmNvZGUsIHZhbHVlLCBmYWlsZWQuY29udGV4dCwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlcG9ydCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgYW5kOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICdhbmQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnYW5kJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFwcGVuZDoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhc3NlcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgICAgIGlmICghVGVtcGxhdGUuaXNUZW1wbGF0ZShzdWJqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0ID0gQ29tcGlsZS5yZWYoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycsICdNZXNzYWdlIG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXNzZXJ0JywgYXJnczogeyBzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzdWJqZWN0KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IsIHByZWZzLCBzdGF0ZSB9LCB7IHN1YmplY3QsIHNjaGVtYSwgbWVzc2FnZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhYm91dCA9IHN1YmplY3QucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gUmVmLmlzUmVmKHN1YmplY3QpID8gc3ViamVjdC5hYnNvbHV0ZShzdGF0ZSkgOiBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLiRfbWF0Y2goYWJvdXQsIHN0YXRlLmxvY2FsaXplKHBhdGgsIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSwgc2NoZW1hKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ29iamVjdC5hc3NlcnQnLCB7IHN1YmplY3QsIG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydzdWJqZWN0JywgJ3NjaGVtYScsICdtZXNzYWdlJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGluc3RhbmNlOiB7XG4gICAgICAgICAgICBtZXRob2QoY29uc3RydWN0b3IsIG5hbWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicsICdjb25zdHJ1Y3RvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaW5zdGFuY2UnLCBhcmdzOiB7IGNvbnN0cnVjdG9yLCBuYW1lIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgY29uc3RydWN0b3IsIG5hbWUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QuaW5zdGFuY2UnLCB7IHR5cGU6IG5hbWUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnY29uc3RydWN0b3InLCAnbmFtZSddXG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5czoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnLCAnT2JqZWN0IHNjaGVtYSBtdXN0IGJlIGEgdmFsaWQgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFDb21tb24uaXNTY2hlbWEoc2NoZW1hKSwgJ09iamVjdCBzY2hlbWEgY2Fubm90IGJlIGEgam9pIHNjaGVtYScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFsbFxuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5rZXlzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoKSB7ICAgICAgICAgICAgIC8vIEFsbG93IG5vbmVcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG5ldyBpbnRlcm5hbHMuS2V5cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG9iai4kX3Rlcm1zLmtleXMgPyBvYmouJF90ZXJtcy5rZXlzLmZpbHRlcigoY2hpbGQpID0+ICFzY2hlbWEuaGFzT3duUHJvcGVydHkoY2hpbGQua2V5KSkgOiBuZXcgaW50ZXJuYWxzLktleXMoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gb2JqLiRfdGVybXMua2V5cy5wdXNoKHsga2V5LCBzY2hlbWE6IHRoaXMuJF9jb21waWxlKHNjaGVtYVtrZXldKSB9KSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5hbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ25hbmQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnbmFuZCcsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnb3InKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnb3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3hvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnb3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVnRXhwID0gcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLiRfY29tcGlsZShwYXR0ZXJuLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYSAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydmYWxsdGhyb3VnaCcsICdtYXRjaGVzJ10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghcGF0dGVybi5mbGFncy5pbmNsdWRlcygnZycpICYmICFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCd5JyksICdwYXR0ZXJuIHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnBhdHRlcm5zID0gb2JqLiRfdGVybXMucGF0dGVybnMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0geyBbaXNSZWdFeHAgPyAncmVnZXgnIDogJ3NjaGVtYSddOiBwYXR0ZXJuLCBydWxlOiBzY2hlbWEgfTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXRjaGVzID0gdGhpcy4kX2NvbXBpbGUob3B0aW9ucy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXRjaGVzLnR5cGUgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXRjaGVzID0gY29uZmlnLm1hdGNoZXMuJF9yb290LmFycmF5KCkuaXRlbXMoY29uZmlnLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoY29uZmlnLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF9zZXRGbGFnKCdfaGFzUGF0dGVybk1hdGNoJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmFsbHRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmZhbGx0aHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5wYXR0ZXJucy5wdXNoKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdyZWYnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QucmVmVHlwZScsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncmVnZXgnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnJlZ2V4JywgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW5hbWU6IHtcbiAgICAgICAgICAgIG1ldGhvZChmcm9tLCB0bywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGZyb20gPT09ICdzdHJpbmcnIHx8IGZyb20gaW5zdGFuY2VvZiBSZWdFeHAsICdSZW5hbWUgbWlzc2luZyB0aGUgZnJvbSBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8IHRvIGluc3RhbmNlb2YgVGVtcGxhdGUsICdJbnZhbGlkIHJlbmFtZSB0byBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0byAhPT0gZnJvbSwgJ0Nhbm5vdCByZW5hbWUga2V5IHRvIHNhbWUgbmFtZTonLCBmcm9tKTtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxpYXMnLCAnaWdub3JlVW5kZWZpbmVkJywgJ292ZXJyaWRlJywgJ211bHRpcGxlJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVuYW1lcyA9IG9iai4kX3Rlcm1zLnJlbmFtZXMgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZW5hbWUgb2Ygb2JqLiRfdGVybXMucmVuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQocmVuYW1lLmZyb20gIT09IGZyb20sICdDYW5ub3QgcmVuYW1lIHRoZSBzYW1lIGtleSBtdWx0aXBsZSB0aW1lcycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0byBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHRvKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5yZW5hbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogQXBwbHlUb0RlZmF1bHRzKGludGVybmFscy5yZW5hbWVEZWZhdWx0cywgb3B0aW9ucylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICBtZXRob2QodHlwZSA9ICdhbnknKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc2NoZW1hJywgYXJnczogeyB0eXBlIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgdHlwZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZSA9PT0gJ2FueScgfHwgdmFsdWUudHlwZSA9PT0gdHlwZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC5zY2hlbWEnLCB7IHR5cGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5rbm93bjoge1xuICAgICAgICAgICAgbWV0aG9kKGFsbG93KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Vua25vd24nLCBhbGxvdyAhPT0gZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdpdGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChrZXksIHBlZXJzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnd2l0aCcsIGtleSwgcGVlcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdpdGhvdXQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChrZXksIHBlZXJzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnd2l0aG91dCcsIGtleSwgcGVlcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHhvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAneG9yJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBkZWZhdWx0KHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9wYXJlbnQoJ2RlZmF1bHQnLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgY29uc3QgdG9wbyA9IG5ldyBUb3BvLlNvcnRlcigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRvcG8uYWRkKGNoaWxkLCB7IGFmdGVyOiBjaGlsZC5zY2hlbWEuJF9yb290UmVmZXJlbmNlcygpLCBncm91cDogY2hpbGQua2V5IH0pLCBjaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5rZXlzID0gbmV3IGludGVybmFscy5LZXlzKC4uLnRvcG8ubm9kZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmtleXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoua2V5cyhkZXNjLmtleXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVsLCBrZXkgPSBudWxsLCBwZWVycywgb3B0aW9ucyB9IG9mIGRlc2MuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGludGVybmFscy5kZXBlbmRlbmN5KG9iaiwgcmVsLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlZ2V4LCBzY2hlbWEsIHJ1bGUsIGZhbGx0aHJvdWdoLCBtYXRjaGVzIH0gb2YgZGVzYy5wYXR0ZXJucykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucGF0dGVybihyZWdleCB8fCBzY2hlbWEsIHJ1bGUsIHsgZmFsbHRocm91Z2gsIG1hdGNoZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGZyb20sIHRvLCBvcHRpb25zIH0gb2YgZGVzYy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5yZW5hbWUoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnb2JqZWN0LmFuZCc6ICd7eyNsYWJlbH19IGNvbnRhaW5zIHt7I3ByZXNlbnRXaXRoTGFiZWxzfX0gd2l0aG91dCBpdHMgcmVxdWlyZWQgcGVlcnMge3sjbWlzc2luZ1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QuYXNzZXJ0JzogJ3t7I2xhYmVsfX0gaXMgaW52YWxpZCBiZWNhdXNlIHtpZigjc3ViamVjdC5rZXksIGBcImAgKyAjc3ViamVjdC5rZXkgKyBgXCIgZmFpbGVkIHRvIGAgKyAoI21lc3NhZ2UgfHwgXCJwYXNzIHRoZSBhc3NlcnRpb24gdGVzdFwiKSwgI21lc3NhZ2UgfHwgXCJ0aGUgYXNzZXJ0aW9uIGZhaWxlZFwiKX0nLFxuICAgICAgICAnb2JqZWN0LmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIG9mIHR5cGUge3sjdHlwZX19JyxcbiAgICAgICAgJ29iamVjdC5pbnN0YW5jZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge3s6I3R5cGV9fScsXG4gICAgICAgICdvYmplY3QubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbXVzdCBoYXZlIHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgYXQgbGVhc3Qge3sjbGltaXR9fSBrZXl7aWYoI2xpbWl0ID09IDEsIFwiXCIsIFwic1wiKX0nLFxuICAgICAgICAnb2JqZWN0Lm1pc3NpbmcnOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHt7I3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgJ29iamVjdC5uYW5kJzogJ3t7OiNtYWluV2l0aExhYmVsfX0gbXVzdCBub3QgZXhpc3Qgc2ltdWx0YW5lb3VzbHkgd2l0aCB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3Qub3hvcic6ICd7eyNsYWJlbH19IGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBvcHRpb25hbCBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LnBhdHRlcm4ubWF0Y2gnOiAne3sjbGFiZWx9fSBrZXlzIGZhaWxlZCB0byBtYXRjaCBwYXR0ZXJuIHJlcXVpcmVtZW50cycsXG4gICAgICAgICdvYmplY3QucmVmVHlwZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBKb2kgcmVmZXJlbmNlJyxcbiAgICAgICAgJ29iamVjdC5yZWdleCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBSZWdFeHAgb2JqZWN0JyxcbiAgICAgICAgJ29iamVjdC5yZW5hbWUubXVsdGlwbGUnOiAne3sjbGFiZWx9fSBjYW5ub3QgcmVuYW1lIHt7OiNmcm9tfX0gYmVjYXVzZSBtdWx0aXBsZSByZW5hbWVzIGFyZSBkaXNhYmxlZCBhbmQgYW5vdGhlciBrZXkgd2FzIGFscmVhZHkgcmVuYW1lZCB0byB7ezojdG99fScsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm92ZXJyaWRlJzogJ3t7I2xhYmVsfX0gY2Fubm90IHJlbmFtZSB7ezojZnJvbX19IGJlY2F1c2Ugb3ZlcnJpZGUgaXMgZGlzYWJsZWQgYW5kIHRhcmdldCB7ezojdG99fSBleGlzdHMnLFxuICAgICAgICAnb2JqZWN0LnNjaGVtYSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBKb2kgc2NoZW1hIG9mIHt7I3R5cGV9fSB0eXBlJyxcbiAgICAgICAgJ29iamVjdC51bmtub3duJzogJ3t7I2xhYmVsfX0gaXMgbm90IGFsbG93ZWQnLFxuICAgICAgICAnb2JqZWN0LndpdGgnOiAne3s6I21haW5XaXRoTGFiZWx9fSBtaXNzaW5nIHJlcXVpcmVkIHBlZXIge3s6I3BlZXJXaXRoTGFiZWx9fScsXG4gICAgICAgICdvYmplY3Qud2l0aG91dCc6ICd7ezojbWFpbldpdGhMYWJlbH19IGNvbmZsaWN0IHdpdGggZm9yYmlkZGVuIHBlZXIge3s6I3BlZXJXaXRoTGFiZWx9fScsXG4gICAgICAgICdvYmplY3QueG9yJzogJ3t7I2xhYmVsfX0gY29udGFpbnMgYSBjb25mbGljdCBiZXR3ZWVuIGV4Y2x1c2l2ZSBwZWVycyB7eyNwZWVyc1dpdGhMYWJlbHN9fSdcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5jbG9uZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJlZnMpIHtcblxuICAgIC8vIE9iamVjdFxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHByZWZzLm5vbkVudW1lcmFibGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUodmFsdWUsIHsgc2hhbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25cblxuICAgIGNvbnN0IGNsb25lID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIGNsb25lLnByb3RvdHlwZSA9IENsb25lKHZhbHVlLnByb3RvdHlwZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbmFtZScsIHsgdmFsdWU6IHZhbHVlLm5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsICdsZW5ndGgnLCB7IHZhbHVlOiB2YWx1ZS5sZW5ndGgsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuYXNzaWduKGNsb25lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxuXG5pbnRlcm5hbHMuZGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChzY2hlbWEsIHJlbCwga2V5LCBwZWVycywgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KGtleSA9PT0gbnVsbCB8fCB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJywgcmVsLCAna2V5IG11c3QgYmUgYSBzdHJpbmdzJyk7XG5cbiAgICAvLyBFeHRyYWN0IG9wdGlvbnMgZnJvbSBwZWVycyBhcnJheVxuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwZWVycy5sZW5ndGggPiAxICYmIHR5cGVvZiBwZWVyc1twZWVycy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcgPyBwZWVycy5wb3AoKSA6IHt9O1xuICAgIH1cblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnc2VwYXJhdG9yJywgJ2lzUHJlc2VudCddKTtcblxuICAgIHBlZXJzID0gW10uY29uY2F0KHBlZXJzKTtcblxuICAgIC8vIENhc3QgcGVlciBwYXRoc1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBlZXIgb2YgcGVlcnMpIHtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJywgcmVsLCAncGVlcnMgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgIHBhdGhzLnB1c2goQ29tcGlsZS5yZWYocGVlciwgeyBzZXBhcmF0b3IsIGFuY2VzdG9yOiAwLCBwcmVmaXg6IGZhbHNlIH0pKTtcbiAgICB9XG5cbiAgICAvLyBDYXN0IGtleVxuXG4gICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICBrZXkgPSBDb21waWxlLnJlZihrZXksIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCwgcHJlZml4OiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcnVsZVxuXG4gICAgY29uc3Qgb2JqID0gc2NoZW1hLmNsb25lKCk7XG4gICAgb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzID0gb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzIHx8IFtdO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcy5wdXNoKG5ldyBpbnRlcm5hbHMuRGVwZW5kZW5jeShyZWwsIGtleSwgcGF0aHMsIHBlZXJzLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY2llcyA9IHtcblxuICAgIGFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGRlcC5wZWVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoICE9PSBjb3VudCAmJlxuICAgICAgICAgICAgcHJlc2VudC5sZW5ndGggIT09IGNvdW50KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZTogJ29iamVjdC5hbmQnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudFdpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwcmVzZW50KSxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZyxcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBtaXNzaW5nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbmFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gaW50ZXJuYWxzLmlzUHJlc2VudChkZXAub3B0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSkpIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoICE9PSBkZXAucGVlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYWluID0gZGVwLnBhdGhzWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXAucGF0aHMuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiAnb2JqZWN0Lm5hbmQnLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIG1haW4sXG4gICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIG1haW4pLFxuICAgICAgICAgICAgICAgIHBlZXJzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgdmFsdWVzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6ICdvYmplY3QubWlzc2luZycsXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgcGVlcnM6IGRlcC5wYXRocyxcbiAgICAgICAgICAgICAgICBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG94b3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJlc2VudC5sZW5ndGggfHxcbiAgICAgICAgICAgIHByZXNlbnQubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IHBlZXJzOiBkZXAucGF0aHMsIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocykgfTtcbiAgICAgICAgY29udGV4dC5wcmVzZW50ID0gcHJlc2VudDtcbiAgICAgICAgY29udGV4dC5wcmVzZW50V2l0aExhYmVscyA9IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwcmVzZW50KTtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogJ29iamVjdC5veG9yJywgY29udGV4dCB9O1xuICAgIH0sXG5cbiAgICB3aXRoKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gaW50ZXJuYWxzLmlzUHJlc2VudChkZXAub3B0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ29iamVjdC53aXRoJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZGVwLmtleS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLmtleS5rZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcjogcGVlci5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcGVlci5rZXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdpdGhvdXQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBpc1ByZXNlbnQgPSBpbnRlcm5hbHMuaXNQcmVzZW50KGRlcC5vcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3Qud2l0aG91dCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IGRlcC5rZXkua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5rZXkua2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXI6IHBlZXIua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHBlZXIua2V5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB4b3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IGludGVybmFscy5pc1ByZXNlbnQoZGVwLm9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkpKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnM6IGRlcC5wYXRocywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKSB9O1xuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QubWlzc2luZycsIGNvbnRleHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QueG9yJywgY29udGV4dCB9O1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmtleXNUb0xhYmVscyA9IGZ1bmN0aW9uIChzY2hlbWEsIGtleXMpIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIHJldHVybiBrZXlzLm1hcCgoa2V5KSA9PiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX21hcExhYmVscyhrZXlzKTtcbn07XG5cblxuaW50ZXJuYWxzLmlzUHJlc2VudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMuaXNQcmVzZW50ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5pc1ByZXNlbnQgOiAocmVzb2x2ZWQpID0+IHJlc29sdmVkICE9PSB1bmRlZmluZWQ7XG59O1xuXG5cbmludGVybmFscy5yZW5hbWUgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBlcnJvcnMpIHtcblxuICAgIGNvbnN0IHJlbmFtZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHJlbmFtZSBvZiBzY2hlbWEuJF90ZXJtcy5yZW5hbWVzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHR5cGVvZiByZW5hbWUuZnJvbSAhPT0gJ3N0cmluZyc7XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZW5hbWUuZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAodmFsdWVbcmVuYW1lLmZyb21dICE9PSB1bmRlZmluZWQgfHwgIXJlbmFtZS5vcHRpb25zLmlnbm9yZVVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChyZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcm9tIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2Zyb21dID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lLm9wdGlvbnMuaWdub3JlVW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHJlbmFtZS50bykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlbmFtZS5mcm9tLmV4ZWMoZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goeyBmcm9tLCB0bzogcmVuYW1lLnRvLCBtYXRjaCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IG1hdGNoLmZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBtYXRjaC50bztcbiAgICAgICAgICAgIGlmICh0byBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdG8gPSB0by5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbWF0Y2gubWF0Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5tdWx0aXBsZSAmJlxuICAgICAgICAgICAgICAgIHJlbmFtZWRbdG9dKSB7XG5cbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5tdWx0aXBsZScsIHZhbHVlLCB7IGZyb20sIHRvLCBwYXR0ZXJuIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHRvKSAmJlxuICAgICAgICAgICAgICAgICFyZW5hbWUub3B0aW9ucy5vdmVycmlkZSAmJlxuICAgICAgICAgICAgICAgICFyZW5hbWVkW3RvXSkge1xuXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5yZW5hbWUub3ZlcnJpZGUnLCB2YWx1ZSwgeyBmcm9tLCB0bywgcGF0dGVybiB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWVbZnJvbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVt0b107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVt0b10gPSB2YWx1ZVtmcm9tXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuYW1lZFt0b10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy51bmtub3duID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHVucHJvY2Vzc2VkLCBlcnJvcnMsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zKSB7XG4gICAgICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucy5tYXAoKHBhdHRlcm4pID0+IHtcblxuICAgICAgICAgICAgaWYgKHBhdHRlcm4ubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbLi4uc3RhdGUucGF0aCwga2V5XTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJuc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5yZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4ucmVnZXgudGVzdChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICdydWxlJywgYHBhdHRlcm4uJHtpfWAsIG1hdGNoID8gJ3Bhc3MnIDogJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4uc2NoZW1hLiRfbWF0Y2goa2V5LCBzdGF0ZS5uZXN0KHBhdHRlcm4uc2NoZW1hLCBgcGF0dGVybi4ke2l9YCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIHsgc2NoZW1hOiBwYXR0ZXJuLnJ1bGUsIGtleSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXR0ZXJuLnJ1bGUuJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc1tpXS5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4uZmFsbHRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcGF0dGVybiBtYXRjaGVzIHJ1bGVzXG5cbiAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cG0gPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJuc1tpXS5tYXRjaGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShzdGF0ZS5wYXRoLCBhbmNlc3RvcnMsIHN0cG0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0cG0uJF92YWxpZGF0ZShtYXRjaCwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBFcnJvcnMuZGV0YWlscyhyZXN1bHQuZXJyb3JzLCB7IG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucGF0dGVybi5tYXRjaCcsIHZhbHVlLCBkZXRhaWxzLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVwb3J0IH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5wcm9jZXNzZWQuc2l6ZSB8fFxuICAgICAgICAhc2NoZW1hLiRfdGVybXMua2V5cyAmJiAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMpIHsgICAgIC8vIElmIG5vIGtleXMgb3IgcGF0dGVybnMgc3BlY2lmaWVkLCB1bmtub3duIGtleXMgYWxsb3dlZFxuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuc3RyaXBVbmtub3duICYmIHR5cGVvZiBzY2hlbWEuX2ZsYWdzLnVua25vd24gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHByZWZzLnNraXBGdW5jdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBzdHJpcFVua25vd24gPSBwcmVmcy5zdHJpcFVua25vd24gPyAocHJlZnMuc3RyaXBVbmtub3duID09PSB0cnVlID8gdHJ1ZSA6ICEhcHJlZnMuc3RyaXBVbmtub3duLm9iamVjdHMpIDogZmFsc2U7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmb3JiaWRVbmtub3duID0gIUNvbW1vbi5kZWZhdWx0KHNjaGVtYS5fZmxhZ3MudW5rbm93biwgcHJlZnMuYWxsb3dVbmtub3duKTtcbiAgICBpZiAoZm9yYmlkVW5rbm93bikge1xuICAgICAgICBmb3IgKGNvbnN0IHVucHJvY2Vzc2VkS2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIHVucHJvY2Vzc2VkS2V5XSwgW10pO1xuICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC51bmtub3duJywgdmFsdWVbdW5wcm9jZXNzZWRLZXldLCB7IGNoaWxkOiB1bnByb2Nlc3NlZEtleSB9LCBsb2NhbFN0YXRlLCBwcmVmcywgeyBmbGFnczogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlcG9ydCB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuRGVwZW5kZW5jeSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlbCwga2V5LCBwZWVycywgcGF0aHMsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLnJlbCA9IHJlbDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucGVlcnMgPSBwZWVycztcbiAgICAgICAgdGhpcy5wYXRocyA9IHBhdGhzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IGRlc2MgPSB7XG4gICAgICAgICAgICByZWw6IHRoaXMucmVsLFxuICAgICAgICAgICAgcGVlcnM6IHRoaXMucGF0aHNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlc2Mua2V5ID0gdGhpcy5rZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGVlcnNbMF0uc2VwYXJhdG9yICE9PSAnLicpIHtcbiAgICAgICAgICAgIGRlc2Mub3B0aW9ucyA9IHsgLi4uZGVzYy5vcHRpb25zLCBzZXBhcmF0b3I6IHRoaXMucGVlcnNbMF0uc2VwYXJhdG9yIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzUHJlc2VudCkge1xuICAgICAgICAgICAgZGVzYy5vcHRpb25zID0geyAuLi5kZXNjLm9wdGlvbnMsIGlzUHJlc2VudDogdGhpcy5vcHRpb25zLmlzUHJlc2VudCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuS2V5cyA9IGNsYXNzIGV4dGVuZHMgQXJyYXkge1xuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2xpY2UoKTtcblxuICAgICAgICBjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAga2V5cy5zZXQocmVzdWx0W2ldLmtleSwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBpdGVtLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGtleXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAocG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcG9zXSA9IHsga2V5LCBzY2hlbWE6IHJlc3VsdFtwb3NdLnNjaGVtYS5jb25jYXQoaXRlbS5zY2hlbWEpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJBcHBseVRvRGVmYXVsdHMiLCJyZXF1aXJlIiwiQXNzZXJ0IiwiQ2xvbmUiLCJUb3BvIiwiQW55IiwiQ29tbW9uIiwiQ29tcGlsZSIsIkVycm9ycyIsIlJlZiIsIlRlbXBsYXRlIiwiaW50ZXJuYWxzIiwicmVuYW1lRGVmYXVsdHMiLCJhbGlhcyIsIm11bHRpcGxlIiwib3ZlcnJpZGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXh0ZW5kIiwidHlwZSIsInByb3BlcnRpZXMiLCJ0eXBlb2YiLCJmbGFncyIsInVua25vd24iLCJkZWZhdWx0IiwidW5kZWZpbmVkIiwidGVybXMiLCJkZXBlbmRlbmNpZXMiLCJpbml0Iiwia2V5cyIsIm1hbmlmZXN0IiwibWFwcGVkIiwiZnJvbSIsInRvIiwicGF0dGVybnMiLCJyZW5hbWVzIiwiYXJncyIsInNjaGVtYSIsInZhbGlkYXRlIiwidmFsdWUiLCJlcnJvciIsInN0YXRlIiwicHJlZnMiLCIkX3Byb3BlcnR5IiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JzIiwiJF90ZXJtcyIsImV4dGVybmFscyIsImNsb25lIiwicmVuYW1lIiwidW5wcm9jZXNzZWQiLCJTZXQiLCJPYmplY3QiLCJhbmNlc3RvcnMiLCJjaGlsZCIsImtleSIsIml0ZW0iLCJkZWxldGUiLCJsb2NhbFN0YXRlIiwibG9jYWxpemUiLCJwYXRoIiwicmVzdWx0IiwiJF92YWxpZGF0ZSIsImFib3J0RWFybHkiLCJwdXNoIiwiX2ZsYWdzIiwic2l6ZSIsIl9oYXNQYXR0ZXJuTWF0Y2giLCJlYXJseSIsImRlcCIsImlzUHJlc2VudCIsIm9wdGlvbnMiLCJyZXNvbHZlIiwic2hhZG93IiwiZmFpbGVkIiwicmVsIiwicmVwb3J0IiwiJF9jcmVhdGVFcnJvciIsImNvZGUiLCJjb250ZXh0IiwicnVsZXMiLCJhbmQiLCJtZXRob2QiLCJwZWVycyIsInZlcmlmeUZsYXQiLCJkZXBlbmRlbmN5IiwiYXBwZW5kIiwibGVuZ3RoIiwiYXNzZXJ0Iiwic3ViamVjdCIsIm1lc3NhZ2UiLCJpc1RlbXBsYXRlIiwicmVmIiwiJF9jb21waWxlIiwiYXBwZW5kUGF0aCIsIm9iaiIsIiRfYWRkUnVsZSIsIm5hbWUiLCIkX211dGF0ZVJlZ2lzdGVyIiwiYWJvdXQiLCJpc1JlZiIsImFic29sdXRlIiwiJF9tYXRjaCIsIm11bHRpIiwiaW5zdGFuY2UiLCJjb25zdHJ1Y3RvciIsImhlbHBlcnMiLCJpc1NjaGVtYSIsIktleXMiLCJmaWx0ZXIiLCJoYXNPd25Qcm9wZXJ0eSIsInRyeVdpdGhQYXRoIiwiJF9tdXRhdGVSZWJ1aWxkIiwibGltaXQiLCJvcGVyYXRvciIsImNvbXBhcmUiLCJtYXgiLCJtaW4iLCJuYW5kIiwib3IiLCJveG9yIiwicGF0dGVybiIsImlzUmVnRXhwIiwiUmVnRXhwIiwiYXNzZXJ0T3B0aW9ucyIsImluY2x1ZGVzIiwiY29uZmlnIiwicnVsZSIsIm1hdGNoZXMiLCIkX3Jvb3QiLCJhcnJheSIsIml0ZW1zIiwiJF9zZXRGbGFnIiwiZmFsbHRocm91Z2giLCJyZWdleCIsImFsbG93Iiwid2l0aCIsIndpdGhvdXQiLCJ4b3IiLCJvdmVycmlkZXMiLCJzeW1ib2xzIiwiZGVlcERlZmF1bHQiLCIkX3BhcmVudCIsInJlYnVpbGQiLCJ0b3BvIiwiU29ydGVyIiwiYWRkIiwiYWZ0ZXIiLCIkX3Jvb3RSZWZlcmVuY2VzIiwiZ3JvdXAiLCJub2RlcyIsImJ1aWxkIiwiZGVzYyIsIm1lc3NhZ2VzIiwibm9uRW51bWVyYWJsZXMiLCJzaGFsbG93IiwiY3JlYXRlIiwiZ2V0UHJvdG90eXBlT2YiLCJhc3NpZ24iLCJhcHBseSIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJwb3AiLCJjb25jYXQiLCJzZXBhcmF0b3IiLCJwYXRocyIsInBlZXIiLCJhbmNlc3RvciIsInByZWZpeCIsIkRlcGVuZGVuY3kiLCJtaXNzaW5nIiwicHJlc2VudCIsImNvdW50IiwicHJlc2VudFdpdGhMYWJlbHMiLCJrZXlzVG9MYWJlbHMiLCJtaXNzaW5nV2l0aExhYmVscyIsIm1haW4iLCJ2YWx1ZXMiLCJzbGljZSIsIm1haW5XaXRoTGFiZWwiLCJwZWVyc1dpdGhMYWJlbHMiLCJwZWVyV2l0aExhYmVsIiwibWFwIiwiJF9tYXBMYWJlbHMiLCJyZXNvbHZlZCIsInJlbmFtZWQiLCJjYWxsIiwiaWdub3JlVW5kZWZpbmVkIiwibWF0Y2giLCJleGVjIiwicmVuZGVyIiwiaGFzTWF0Y2hlcyIsImkiLCJ0ZXN0IiwibWFpbnN0YXkiLCJ0cmFjZXIiLCJkZWJ1ZyIsIm5lc3QiLCJzdHBtIiwiZGV0YWlscyIsInN0cmlwVW5rbm93biIsInNraXBGdW5jdGlvbnMiLCJvYmplY3RzIiwiZm9yYmlkVW5rbm93biIsImFsbG93VW5rbm93biIsInVucHJvY2Vzc2VkS2V5IiwiZGVzY3JpYmUiLCJzb3VyY2UiLCJNYXAiLCJzZXQiLCJwb3MiLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/keys.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/link.js":
/*!********************************************!*\
  !*** ./node_modules/joi/lib/types/link.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Compile = __webpack_require__(/*! ../compile */ \"(rsc)/./node_modules/joi/lib/compile.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst internals = {};\nmodule.exports = Any.extend({\n    type: \"link\",\n    properties: {\n        schemaChain: true\n    },\n    terms: {\n        link: {\n            init: null,\n            manifest: \"single\",\n            register: false\n        }\n    },\n    args (schema, ref) {\n        return schema.ref(ref);\n    },\n    validate (value, { schema, state, prefs }) {\n        Assert(schema.$_terms.link, \"Uninitialized link schema\");\n        const linked = internals.generate(schema, value, state, prefs);\n        const ref = schema.$_terms.link[0].ref;\n        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);\n    },\n    generate (schema, value, state, prefs) {\n        return internals.generate(schema, value, state, prefs);\n    },\n    rules: {\n        ref: {\n            method (ref) {\n                Assert(!this.$_terms.link, \"Cannot reinitialize schema\");\n                ref = Compile.ref(ref);\n                Assert(ref.type === \"value\" || ref.type === \"local\", \"Invalid reference type:\", ref.type);\n                Assert(ref.type === \"local\" || ref.ancestor === \"root\" || ref.ancestor > 0, \"Link cannot reference itself\");\n                const obj = this.clone();\n                obj.$_terms.link = [\n                    {\n                        ref\n                    }\n                ];\n                return obj;\n            }\n        },\n        relative: {\n            method (enabled = true) {\n                return this.$_setFlag(\"relative\", enabled);\n            }\n        }\n    },\n    overrides: {\n        concat (source) {\n            Assert(this.$_terms.link, \"Uninitialized link schema\");\n            Assert(Common.isSchema(source), \"Invalid schema object\");\n            Assert(source.type !== \"link\", \"Cannot merge type link with another link\");\n            const obj = this.clone();\n            if (!obj.$_terms.whens) {\n                obj.$_terms.whens = [];\n            }\n            obj.$_terms.whens.push({\n                concat: source\n            });\n            return obj.$_mutateRebuild();\n        }\n    },\n    manifest: {\n        build (obj, desc) {\n            Assert(desc.link, \"Invalid link description missing link\");\n            return obj.ref(desc.link);\n        }\n    }\n});\n// Helpers\ninternals.generate = function(schema, value, state, prefs) {\n    let linked = state.mainstay.links.get(schema);\n    if (linked) {\n        return linked._generate(value, state, prefs).schema;\n    }\n    const ref = schema.$_terms.link[0].ref;\n    const { perspective, path } = internals.perspective(ref, state);\n    internals.assert(perspective, \"which is outside of schema boundaries\", ref, schema, state, prefs);\n    try {\n        linked = path.length ? perspective.$_reach(path) : perspective;\n    } catch (ignoreErr) {\n        internals.assert(false, \"to non-existing schema\", ref, schema, state, prefs);\n    }\n    internals.assert(linked.type !== \"link\", \"which is another link\", ref, schema, state, prefs);\n    if (!schema._flags.relative) {\n        state.mainstay.links.set(schema, linked);\n    }\n    return linked._generate(value, state, prefs).schema;\n};\ninternals.perspective = function(ref, state) {\n    if (ref.type === \"local\") {\n        for (const { schema, key } of state.schemas){\n            const id = schema._flags.id || key;\n            if (id === ref.path[0]) {\n                return {\n                    perspective: schema,\n                    path: ref.path.slice(1)\n                };\n            }\n            if (schema.$_terms.shared) {\n                for (const shared of schema.$_terms.shared){\n                    if (shared._flags.id === ref.path[0]) {\n                        return {\n                            perspective: shared,\n                            path: ref.path.slice(1)\n                        };\n                    }\n                }\n            }\n        }\n        return {\n            perspective: null,\n            path: null\n        };\n    }\n    if (ref.ancestor === \"root\") {\n        return {\n            perspective: state.schemas[state.schemas.length - 1].schema,\n            path: ref.path\n        };\n    }\n    return {\n        perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema,\n        path: ref.path\n    };\n};\ninternals.assert = function(condition, message, ref, schema, state, prefs) {\n    if (condition) {\n        return;\n    }\n    Assert(false, `\"${Errors.label(schema._flags, state, prefs)}\" contains link reference \"${ref.display}\" ${message}`);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9saW5rLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFFdkIsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUM7QUFDeEIsTUFBTUksU0FBU0osbUJBQU9BLENBQUM7QUFHdkIsTUFBTUssWUFBWSxDQUFDO0FBR25CQyxPQUFPQyxPQUFPLEdBQUdOLElBQUlPLE1BQU0sQ0FBQztJQUV4QkMsTUFBTTtJQUVOQyxZQUFZO1FBQ1JDLGFBQWE7SUFDakI7SUFFQUMsT0FBTztRQUVIQyxNQUFNO1lBQUVDLE1BQU07WUFBTUMsVUFBVTtZQUFVQyxVQUFVO1FBQU07SUFDNUQ7SUFFQUMsTUFBS0MsTUFBTSxFQUFFQyxHQUFHO1FBRVosT0FBT0QsT0FBT0MsR0FBRyxDQUFDQTtJQUN0QjtJQUVBQyxVQUFTQyxLQUFLLEVBQUUsRUFBRUgsTUFBTSxFQUFFSSxLQUFLLEVBQUVDLEtBQUssRUFBRTtRQUVwQ3hCLE9BQU9tQixPQUFPTSxPQUFPLENBQUNYLElBQUksRUFBRTtRQUU1QixNQUFNWSxTQUFTcEIsVUFBVXFCLFFBQVEsQ0FBQ1IsUUFBUUcsT0FBT0MsT0FBT0M7UUFDeEQsTUFBTUosTUFBTUQsT0FBT00sT0FBTyxDQUFDWCxJQUFJLENBQUMsRUFBRSxDQUFDTSxHQUFHO1FBQ3RDLE9BQU9NLE9BQU9FLFVBQVUsQ0FBQ04sT0FBT0MsTUFBTU0sSUFBSSxDQUFDSCxRQUFRLENBQUMsS0FBSyxFQUFFTixJQUFJVSxPQUFPLENBQUMsQ0FBQyxFQUFFSixPQUFPaEIsSUFBSSxDQUFDLENBQUMsR0FBR2M7SUFDOUY7SUFFQUcsVUFBU1IsTUFBTSxFQUFFRyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsS0FBSztRQUVoQyxPQUFPbEIsVUFBVXFCLFFBQVEsQ0FBQ1IsUUFBUUcs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QUlpQyxJQUFJO0lBQUM7QUFDNUc7QUFHQS9DLFVBQVVnRCxNQUFNLEdBQUcsU0FBVVcsU0FBUyxFQUFFQyxPQUFPLEVBQUU5QyxHQUFHLEVBQUVELE1BQU0sRUFBRUksS0FBSyxFQUFFQyxLQUFLO0lBRXRFLElBQUl5QyxXQUFXO1FBQ1g7SUFDSjtJQUVBakUsT0FBTyxPQUFPLENBQUMsQ0FBQyxFQUFFSyxPQUFPOEQsS0FBSyxDQUFDaEQsT0FBT3VDLE1BQU0sRUFBRW5DLE9BQU9DLE9BQU8sMkJBQTJCLEVBQUVKLElBQUlVLE9BQU8sQ0FBQyxFQUFFLEVBQUVvQyxRQUFRLENBQUM7QUFDdEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL2xpbmsuanM/MjU4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdsaW5rJyxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgc2NoZW1hQ2hhaW46IHRydWVcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBsaW5rOiB7IGluaXQ6IG51bGwsIG1hbmlmZXN0OiAnc2luZ2xlJywgcmVnaXN0ZXI6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIHJlZikge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEucmVmKHJlZik7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICBBc3NlcnQoc2NoZW1hLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcblxuICAgICAgICBjb25zdCBsaW5rZWQgPSBpbnRlcm5hbHMuZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgY29uc3QgcmVmID0gc2NoZW1hLiRfdGVybXMubGlua1swXS5yZWY7XG4gICAgICAgIHJldHVybiBsaW5rZWQuJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUubmVzdChsaW5rZWQsIGBsaW5rOiR7cmVmLmRpc3BsYXl9OiR7bGlua2VkLnR5cGV9YCksIHByZWZzKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKHJlZikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLiRfdGVybXMubGluaywgJ0Nhbm5vdCByZWluaXRpYWxpemUgc2NoZW1hJyk7XG5cbiAgICAgICAgICAgICAgICByZWYgPSBDb21waWxlLnJlZihyZWYpO1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAndmFsdWUnIHx8IHJlZi50eXBlID09PSAnbG9jYWwnLCAnSW52YWxpZCByZWZlcmVuY2UgdHlwZTonLCByZWYudHlwZSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAnbG9jYWwnIHx8IHJlZi5hbmNlc3RvciA9PT0gJ3Jvb3QnIHx8IHJlZi5hbmNlc3RvciA+IDAsICdMaW5rIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubGluayA9IFt7IHJlZiB9XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVsYXRpdmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgICAgIEFzc2VydCh0aGlzLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc291cmNlKSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICAgICAgQXNzZXJ0KHNvdXJjZS50eXBlICE9PSAnbGluaycsICdDYW5ub3QgbWVyZ2UgdHlwZSBsaW5rIHdpdGggYW5vdGhlciBsaW5rJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zLnB1c2goeyBjb25jYXQ6IHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KGRlc2MubGluaywgJ0ludmFsaWQgbGluayBkZXNjcmlwdGlvbiBtaXNzaW5nIGxpbmsnKTtcbiAgICAgICAgICAgIHJldHVybiBvYmoucmVmKGRlc2MubGluayk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGxldCBsaW5rZWQgPSBzdGF0ZS5tYWluc3RheS5saW5rcy5nZXQoc2NoZW1hKTtcbiAgICBpZiAobGlua2VkKSB7XG4gICAgICAgIHJldHVybiBsaW5rZWQuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCByZWYgPSBzY2hlbWEuJF90ZXJtcy5saW5rWzBdLnJlZjtcbiAgICBjb25zdCB7IHBlcnNwZWN0aXZlLCBwYXRoIH0gPSBpbnRlcm5hbHMucGVyc3BlY3RpdmUocmVmLCBzdGF0ZSk7XG4gICAgaW50ZXJuYWxzLmFzc2VydChwZXJzcGVjdGl2ZSwgJ3doaWNoIGlzIG91dHNpZGUgb2Ygc2NoZW1hIGJvdW5kYXJpZXMnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGxpbmtlZCA9IHBhdGgubGVuZ3RoID8gcGVyc3BlY3RpdmUuJF9yZWFjaChwYXRoKSA6IHBlcnNwZWN0aXZlO1xuICAgIH1cbiAgICBjYXRjaCAoaWdub3JlRXJyKSB7XG4gICAgICAgIGludGVybmFscy5hc3NlcnQoZmFsc2UsICd0byBub24tZXhpc3Rpbmcgc2NoZW1hJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxzLmFzc2VydChsaW5rZWQudHlwZSAhPT0gJ2xpbmsnLCAnd2hpY2ggaXMgYW5vdGhlciBsaW5rJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICBpZiAoIXNjaGVtYS5fZmxhZ3MucmVsYXRpdmUpIHtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkubGlua3Muc2V0KHNjaGVtYSwgbGlua2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlua2VkLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChyZWYsIHN0YXRlKSB7XG5cbiAgICBpZiAocmVmLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IHNjaGVtYSwga2V5IH0gb2Ygc3RhdGUuc2NoZW1hcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyb20gcGFyZW50IHRvIHJvb3RcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NoZW1hLl9mbGFncy5pZCB8fCBrZXk7XG4gICAgICAgICAgICBpZiAoaWQgPT09IHJlZi5wYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHNjaGVtYSwgcGF0aDogcmVmLnBhdGguc2xpY2UoMSkgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2hhcmVkIG9mIHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLl9mbGFncy5pZCA9PT0gcmVmLnBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzaGFyZWQsIHBhdGg6IHJlZi5wYXRoLnNsaWNlKDEpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogbnVsbCwgcGF0aDogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChyZWYuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tzdGF0ZS5zY2hlbWFzLmxlbmd0aCAtIDFdLnNjaGVtYSwgcGF0aDogcmVmLnBhdGggfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tyZWYuYW5jZXN0b3JdICYmIHN0YXRlLnNjaGVtYXNbcmVmLmFuY2VzdG9yXS5zY2hlbWEsIHBhdGg6IHJlZi5wYXRoIH07XG59O1xuXG5cbmludGVybmFscy5hc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoY29uZGl0aW9uKSB7ICAgICAgICAgICAgICAgIC8vIE1hbnVhbCBjaGVjayB0byBhdm9pZCBnZW5lcmF0aW5nIGVycm9yIG1lc3NhZ2Ugb24gc3VjY2Vzc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQXNzZXJ0KGZhbHNlLCBgXCIke0Vycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpfVwiIGNvbnRhaW5zIGxpbmsgcmVmZXJlbmNlIFwiJHtyZWYuZGlzcGxheX1cIiAke21lc3NhZ2V9YCk7XG59O1xuIl0sIm5hbWVzIjpbIkFzc2VydCIsInJlcXVpcmUiLCJBbnkiLCJDb21tb24iLCJDb21waWxlIiwiRXJyb3JzIiwiaW50ZXJuYWxzIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4dGVuZCIsInR5cGUiLCJwcm9wZXJ0aWVzIiwic2NoZW1hQ2hhaW4iLCJ0ZXJtcyIsImxpbmsiLCJpbml0IiwibWFuaWZlc3QiLCJyZWdpc3RlciIsImFyZ3MiLCJzY2hlbWEiLCJyZWYiLCJ2YWxpZGF0ZSIsInZhbHVlIiwic3RhdGUiLCJwcmVmcyIsIiRfdGVybXMiLCJsaW5rZWQiLCJnZW5lcmF0ZSIsIiRfdmFsaWRhdGUiLCJuZXN0IiwiZGlzcGxheSIsInJ1bGVzIiwibWV0aG9kIiwiYW5jZXN0b3IiLCJvYmoiLCJjbG9uZSIsInJlbGF0aXZlIiwiZW5hYmxlZCIsIiRfc2V0RmxhZyIsIm92ZXJyaWRlcyIsImNvbmNhdCIsInNvdXJjZSIsImlzU2NoZW1hIiwid2hlbnMiLCJwdXNoIiwiJF9tdXRhdGVSZWJ1aWxkIiwiYnVpbGQiLCJkZXNjIiwibWFpbnN0YXkiLCJsaW5rcyIsImdldCIsIl9nZW5lcmF0ZSIsInBlcnNwZWN0aXZlIiwicGF0aCIsImFzc2VydCIsImxlbmd0aCIsIiRfcmVhY2giLCJpZ25vcmVFcnIiLCJfZmxhZ3MiLCJzZXQiLCJrZXkiLCJzY2hlbWFzIiwiaWQiLCJzbGljZSIsInNoYXJlZCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJsYWJlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/link.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/number.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/number.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst internals = {\n    numberRx: /^\\s*[+-]?(?:(?:\\d+(?:\\.\\d*)?)|(?:\\.\\d+))(?:e([+-]?\\d+))?\\s*$/i,\n    precisionRx: /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/,\n    exponentialPartRegex: /[eE][+-]?\\d+$/,\n    leadingSignAndZerosRegex: /^[+-]?(0*)?/,\n    dotRegex: /\\./,\n    trailingZerosRegex: /0+$/,\n    decimalPlaces (value) {\n        const str = value.toString();\n        const dindex = str.indexOf(\".\");\n        const eindex = str.indexOf(\"e\");\n        return (dindex < 0 ? 0 : (eindex < 0 ? str.length : eindex) - dindex - 1) + (eindex < 0 ? 0 : Math.max(0, -parseInt(str.slice(eindex + 1))));\n    }\n};\nmodule.exports = Any.extend({\n    type: \"number\",\n    flags: {\n        unsafe: {\n            default: false\n        }\n    },\n    coerce: {\n        from: \"string\",\n        method (value, { schema, error }) {\n            const matches = value.match(internals.numberRx);\n            if (!matches) {\n                return;\n            }\n            value = value.trim();\n            const result = {\n                value: parseFloat(value)\n            };\n            if (result.value === 0) {\n                result.value = 0; // -0\n            }\n            if (!schema._flags.unsafe) {\n                if (value.match(/e/i)) {\n                    if (internals.extractSignificantDigits(value) !== internals.extractSignificantDigits(String(result.value))) {\n                        result.errors = error(\"number.unsafe\");\n                        return result;\n                    }\n                } else {\n                    const string = result.value.toString();\n                    if (string.match(/e/i)) {\n                        return result;\n                    }\n                    if (string !== internals.normalizeDecimal(value)) {\n                        result.errors = error(\"number.unsafe\");\n                        return result;\n                    }\n                }\n            }\n            return result;\n        }\n    },\n    validate (value, { schema, error, prefs }) {\n        if (value === Infinity || value === -Infinity) {\n            return {\n                value,\n                errors: error(\"number.infinity\")\n            };\n        }\n        if (!Common.isNumber(value)) {\n            return {\n                value,\n                errors: error(\"number.base\")\n            };\n        }\n        const result = {\n            value\n        };\n        if (prefs.convert) {\n            const rule = schema.$_getRule(\"precision\");\n            if (rule) {\n                const precision = Math.pow(10, rule.args.limit); // This is conceptually equivalent to using toFixed but it should be much faster\n                result.value = Math.round(result.value * precision) / precision;\n            }\n        }\n        if (result.value === 0) {\n            result.value = 0; // -0\n        }\n        if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {\n            result.errors = error(\"number.unsafe\");\n        }\n        return result;\n    },\n    rules: {\n        compare: {\n            method: false,\n            validate (value, helpers, { limit }, { name, operator, args }) {\n                if (Common.compare(value, limit, operator)) {\n                    return value;\n                }\n                return helpers.error(\"number.\" + name, {\n                    limit: args.limit,\n                    value\n                });\n            },\n            args: [\n                {\n                    name: \"limit\",\n                    ref: true,\n                    assert: Common.isNumber,\n                    message: \"must be a number\"\n                }\n            ]\n        },\n        greater: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"greater\",\n                    method: \"compare\",\n                    args: {\n                        limit\n                    },\n                    operator: \">\"\n                });\n            }\n        },\n        integer: {\n            method () {\n                return this.$_addRule(\"integer\");\n            },\n            validate (value, helpers) {\n                if (Math.trunc(value) - value === 0) {\n                    return value;\n                }\n                return helpers.error(\"number.integer\");\n            }\n        },\n        less: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"less\",\n                    method: \"compare\",\n                    args: {\n                        limit\n                    },\n                    operator: \"<\"\n                });\n            }\n        },\n        max: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"max\",\n                    method: \"compare\",\n                    args: {\n                        limit\n                    },\n                    operator: \"<=\"\n                });\n            }\n        },\n        min: {\n            method (limit) {\n                return this.$_addRule({\n                    name: \"min\",\n                    method: \"compare\",\n                    args: {\n                        limit\n                    },\n                    operator: \">=\"\n                });\n            }\n        },\n        multiple: {\n            method (base) {\n                const baseDecimalPlace = typeof base === \"number\" ? internals.decimalPlaces(base) : null;\n                const pfactor = Math.pow(10, baseDecimalPlace);\n                return this.$_addRule({\n                    name: \"multiple\",\n                    args: {\n                        base,\n                        baseDecimalPlace,\n                        pfactor\n                    }\n                });\n            },\n            validate (value, helpers, { base, baseDecimalPlace, pfactor }, options) {\n                const valueDecimalPlace = internals.decimalPlaces(value);\n                if (valueDecimalPlace > baseDecimalPlace) {\n                    // Value with higher precision than base can never be a multiple\n                    return helpers.error(\"number.multiple\", {\n                        multiple: options.args.base,\n                        value\n                    });\n                }\n                return Math.round(pfactor * value) % Math.round(pfactor * base) === 0 ? value : helpers.error(\"number.multiple\", {\n                    multiple: options.args.base,\n                    value\n                });\n            },\n            args: [\n                {\n                    name: \"base\",\n                    ref: true,\n                    assert: (value)=>typeof value === \"number\" && isFinite(value) && value > 0,\n                    message: \"must be a positive number\"\n                },\n                \"baseDecimalPlace\",\n                \"pfactor\"\n            ],\n            multi: true\n        },\n        negative: {\n            method () {\n                return this.sign(\"negative\");\n            }\n        },\n        port: {\n            method () {\n                return this.$_addRule(\"port\");\n            },\n            validate (value, helpers) {\n                if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {\n                    return value;\n                }\n                return helpers.error(\"number.port\");\n            }\n        },\n        positive: {\n            method () {\n                return this.sign(\"positive\");\n            }\n        },\n        precision: {\n            method (limit) {\n                Assert(Number.isSafeInteger(limit), \"limit must be an integer\");\n                return this.$_addRule({\n                    name: \"precision\",\n                    args: {\n                        limit\n                    }\n                });\n            },\n            validate (value, helpers, { limit }) {\n                const places = value.toString().match(internals.precisionRx);\n                const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n                if (decimals <= limit) {\n                    return value;\n                }\n                return helpers.error(\"number.precision\", {\n                    limit,\n                    value\n                });\n            },\n            convert: true\n        },\n        sign: {\n            method (sign) {\n                Assert([\n                    \"negative\",\n                    \"positive\"\n                ].includes(sign), \"Invalid sign\", sign);\n                return this.$_addRule({\n                    name: \"sign\",\n                    args: {\n                        sign\n                    }\n                });\n            },\n            validate (value, helpers, { sign }) {\n                if (sign === \"negative\" && value < 0 || sign === \"positive\" && value > 0) {\n                    return value;\n                }\n                return helpers.error(`number.${sign}`);\n            }\n        },\n        unsafe: {\n            method (enabled = true) {\n                Assert(typeof enabled === \"boolean\", \"enabled must be a boolean\");\n                return this.$_setFlag(\"unsafe\", enabled);\n            }\n        }\n    },\n    cast: {\n        string: {\n            from: (value)=>typeof value === \"number\",\n            to (value, helpers) {\n                return value.toString();\n            }\n        }\n    },\n    messages: {\n        \"number.base\": \"{{#label}} must be a number\",\n        \"number.greater\": \"{{#label}} must be greater than {{#limit}}\",\n        \"number.infinity\": \"{{#label}} cannot be infinity\",\n        \"number.integer\": \"{{#label}} must be an integer\",\n        \"number.less\": \"{{#label}} must be less than {{#limit}}\",\n        \"number.max\": \"{{#label}} must be less than or equal to {{#limit}}\",\n        \"number.min\": \"{{#label}} must be greater than or equal to {{#limit}}\",\n        \"number.multiple\": \"{{#label}} must be a multiple of {{#multiple}}\",\n        \"number.negative\": \"{{#label}} must be a negative number\",\n        \"number.port\": \"{{#label}} must be a valid port\",\n        \"number.positive\": \"{{#label}} must be a positive number\",\n        \"number.precision\": \"{{#label}} must have no more than {{#limit}} decimal places\",\n        \"number.unsafe\": \"{{#label}} must be a safe number\"\n    }\n});\n// Helpers\ninternals.extractSignificantDigits = function(value) {\n    return value.replace(internals.exponentialPartRegex, \"\").replace(internals.dotRegex, \"\").replace(internals.trailingZerosRegex, \"\").replace(internals.leadingSignAndZerosRegex, \"\");\n};\ninternals.normalizeDecimal = function(str) {\n    str = str// Remove leading plus signs\n    .replace(/^\\+/, \"\")// Remove trailing zeros if there is a decimal point and unecessary decimal points\n    .replace(/\\.0*$/, \"\")// Add a integer 0 if the numbers starts with a decimal point\n    .replace(/^(-?)\\.([^\\.]*)$/, \"$10.$2\")// Remove leading zeros\n    .replace(/^(-?)0+([0-9])/, \"$1$2\");\n    if (str.includes(\".\") && str.endsWith(\"0\")) {\n        str = str.replace(/0+$/, \"\");\n    }\n    if (str === \"-0\") {\n        return \"0\";\n    }\n    return str;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUV2QixNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUd2QixNQUFNRyxZQUFZO0lBQ2RDLFVBQVU7SUFDVkMsYUFBYTtJQUNiQyxzQkFBc0I7SUFDdEJDLDBCQUEwQjtJQUMxQkMsVUFBVTtJQUNWQyxvQkFBb0I7SUFDcEJDLGVBQWNDLEtBQUs7UUFFZixNQUFNQyxNQUFNRCxNQUFNRSxRQUFRO1FBQzFCLE1BQU1DLFNBQVNGLElBQUlHLE9BQU8sQ0FBQztRQUMzQixNQUFNQyxTQUFTSixJQUFJRyxPQUFPLENBQUM7UUFDM0IsT0FDSSxDQUFDRCxTQUFTLElBQUksSUFBSSxDQUFDRSxTQUFTLElBQUlKLElBQUlLLE1BQU0sR0FBR0QsTUFBSyxJQUFLRixTQUFTLEtBQy9ERSxDQUFBQSxTQUFTLElBQUksSUFBSUUsS0FBS0MsR0FBRyxDQUFDLEdBQUcsQ0FBQ0MsU0FBU1IsSUFBSVMsS0FBSyxDQUFDTCxTQUFTLElBQUc7SUFFdEU7QUFDSjtBQUdBTSxPQUFPQyxPQUFPLEdBQUd0QixJQUFJdUIsTUFBTSxDQUFDO0lBRXhCQyxNQUFNO0lBRU5DLE9BQU87UUFFSEMsUUFBUTtZQUFFQyxTQUFTO1FBQU07SUFDN0I7SUFFQUMsUUFBUTtRQUNKQyxNQUFNO1FBQ05DLFFBQU9wQixLQUFLLEVBQUUsRUFBRXFCLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1lBRTNCLE1BQU1DLFVBQVV2QixNQUFNd0IsS0FBSyxDQUFDaEMsVUFBVUMsUUFBUTtZQUM5QyxJQUFJLENBQUM4QixTQUFTO2dCQUNWO1lBQ0o7WUFFQXZCLFFBQVFBLE1BQU15QixJQUFJO1lBQ2xCLE1BQU1DLFNBQVM7Z0JBQUUxQixPQUFPMkIsV0FBVzNCO1lBQU87WUFFMUMsSUFBSTBCLE9BQU8x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SUFBSW1GLE9BQU8sQ0FBQyxPQUFPO0lBQzdCO0lBRUEsSUFBSW5GLFFBQVEsTUFBTTtRQUNkLE9BQU87SUFDWDtJQUVBLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3R5cGVzL251bWJlci5qcz9lZmM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbnVtYmVyUng6IC9eXFxzKlsrLV0/KD86KD86XFxkKyg/OlxcLlxcZCopPyl8KD86XFwuXFxkKykpKD86ZShbKy1dP1xcZCspKT9cXHMqJC9pLFxuICAgIHByZWNpc2lvblJ4OiAvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvLFxuICAgIGV4cG9uZW50aWFsUGFydFJlZ2V4OiAvW2VFXVsrLV0/XFxkKyQvLFxuICAgIGxlYWRpbmdTaWduQW5kWmVyb3NSZWdleDogL15bKy1dPygwKik/LyxcbiAgICBkb3RSZWdleDogL1xcLi8sXG4gICAgdHJhaWxpbmdaZXJvc1JlZ2V4OiAvMCskLyxcbiAgICBkZWNpbWFsUGxhY2VzKHZhbHVlKSB7XG5cbiAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZGluZGV4ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgY29uc3QgZWluZGV4ID0gc3RyLmluZGV4T2YoJ2UnKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChkaW5kZXggPCAwID8gMCA6IChlaW5kZXggPCAwID8gc3RyLmxlbmd0aCA6IGVpbmRleCkgLSBkaW5kZXggLSAxKSArXG4gICAgICAgICAgICAoZWluZGV4IDwgMCA/IDAgOiBNYXRoLm1heCgwLCAtcGFyc2VJbnQoc3RyLnNsaWNlKGVpbmRleCArIDEpKSkpXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ251bWJlcicsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHVuc2FmZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goaW50ZXJuYWxzLm51bWJlclJ4KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSB9O1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gMDsgICAgICAgICAgIC8vIC0wXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy51bnNhZmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL2UvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHModmFsdWUpICE9PSBpbnRlcm5hbHMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKFN0cmluZyhyZXN1bHQudmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmcgPSByZXN1bHQudmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaCgvZS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IGludGVybmFscy5ub3JtYWxpemVEZWNpbWFsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHByZWZzIH0pIHtcblxuICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdudW1iZXIuaW5maW5pdHknKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFDb21tb24uaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignbnVtYmVyLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZSB9O1xuXG4gICAgICAgIGlmIChwcmVmcy5jb252ZXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLiRfZ2V0UnVsZSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBydWxlLmFyZ3MubGltaXQpOyAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBjb25jZXB0dWFsbHkgZXF1aXZhbGVudCB0byB1c2luZyB0b0ZpeGVkIGJ1dCBpdCBzaG91bGQgYmUgbXVjaCBmYXN0ZXJcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJlc3VsdC52YWx1ZSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSAwOyAgICAgICAgICAgLy8gLTBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NoZW1hLl9mbGFncy51bnNhZmUgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IHZhbHVlIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjb21wYXJlOiB7XG4gICAgICAgICAgICBtZXRob2Q6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24uaXNOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBncmVhdGVyOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdncmVhdGVyJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbnRlZ2VyOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2ludGVnZXInKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgudHJ1bmModmFsdWUpIC0gdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIuaW50ZWdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlc3M6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlc3MnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzwnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtdWx0aXBsZToge1xuICAgICAgICAgICAgbWV0aG9kKGJhc2UpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VEZWNpbWFsUGxhY2UgPSB0eXBlb2YgYmFzZSA9PT0gJ251bWJlcicgPyBpbnRlcm5hbHMuZGVjaW1hbFBsYWNlcyhiYXNlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgcGZhY3RvciA9IE1hdGgucG93KDEwLCBiYXNlRGVjaW1hbFBsYWNlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlRGVjaW1hbFBsYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGZhY3RvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgYmFzZSwgYmFzZURlY2ltYWxQbGFjZSwgcGZhY3RvciB9LCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURlY2ltYWxQbGFjZSA9IGludGVybmFscy5kZWNpbWFsUGxhY2VzKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZURlY2ltYWxQbGFjZSA+IGJhc2VEZWNpbWFsUGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsdWUgd2l0aCBoaWdoZXIgcHJlY2lzaW9uIHRoYW4gYmFzZSBjYW4gbmV2ZXIgYmUgYSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogb3B0aW9ucy5hcmdzLmJhc2UsIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBmYWN0b3IgKiB2YWx1ZSkgJSBNYXRoLnJvdW5kKHBmYWN0b3IgKiBiYXNlKSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgaGVscGVycy5lcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogb3B0aW9ucy5hcmdzLmJhc2UsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdiYXNlRGVjaW1hbFBsYWNlJyxcbiAgICAgICAgICAgICAgICAncGZhY3RvcidcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG5lZ2F0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduKCduZWdhdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncG9ydCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPD0gNjU1MzUpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5wb3J0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24oJ3Bvc2l0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlY2lzaW9uOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCksICdsaW1pdCBtdXN0IGJlIGFuIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdwcmVjaXNpb24nLCBhcmdzOiB7IGxpbWl0IH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaChpbnRlcm5hbHMucHJlY2lzaW9uUngpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gTWF0aC5tYXgoKHBsYWNlc1sxXSA/IHBsYWNlc1sxXS5sZW5ndGggOiAwKSAtIChwbGFjZXNbMl0gPyBwYXJzZUludChwbGFjZXNbMl0sIDEwKSA6IDApLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbHMgPD0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIucHJlY2lzaW9uJywgeyBsaW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpZ246IHtcbiAgICAgICAgICAgIG1ldGhvZChzaWduKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWyduZWdhdGl2ZScsICdwb3NpdGl2ZSddLmluY2x1ZGVzKHNpZ24pLCAnSW52YWxpZCBzaWduJywgc2lnbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc2lnbicsIGFyZ3M6IHsgc2lnbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHNpZ24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpZ24gPT09ICduZWdhdGl2ZScgJiYgdmFsdWUgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPT09ICdwb3NpdGl2ZScgJiYgdmFsdWUgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGBudW1iZXIuJHtzaWdufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc2FmZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5zYWZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnbnVtYmVyLmJhc2UnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5ncmVhdGVyJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBncmVhdGVyIHRoYW4ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIuaW5maW5pdHknOiAne3sjbGFiZWx9fSBjYW5ub3QgYmUgaW5maW5pdHknLFxuICAgICAgICAnbnVtYmVyLmludGVnZXInOiAne3sjbGFiZWx9fSBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgICAnbnVtYmVyLmxlc3MnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tYXgnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5taW4nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tdWx0aXBsZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBtdWx0aXBsZSBvZiB7eyNtdWx0aXBsZX19JyxcbiAgICAgICAgJ251bWJlci5uZWdhdGl2ZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLnBvcnQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgcG9ydCcsXG4gICAgICAgICdudW1iZXIucG9zaXRpdmUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyxcbiAgICAgICAgJ251bWJlci5wcmVjaXNpb24nOiAne3sjbGFiZWx9fSBtdXN0IGhhdmUgbm8gbW9yZSB0aGFuIHt7I2xpbWl0fX0gZGVjaW1hbCBwbGFjZXMnLFxuICAgICAgICAnbnVtYmVyLnVuc2FmZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzYWZlIG51bWJlcidcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMuZXhwb25lbnRpYWxQYXJ0UmVnZXgsICcnKVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMuZG90UmVnZXgsICcnKVxuICAgICAgICAucmVwbGFjZShpbnRlcm5hbHMudHJhaWxpbmdaZXJvc1JlZ2V4LCAnJylcbiAgICAgICAgLnJlcGxhY2UoaW50ZXJuYWxzLmxlYWRpbmdTaWduQW5kWmVyb3NSZWdleCwgJycpO1xufTtcblxuXG5pbnRlcm5hbHMubm9ybWFsaXplRGVjaW1hbCA9IGZ1bmN0aW9uIChzdHIpIHtcblxuICAgIHN0ciA9IHN0clxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBwbHVzIHNpZ25zXG4gICAgICAgIC5yZXBsYWNlKC9eXFwrLywgJycpXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcyBpZiB0aGVyZSBpcyBhIGRlY2ltYWwgcG9pbnQgYW5kIHVuZWNlc3NhcnkgZGVjaW1hbCBwb2ludHNcbiAgICAgICAgLnJlcGxhY2UoL1xcLjAqJC8sICcnKVxuICAgICAgICAvLyBBZGQgYSBpbnRlZ2VyIDAgaWYgdGhlIG51bWJlcnMgc3RhcnRzIHdpdGggYSBkZWNpbWFsIHBvaW50XG4gICAgICAgIC5yZXBsYWNlKC9eKC0/KVxcLihbXlxcLl0qKSQvLCAnJDEwLiQyJylcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pMCsoWzAtOV0pLywgJyQxJDInKTtcblxuICAgIGlmIChzdHIuaW5jbHVkZXMoJy4nKSAmJlxuICAgICAgICBzdHIuZW5kc1dpdGgoJzAnKSkge1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8wKyQvLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0ciA9PT0gJy0wJykge1xuICAgICAgICByZXR1cm4gJzAnO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG59O1xuIl0sIm5hbWVzIjpbIkFzc2VydCIsInJlcXVpcmUiLCJBbnkiLCJDb21tb24iLCJpbnRlcm5hbHMiLCJudW1iZXJSeCIsInByZWNpc2lvblJ4IiwiZXhwb25lbnRpYWxQYXJ0UmVnZXgiLCJsZWFkaW5nU2lnbkFuZFplcm9zUmVnZXgiLCJkb3RSZWdleCIsInRyYWlsaW5nWmVyb3NSZWdleCIsImRlY2ltYWxQbGFjZXMiLCJ2YWx1ZSIsInN0ciIsInRvU3RyaW5nIiwiZGluZGV4IiwiaW5kZXhPZiIsImVpbmRleCIsImxlbmd0aCIsIk1hdGgiLCJtYXgiLCJwYXJzZUludCIsInNsaWNlIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4dGVuZCIsInR5cGUiLCJmbGFncyIsInVuc2FmZSIsImRlZmF1bHQiLCJjb2VyY2UiLCJmcm9tIiwibWV0aG9kIiwic2NoZW1hIiwiZXJyb3IiLCJtYXRjaGVzIiwibWF0Y2giLCJ0cmltIiwicmVzdWx0IiwicGFyc2VGbG9hdCIsIl9mbGFncyIsImV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyIsIlN0cmluZyIsImVycm9ycyIsInN0cmluZyIsIm5vcm1hbGl6ZURlY2ltYWwiLCJ2YWxpZGF0ZSIsInByZWZzIiwiSW5maW5pdHkiLCJpc051bWJlciIsImNvbnZlcnQiLCJydWxlIiwiJF9nZXRSdWxlIiwicHJlY2lzaW9uIiwicG93IiwiYXJncyIsImxpbWl0Iiwicm91bmQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsInJ1bGVzIiwiY29tcGFyZSIsImhlbHBlcnMiLCJuYW1lIiwib3BlcmF0b3IiLCJyZWYiLCJhc3NlcnQiLCJtZXNzYWdlIiwiZ3JlYXRlciIsIiRfYWRkUnVsZSIsImludGVnZXIiLCJ0cnVuYyIsImxlc3MiLCJtaW4iLCJtdWx0aXBsZSIsImJhc2UiLCJiYXNlRGVjaW1hbFBsYWNlIiwicGZhY3RvciIsIm9wdGlvbnMiLCJ2YWx1ZURlY2ltYWxQbGFjZSIsImlzRmluaXRlIiwibXVsdGkiLCJuZWdhdGl2ZSIsInNpZ24iLCJwb3J0IiwiaXNTYWZlSW50ZWdlciIsInBvc2l0aXZlIiwicGxhY2VzIiwiZGVjaW1hbHMiLCJpbmNsdWRlcyIsImVuYWJsZWQiLCIkX3NldEZsYWciLCJjYXN0IiwidG8iLCJtZXNzYWdlcyIsInJlcGxhY2UiLCJlbmRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/number.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/object.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/object.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Keys = __webpack_require__(/*! ./keys */ \"(rsc)/./node_modules/joi/lib/types/keys.js\");\nconst internals = {};\nmodule.exports = Keys.extend({\n    type: \"object\",\n    cast: {\n        map: {\n            from: (value)=>value && typeof value === \"object\",\n            to (value, helpers) {\n                return new Map(Object.entries(value));\n            }\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9vYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUdyQixNQUFNQyxZQUFZLENBQUM7QUFHbkJDLE9BQU9DLE9BQU8sR0FBR0osS0FBS0ssTUFBTSxDQUFDO0lBRXpCQyxNQUFNO0lBRU5DLE1BQU07UUFDRkMsS0FBSztZQUNEQyxNQUFNLENBQUNDLFFBQVVBLFNBQVMsT0FBT0EsVUFBVTtZQUMzQ0MsSUFBR0QsS0FBSyxFQUFFRSxPQUFPO2dCQUViLE9BQU8sSUFBSUMsSUFBSUMsT0FBT0MsT0FBTyxDQUFDTDtZQUNsQztRQUNKO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvb2JqZWN0LmpzP2FkZDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlzLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnb2JqZWN0JyxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmVudHJpZXModmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbIktleXMiLCJyZXF1aXJlIiwiaW50ZXJuYWxzIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4dGVuZCIsInR5cGUiLCJjYXN0IiwibWFwIiwiZnJvbSIsInZhbHVlIiwidG8iLCJoZWxwZXJzIiwiTWFwIiwiT2JqZWN0IiwiZW50cmllcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/object.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/string.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/string.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Domain = __webpack_require__(/*! @sideway/address/lib/domain */ \"(rsc)/./node_modules/@sideway/address/lib/domain.js\");\nconst Email = __webpack_require__(/*! @sideway/address/lib/email */ \"(rsc)/./node_modules/@sideway/address/lib/email.js\");\nconst Ip = __webpack_require__(/*! @sideway/address/lib/ip */ \"(rsc)/./node_modules/@sideway/address/lib/ip.js\");\nconst EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ \"(rsc)/./node_modules/@hapi/hoek/lib/escapeRegex.js\");\nconst Tlds = __webpack_require__(/*! @sideway/address/lib/tlds */ \"(rsc)/./node_modules/@sideway/address/lib/tlds.js\");\nconst Uri = __webpack_require__(/*! @sideway/address/lib/uri */ \"(rsc)/./node_modules/@sideway/address/lib/uri.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst Common = __webpack_require__(/*! ../common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst internals = {\n    tlds: Tlds instanceof Set ? {\n        tlds: {\n            allow: Tlds,\n            deny: null\n        }\n    } : false,\n    base64Regex: {\n        // paddingRequired\n        true: {\n            // urlSafe\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}==|[\\w\\-]{3}=)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n        },\n        false: {\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}(==)?|[\\w\\-]{3}=?)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/\n        }\n    },\n    dataUriRegex: /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/,\n    hexRegex: {\n        withPrefix: /^0x[0-9a-f]+$/i,\n        withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i,\n        withoutPrefix: /^[0-9a-f]+$/i\n    },\n    ipRegex: Ip.regex({\n        cidr: \"forbidden\"\n    }).regex,\n    isoDurationRegex: /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/,\n    guidBrackets: {\n        \"{\": \"}\",\n        \"[\": \"]\",\n        \"(\": \")\",\n        \"\": \"\"\n    },\n    guidVersions: {\n        uuidv1: \"1\",\n        uuidv2: \"2\",\n        uuidv3: \"3\",\n        uuidv4: \"4\",\n        uuidv5: \"5\",\n        uuidv6: \"6\",\n        uuidv7: \"7\",\n        uuidv8: \"8\"\n    },\n    guidSeparators: new Set([\n        undefined,\n        true,\n        false,\n        \"-\",\n        \":\"\n    ]),\n    normalizationForms: [\n        \"NFC\",\n        \"NFD\",\n        \"NFKC\",\n        \"NFKD\"\n    ]\n};\nmodule.exports = Any.extend({\n    type: \"string\",\n    flags: {\n        insensitive: {\n            default: false\n        },\n        truncate: {\n            default: false\n        }\n    },\n    terms: {\n        replacements: {\n            init: null\n        }\n    },\n    coerce: {\n        from: \"string\",\n        method (value, { schema, state, prefs }) {\n            const normalize = schema.$_getRule(\"normalize\");\n            if (normalize) {\n                value = value.normalize(normalize.args.form);\n            }\n            const casing = schema.$_getRule(\"case\");\n            if (casing) {\n                value = casing.args.direction === \"upper\" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n            }\n            const trim = schema.$_getRule(\"trim\");\n            if (trim && trim.args.enabled) {\n                value = value.trim();\n            }\n            if (schema.$_terms.replacements) {\n                for (const replacement of schema.$_terms.replacements){\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n            const hex = schema.$_getRule(\"hex\");\n            if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {\n                value = `0${value}`;\n            }\n            if (schema.$_getRule(\"isoDate\")) {\n                const iso = internals.isoDate(value);\n                if (iso) {\n                    value = iso;\n                }\n            }\n            if (schema._flags.truncate) {\n                const rule = schema.$_getRule(\"max\");\n                if (rule) {\n                    let limit = rule.args.limit;\n                    if (Common.isResolvable(limit)) {\n                        limit = limit.resolve(value, state, prefs);\n                        if (!Common.limit(limit)) {\n                            return {\n                                value,\n                                errors: schema.$_createError(\"any.ref\", limit, {\n                                    ref: rule.args.limit,\n                                    arg: \"limit\",\n                                    reason: \"must be a positive integer\"\n                                }, state, prefs)\n                            };\n                        }\n                    }\n                    value = value.slice(0, limit);\n                }\n            }\n            return {\n                value\n            };\n        }\n    },\n    validate (value, { schema, error }) {\n        if (typeof value !== \"string\") {\n            return {\n                value,\n                errors: error(\"string.base\")\n            };\n        }\n        if (value === \"\") {\n            const min = schema.$_getRule(\"min\");\n            if (min && min.args.limit === 0) {\n                return;\n            }\n            return {\n                value,\n                errors: error(\"string.empty\")\n            };\n        }\n    },\n    rules: {\n        alphanum: {\n            method () {\n                return this.$_addRule(\"alphanum\");\n            },\n            validate (value, helpers) {\n                if (/^[a-zA-Z0-9]+$/.test(value)) {\n                    return value;\n                }\n                return helpers.error(\"string.alphanum\");\n            }\n        },\n        base64: {\n            method (options = {}) {\n                Common.assertOptions(options, [\n                    \"paddingRequired\",\n                    \"urlSafe\"\n                ]);\n                options = {\n                    urlSafe: false,\n                    paddingRequired: true,\n                    ...options\n                };\n                Assert(typeof options.paddingRequired === \"boolean\", \"paddingRequired must be boolean\");\n                Assert(typeof options.urlSafe === \"boolean\", \"urlSafe must be boolean\");\n                return this.$_addRule({\n                    name: \"base64\",\n                    args: {\n                        options\n                    }\n                });\n            },\n            validate (value, helpers, { options }) {\n                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];\n                if (regex.test(value)) {\n                    return value;\n                }\n                return helpers.error(\"string.base64\");\n            }\n        },\n        case: {\n            method (direction) {\n                Assert([\n                    \"lower\",\n                    \"upper\"\n                ].includes(direction), \"Invalid case:\", direction);\n                return this.$_addRule({\n                    name: \"case\",\n                    args: {\n                        direction\n                    }\n                });\n            },\n            validate (value, helpers, { direction }) {\n                if (direction === \"lower\" && value === value.toLocaleLowerCase() || direction === \"upper\" && value === value.toLocaleUpperCase()) {\n                    return value;\n                }\n                return helpers.error(`string.${direction}case`);\n            },\n            convert: true\n        },\n        creditCard: {\n            method () {\n                return this.$_addRule(\"creditCard\");\n            },\n            validate (value, helpers) {\n                let i = value.length;\n                let sum = 0;\n                let mul = 1;\n                while(i--){\n                    const char = value.charAt(i) * mul;\n                    sum = sum + (char - (char > 9) * 9);\n                    mul = mul ^ 3;\n                }\n                if (sum > 0 && sum % 10 === 0) {\n                    return value;\n                }\n                return helpers.error(\"string.creditCard\");\n            }\n        },\n        dataUri: {\n            method (options = {}) {\n                Common.assertOptions(options, [\n                    \"paddingRequired\"\n                ]);\n                options = {\n                    paddingRequired: true,\n                    ...options\n                };\n                Assert(typeof options.paddingRequired === \"boolean\", \"paddingRequired must be boolean\");\n                return this.$_addRule({\n                    name: \"dataUri\",\n                    args: {\n                        options\n                    }\n                });\n            },\n            validate (value, helpers, { options }) {\n                const matches = value.match(internals.dataUriRegex);\n                if (matches) {\n                    if (!matches[2]) {\n                        return value;\n                    }\n                    if (matches[2] !== \"base64\") {\n                        return value;\n                    }\n                    const base64regex = internals.base64Regex[options.paddingRequired].false;\n                    if (base64regex.test(matches[3])) {\n                        return value;\n                    }\n                }\n                return helpers.error(\"string.dataUri\");\n            }\n        },\n        domain: {\n            method (options) {\n                if (options) {\n                    Common.assertOptions(options, [\n                        \"allowFullyQualified\",\n                        \"allowUnicode\",\n                        \"maxDomainSegments\",\n                        \"minDomainSegments\",\n                        \"tlds\"\n                    ]);\n                }\n                const address = internals.addressOptions(options);\n                return this.$_addRule({\n                    name: \"domain\",\n                    args: {\n                        options\n                    },\n                    address\n                });\n            },\n            validate (value, helpers, args, { address }) {\n                if (Domain.isValid(value, address)) {\n                    return value;\n                }\n                return helpers.error(\"string.domain\");\n            }\n        },\n        email: {\n            method (options = {}) {\n                Common.assertOptions(options, [\n                    \"allowFullyQualified\",\n                    \"allowUnicode\",\n                    \"ignoreLength\",\n                    \"maxDomainSegments\",\n                    \"minDomainSegments\",\n                    \"multiple\",\n                    \"separator\",\n                    \"tlds\"\n                ]);\n                Assert(options.multiple === undefined || typeof options.multiple === \"boolean\", \"multiple option must be an boolean\");\n                const address = internals.addressOptions(options);\n                const regex = new RegExp(`\\\\s*[${options.separator ? EscapeRegex(options.separator) : \",\"}]\\\\s*`);\n                return this.$_addRule({\n                    name: \"email\",\n                    args: {\n                        options\n                    },\n                    regex,\n                    address\n                });\n            },\n            validate (value, helpers, { options }, { regex, address }) {\n                const emails = options.multiple ? value.split(regex) : [\n                    value\n                ];\n                const invalids = [];\n                for (const email of emails){\n                    if (!Email.isValid(email, address)) {\n                        invalids.push(email);\n                    }\n                }\n                if (!invalids.length) {\n                    return value;\n                }\n                return helpers.error(\"string.email\", {\n                    value,\n                    invalids\n                });\n            }\n        },\n        guid: {\n            alias: \"uuid\",\n            method (options = {}) {\n                Common.assertOptions(options, [\n                    \"version\",\n                    \"separator\"\n                ]);\n                let versionNumbers = \"\";\n                if (options.version) {\n                    const versions = [].concat(options.version);\n                    Assert(versions.length >= 1, \"version must have at least 1 valid version specified\");\n                    const set = new Set();\n                    for(let i = 0; i < versions.length; ++i){\n                        const version = versions[i];\n                        Assert(typeof version === \"string\", \"version at position \" + i + \" must be a string\");\n                        const versionNumber = internals.guidVersions[version.toLowerCase()];\n                        Assert(versionNumber, \"version at position \" + i + \" must be one of \" + Object.keys(internals.guidVersions).join(\", \"));\n                        Assert(!set.has(versionNumber), \"version at position \" + i + \" must not be a duplicate\");\n                        versionNumbers += versionNumber;\n                        set.add(versionNumber);\n                    }\n                }\n                Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, \"-\", or \":\"');\n                const separator = options.separator === undefined ? \"[:-]?\" : options.separator === true ? \"[:-]\" : options.separator === false ? \"[]?\" : `\\\\${options.separator}`;\n                const regex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\\\2?[${versionNumbers || \"0-9A-F\"}][0-9A-F]{3}\\\\2?[${versionNumbers ? \"89AB\" : \"0-9A-F\"}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, \"i\");\n                return this.$_addRule({\n                    name: \"guid\",\n                    args: {\n                        options\n                    },\n                    regex\n                });\n            },\n            validate (value, helpers, args, { regex }) {\n                const results = regex.exec(value);\n                if (!results) {\n                    return helpers.error(\"string.guid\");\n                }\n                // Matching braces\n                if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                    return helpers.error(\"string.guid\");\n                }\n                return value;\n            }\n        },\n        hex: {\n            method (options = {}) {\n                Common.assertOptions(options, [\n                    \"byteAligned\",\n                    \"prefix\"\n                ]);\n                options = {\n                    byteAligned: false,\n                    prefix: false,\n                    ...options\n                };\n                Assert(typeof options.byteAligned === \"boolean\", \"byteAligned must be boolean\");\n                Assert(typeof options.prefix === \"boolean\" || options.prefix === \"optional\", 'prefix must be boolean or \"optional\"');\n                return this.$_addRule({\n                    name: \"hex\",\n                    args: {\n                        options\n                    }\n                });\n            },\n            validate (value, helpers, { options }) {\n                const re = options.prefix === \"optional\" ? internals.hexRegex.withOptionalPrefix : options.prefix === true ? internals.hexRegex.withPrefix : internals.hexRegex.withoutPrefix;\n                if (!re.test(value)) {\n                    return helpers.error(\"string.hex\");\n                }\n                if (options.byteAligned && value.length % 2 !== 0) {\n                    return helpers.error(\"string.hexAlign\");\n                }\n                return value;\n            }\n        },\n        hostname: {\n            method () {\n                return this.$_addRule(\"hostname\");\n            },\n            validate (value, helpers) {\n                if (Domain.isValid(value, {\n                    minDomainSegments: 1\n                }) || internals.ipRegex.test(value)) {\n                    return value;\n                }\n                return helpers.error(\"string.hostname\");\n            }\n        },\n        insensitive: {\n            method () {\n                return this.$_setFlag(\"insensitive\", true);\n            }\n        },\n        ip: {\n            method (options = {}) {\n                Common.assertOptions(options, [\n                    \"cidr\",\n                    \"version\"\n                ]);\n                const { cidr, versions, regex } = Ip.regex(options);\n                const version = options.version ? versions : undefined;\n                return this.$_addRule({\n                    name: \"ip\",\n                    args: {\n                        options: {\n                            cidr,\n                            version\n                        }\n                    },\n                    regex\n                });\n            },\n            validate (value, helpers, { options }, { regex }) {\n                if (regex.test(value)) {\n                    return value;\n                }\n                if (options.version) {\n                    return helpers.error(\"string.ipVersion\", {\n                        value,\n                        cidr: options.cidr,\n                        version: options.version\n                    });\n                }\n                return helpers.error(\"string.ip\", {\n                    value,\n                    cidr: options.cidr\n                });\n            }\n        },\n        isoDate: {\n            method () {\n                return this.$_addRule(\"isoDate\");\n            },\n            validate (value, { error }) {\n                if (internals.isoDate(value)) {\n                    return value;\n                }\n                return error(\"string.isoDate\");\n            }\n        },\n        isoDuration: {\n            method () {\n                return this.$_addRule(\"isoDuration\");\n            },\n            validate (value, helpers) {\n                if (internals.isoDurationRegex.test(value)) {\n                    return value;\n                }\n                return helpers.error(\"string.isoDuration\");\n            }\n        },\n        length: {\n            method (limit, encoding) {\n                return internals.length(this, \"length\", limit, \"=\", encoding);\n            },\n            validate (value, helpers, { limit, encoding }, { name, operator, args }) {\n                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length; // $lab:coverage:ignore$\n                if (Common.compare(length, limit, operator)) {\n                    return value;\n                }\n                return helpers.error(\"string.\" + name, {\n                    limit: args.limit,\n                    value,\n                    encoding\n                });\n            },\n            args: [\n                {\n                    name: \"limit\",\n                    ref: true,\n                    assert: Common.limit,\n                    message: \"must be a positive integer\"\n                },\n                \"encoding\"\n            ]\n        },\n        lowercase: {\n            method () {\n                return this.case(\"lower\");\n            }\n        },\n        max: {\n            method (limit, encoding) {\n                return internals.length(this, \"max\", limit, \"<=\", encoding);\n            },\n            args: [\n                \"limit\",\n                \"encoding\"\n            ]\n        },\n        min: {\n            method (limit, encoding) {\n                return internals.length(this, \"min\", limit, \">=\", encoding);\n            },\n            args: [\n                \"limit\",\n                \"encoding\"\n            ]\n        },\n        normalize: {\n            method (form = \"NFC\") {\n                Assert(internals.normalizationForms.includes(form), \"normalization form must be one of \" + internals.normalizationForms.join(\", \"));\n                return this.$_addRule({\n                    name: \"normalize\",\n                    args: {\n                        form\n                    }\n                });\n            },\n            validate (value, { error }, { form }) {\n                if (value === value.normalize(form)) {\n                    return value;\n                }\n                return error(\"string.normalize\", {\n                    value,\n                    form\n                });\n            },\n            convert: true\n        },\n        pattern: {\n            alias: \"regex\",\n            method (regex, options = {}) {\n                Assert(regex instanceof RegExp, \"regex must be a RegExp\");\n                Assert(!regex.flags.includes(\"g\") && !regex.flags.includes(\"y\"), \"regex should not use global or sticky mode\");\n                if (typeof options === \"string\") {\n                    options = {\n                        name: options\n                    };\n                }\n                Common.assertOptions(options, [\n                    \"invert\",\n                    \"name\"\n                ]);\n                const errorCode = [\n                    \"string.pattern\",\n                    options.invert ? \".invert\" : \"\",\n                    options.name ? \".name\" : \".base\"\n                ].join(\"\");\n                return this.$_addRule({\n                    name: \"pattern\",\n                    args: {\n                        regex,\n                        options\n                    },\n                    errorCode\n                });\n            },\n            validate (value, helpers, { regex, options }, { errorCode }) {\n                const patternMatch = regex.test(value);\n                if (patternMatch ^ options.invert) {\n                    return value;\n                }\n                return helpers.error(errorCode, {\n                    name: options.name,\n                    regex,\n                    value\n                });\n            },\n            args: [\n                \"regex\",\n                \"options\"\n            ],\n            multi: true\n        },\n        replace: {\n            method (pattern, replacement) {\n                if (typeof pattern === \"string\") {\n                    pattern = new RegExp(EscapeRegex(pattern), \"g\");\n                }\n                Assert(pattern instanceof RegExp, \"pattern must be a RegExp\");\n                Assert(typeof replacement === \"string\", \"replacement must be a String\");\n                const obj = this.clone();\n                if (!obj.$_terms.replacements) {\n                    obj.$_terms.replacements = [];\n                }\n                obj.$_terms.replacements.push({\n                    pattern,\n                    replacement\n                });\n                return obj;\n            }\n        },\n        token: {\n            method () {\n                return this.$_addRule(\"token\");\n            },\n            validate (value, helpers) {\n                if (/^\\w+$/.test(value)) {\n                    return value;\n                }\n                return helpers.error(\"string.token\");\n            }\n        },\n        trim: {\n            method (enabled = true) {\n                Assert(typeof enabled === \"boolean\", \"enabled must be a boolean\");\n                return this.$_addRule({\n                    name: \"trim\",\n                    args: {\n                        enabled\n                    }\n                });\n            },\n            validate (value, helpers, { enabled }) {\n                if (!enabled || value === value.trim()) {\n                    return value;\n                }\n                return helpers.error(\"string.trim\");\n            },\n            convert: true\n        },\n        truncate: {\n            method (enabled = true) {\n                Assert(typeof enabled === \"boolean\", \"enabled must be a boolean\");\n                return this.$_setFlag(\"truncate\", enabled);\n            }\n        },\n        uppercase: {\n            method () {\n                return this.case(\"upper\");\n            }\n        },\n        uri: {\n            method (options = {}) {\n                Common.assertOptions(options, [\n                    \"allowRelative\",\n                    \"allowQuerySquareBrackets\",\n                    \"domain\",\n                    \"relativeOnly\",\n                    \"scheme\",\n                    \"encodeUri\"\n                ]);\n                if (options.domain) {\n                    Common.assertOptions(options.domain, [\n                        \"allowFullyQualified\",\n                        \"allowUnicode\",\n                        \"maxDomainSegments\",\n                        \"minDomainSegments\",\n                        \"tlds\"\n                    ]);\n                }\n                const { regex, scheme } = Uri.regex(options);\n                const domain = options.domain ? internals.addressOptions(options.domain) : null;\n                return this.$_addRule({\n                    name: \"uri\",\n                    args: {\n                        options\n                    },\n                    regex,\n                    domain,\n                    scheme\n                });\n            },\n            validate (value, helpers, { options }, { regex, domain, scheme }) {\n                if ([\n                    \"http:/\",\n                    \"https:/\"\n                ].includes(value)) {\n                    return helpers.error(\"string.uri\");\n                }\n                let match = regex.exec(value);\n                if (!match && helpers.prefs.convert && options.encodeUri) {\n                    const encoded = encodeURI(value);\n                    match = regex.exec(encoded);\n                    if (match) {\n                        value = encoded;\n                    }\n                }\n                if (match) {\n                    const matched = match[1] || match[2];\n                    if (domain && (!options.allowRelative || matched) && !Domain.isValid(matched, domain)) {\n                        return helpers.error(\"string.domain\", {\n                            value: matched\n                        });\n                    }\n                    return value;\n                }\n                if (options.relativeOnly) {\n                    return helpers.error(\"string.uriRelativeOnly\");\n                }\n                if (options.scheme) {\n                    return helpers.error(\"string.uriCustomScheme\", {\n                        scheme,\n                        value\n                    });\n                }\n                return helpers.error(\"string.uri\");\n            }\n        }\n    },\n    manifest: {\n        build (obj, desc) {\n            if (desc.replacements) {\n                for (const { pattern, replacement } of desc.replacements){\n                    obj = obj.replace(pattern, replacement);\n                }\n            }\n            return obj;\n        }\n    },\n    messages: {\n        \"string.alphanum\": \"{{#label}} must only contain alpha-numeric characters\",\n        \"string.base\": \"{{#label}} must be a string\",\n        \"string.base64\": \"{{#label}} must be a valid base64 string\",\n        \"string.creditCard\": \"{{#label}} must be a credit card\",\n        \"string.dataUri\": \"{{#label}} must be a valid dataUri string\",\n        \"string.domain\": \"{{#label}} must contain a valid domain name\",\n        \"string.email\": \"{{#label}} must be a valid email\",\n        \"string.empty\": \"{{#label}} is not allowed to be empty\",\n        \"string.guid\": \"{{#label}} must be a valid GUID\",\n        \"string.hex\": \"{{#label}} must only contain hexadecimal characters\",\n        \"string.hexAlign\": \"{{#label}} hex decoded representation must be byte aligned\",\n        \"string.hostname\": \"{{#label}} must be a valid hostname\",\n        \"string.ip\": \"{{#label}} must be a valid ip address with a {{#cidr}} CIDR\",\n        \"string.ipVersion\": \"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR\",\n        \"string.isoDate\": \"{{#label}} must be in iso format\",\n        \"string.isoDuration\": \"{{#label}} must be a valid ISO 8601 duration\",\n        \"string.length\": \"{{#label}} length must be {{#limit}} characters long\",\n        \"string.lowercase\": \"{{#label}} must only contain lowercase characters\",\n        \"string.max\": \"{{#label}} length must be less than or equal to {{#limit}} characters long\",\n        \"string.min\": \"{{#label}} length must be at least {{#limit}} characters long\",\n        \"string.normalize\": \"{{#label}} must be unicode normalized in the {{#form}} form\",\n        \"string.token\": \"{{#label}} must only contain alpha-numeric and underscore characters\",\n        \"string.pattern.base\": \"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}\",\n        \"string.pattern.name\": \"{{#label}} with value {:[.]} fails to match the {{#name}} pattern\",\n        \"string.pattern.invert.base\": \"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}\",\n        \"string.pattern.invert.name\": \"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern\",\n        \"string.trim\": \"{{#label}} must not have leading or trailing whitespace\",\n        \"string.uri\": \"{{#label}} must be a valid uri\",\n        \"string.uriCustomScheme\": \"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern\",\n        \"string.uriRelativeOnly\": \"{{#label}} must be a valid relative uri\",\n        \"string.uppercase\": \"{{#label}} must only contain uppercase characters\"\n    }\n});\n// Helpers\ninternals.addressOptions = function(options) {\n    if (!options) {\n        return internals.tlds || options; // $lab:coverage:ignore$\n    }\n    // minDomainSegments\n    Assert(options.minDomainSegments === undefined || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, \"minDomainSegments must be a positive integer\");\n    // maxDomainSegments\n    Assert(options.maxDomainSegments === undefined || Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, \"maxDomainSegments must be a positive integer\");\n    // tlds\n    if (options.tlds === false) {\n        return options;\n    }\n    if (options.tlds === true || options.tlds === undefined) {\n        Assert(internals.tlds, \"Built-in TLD list disabled\");\n        return Object.assign({}, options, internals.tlds);\n    }\n    Assert(typeof options.tlds === \"object\", \"tlds must be true, false, or an object\");\n    const deny = options.tlds.deny;\n    if (deny) {\n        if (Array.isArray(deny)) {\n            options = Object.assign({}, options, {\n                tlds: {\n                    deny: new Set(deny)\n                }\n            });\n        }\n        Assert(options.tlds.deny instanceof Set, \"tlds.deny must be an array, Set, or boolean\");\n        Assert(!options.tlds.allow, \"Cannot specify both tlds.allow and tlds.deny lists\");\n        internals.validateTlds(options.tlds.deny, \"tlds.deny\");\n        return options;\n    }\n    const allow = options.tlds.allow;\n    if (!allow) {\n        return options;\n    }\n    if (allow === true) {\n        Assert(internals.tlds, \"Built-in TLD list disabled\");\n        return Object.assign({}, options, internals.tlds);\n    }\n    if (Array.isArray(allow)) {\n        options = Object.assign({}, options, {\n            tlds: {\n                allow: new Set(allow)\n            }\n        });\n    }\n    Assert(options.tlds.allow instanceof Set, \"tlds.allow must be an array, Set, or boolean\");\n    internals.validateTlds(options.tlds.allow, \"tlds.allow\");\n    return options;\n};\ninternals.validateTlds = function(set, source) {\n    for (const tld of set){\n        Assert(Domain.isValid(tld, {\n            minDomainSegments: 1,\n            maxDomainSegments: 1\n        }), `${source} must contain valid top level domain names`);\n    }\n};\ninternals.isoDate = function(value) {\n    if (!Common.isIsoDate(value)) {\n        return null;\n    }\n    if (/.*T.*[+-]\\d\\d$/.test(value)) {\n        value += \"00\";\n    }\n    const date = new Date(value);\n    if (isNaN(date.getTime())) {\n        return null;\n    }\n    return date.toISOString();\n};\ninternals.length = function(schema, name, limit, operator, encoding) {\n    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), \"Invalid encoding:\", encoding); // $lab:coverage:ignore$\n    return schema.$_addRule({\n        name,\n        method: \"length\",\n        args: {\n            limit,\n            encoding\n        },\n        operator\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUN0QixNQUFNRyxLQUFLSCxtQkFBT0EsQ0FBQztBQUNuQixNQUFNSSxjQUFjSixtQkFBT0EsQ0FBQztBQUM1QixNQUFNSyxPQUFPTCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNTSxNQUFNTixtQkFBT0EsQ0FBQztBQUVwQixNQUFNTyxNQUFNUCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNUSxTQUFTUixtQkFBT0EsQ0FBQztBQUd2QixNQUFNUyxZQUFZO0lBQ2RDLE1BQU1MLGdCQUFnQk0sTUFBTTtRQUFFRCxNQUFNO1lBQUVFLE9BQU9QO1lBQU1RLE1BQU07UUFBSztJQUFFLElBQUk7SUFDcEVDLGFBQWE7UUFDVCxrQkFBa0I7UUFDbEJDLE1BQU07WUFDRixVQUFVO1lBQ1ZBLE1BQU07WUFDTkMsT0FBTztRQUNYO1FBQ0FBLE9BQU87WUFDSEQsTUFBTTtZQUNOQyxPQUFPO1FBQ1g7SUFDSjtJQUNBQyxjQUFjO0lBQ2RDLFVBQVU7UUFDTkMsWUFBWTtRQUNaQyxvQkFBb0I7UUFDcEJDLGVBQWU7SUFDbkI7SUFDQUMsU0FBU25CLEdBQUdvQixLQUFLLENBQUM7UUFBRUMsTUFBTTtJQUFZLEdBQUdELEtBQUs7SUFDOUNFLGtCQUFrQjtJQUVsQkMsY0FBYztRQUNWLEtBQUs7UUFBSyxLQUFLO1FBQUssS0FBSztRQUFLLElBQUk7SUFDdEM7SUFDQUMsY0FBYztRQUNWQyxRQUFRO1FBQ1JDLFFBQVE7UUFDUkMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLFFBQVE7UUFDUkMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLFFBQVE7SUFDWjtJQUNBQyxnQkFBZ0IsSUFBSXpCLElBQUk7UUFBQzBCO1FBQVc7UUFBTTtR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LEVBQUV1RSxRQUFRLEVBQUVELFFBQVE7SUFFaEV0SixPQUFPLENBQUNzSixZQUFZRSxVQUFVQSxPQUFPMEMsVUFBVSxDQUFDNUMsV0FBVyxxQkFBcUJBLFdBQWdCLHdCQUF3QjtJQUV4SCxPQUFPL0YsT0FBT3VDLFNBQVMsQ0FBQztRQUFFTztRQUFNaEQsUUFBUTtRQUFVTyxNQUFNO1lBQUVvQjtZQUFPc0U7UUFBUztRQUFHQztJQUFTO0FBQzFGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zdHJpbmcuanM/MjczZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRG9tYWluID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvZG9tYWluJyk7XG5jb25zdCBFbWFpbCA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL2VtYWlsJyk7XG5jb25zdCBJcCA9IHJlcXVpcmUoJ0BzaWRld2F5L2FkZHJlc3MvbGliL2lwJyk7XG5jb25zdCBFc2NhcGVSZWdleCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2VzY2FwZVJlZ2V4Jyk7XG5jb25zdCBUbGRzID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvdGxkcycpO1xuY29uc3QgVXJpID0gcmVxdWlyZSgnQHNpZGV3YXkvYWRkcmVzcy9saWIvdXJpJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdGxkczogVGxkcyBpbnN0YW5jZW9mIFNldCA/IHsgdGxkczogeyBhbGxvdzogVGxkcywgZGVueTogbnVsbCB9IH0gOiBmYWxzZSwgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGJhc2U2NFJlZ2V4OiB7XG4gICAgICAgIC8vIHBhZGRpbmdSZXF1aXJlZFxuICAgICAgICB0cnVlOiB7XG4gICAgICAgICAgICAvLyB1cmxTYWZlXG4gICAgICAgICAgICB0cnVlOiAvXig/OltcXHdcXC1dezJ9W1xcd1xcLV17Mn0pKig/OltcXHdcXC1dezJ9PT18W1xcd1xcLV17M309KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9PT18W0EtWmEtejAtOStcXC9dezN9PSk/JC9cbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2U6IHtcbiAgICAgICAgICAgIHRydWU6IC9eKD86W1xcd1xcLV17Mn1bXFx3XFwtXXsyfSkqKD86W1xcd1xcLV17Mn0oPT0pP3xbXFx3XFwtXXszfT0/KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9KD09KT98W0EtWmEtejAtOStcXC9dezN9PT8pPyQvXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGFVcmlSZWdleDogL15kYXRhOltcXHcrLi1dK1xcL1tcXHcrLi1dKzsoKGNoYXJzZXQ9W1xcdy1dK3xiYXNlNjQpLCk/KC4qKSQvLFxuICAgIGhleFJlZ2V4OiB7XG4gICAgICAgIHdpdGhQcmVmaXg6IC9eMHhbMC05YS1mXSskL2ksXG4gICAgICAgIHdpdGhPcHRpb25hbFByZWZpeDogL14oPzoweCk/WzAtOWEtZl0rJC9pLFxuICAgICAgICB3aXRob3V0UHJlZml4OiAvXlswLTlhLWZdKyQvaVxuICAgIH0sXG4gICAgaXBSZWdleDogSXAucmVnZXgoeyBjaWRyOiAnZm9yYmlkZGVuJyB9KS5yZWdleCxcbiAgICBpc29EdXJhdGlvblJlZ2V4OiAvXlAoPyEkKShcXGQrWSk/KFxcZCtNKT8oXFxkK1cpPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT8kLyxcblxuICAgIGd1aWRCcmFja2V0czoge1xuICAgICAgICAneyc6ICd9JywgJ1snOiAnXScsICcoJzogJyknLCAnJzogJydcbiAgICB9LFxuICAgIGd1aWRWZXJzaW9uczoge1xuICAgICAgICB1dWlkdjE6ICcxJyxcbiAgICAgICAgdXVpZHYyOiAnMicsXG4gICAgICAgIHV1aWR2MzogJzMnLFxuICAgICAgICB1dWlkdjQ6ICc0JyxcbiAgICAgICAgdXVpZHY1OiAnNScsXG4gICAgICAgIHV1aWR2NjogJzYnLFxuICAgICAgICB1dWlkdjc6ICc3JyxcbiAgICAgICAgdXVpZHY4OiAnOCdcbiAgICB9LFxuICAgIGd1aWRTZXBhcmF0b3JzOiBuZXcgU2V0KFt1bmRlZmluZWQsIHRydWUsIGZhbHNlLCAnLScsICc6J10pLFxuXG4gICAgbm9ybWFsaXphdGlvbkZvcm1zOiBbJ05GQycsICdORkQnLCAnTkZLQycsICdORktEJ11cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdzdHJpbmcnLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBpbnNlbnNpdGl2ZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICB0cnVuY2F0ZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgcmVwbGFjZW1lbnRzOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZSA9IHNjaGVtYS4kX2dldFJ1bGUoJ25vcm1hbGl6ZScpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubm9ybWFsaXplKG5vcm1hbGl6ZS5hcmdzLmZvcm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjYXNpbmcgPSBzY2hlbWEuJF9nZXRSdWxlKCdjYXNlJyk7XG4gICAgICAgICAgICBpZiAoY2FzaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjYXNpbmcuYXJncy5kaXJlY3Rpb24gPT09ICd1cHBlcicgPyB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpIDogdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHJpbSA9IHNjaGVtYS4kX2dldFJ1bGUoJ3RyaW0nKTtcbiAgICAgICAgICAgIGlmICh0cmltICYmXG4gICAgICAgICAgICAgICAgdHJpbS5hcmdzLmVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXBsYWNlbWVudCBvZiBzY2hlbWEuJF90ZXJtcy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlcGxhY2VtZW50LnBhdHRlcm4sIHJlcGxhY2VtZW50LnJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhleCA9IHNjaGVtYS4kX2dldFJ1bGUoJ2hleCcpO1xuICAgICAgICAgICAgaWYgKGhleCAmJlxuICAgICAgICAgICAgICAgIGhleC5hcmdzLm9wdGlvbnMuYnl0ZUFsaWduZWQgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGAwJHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRfZ2V0UnVsZSgnaXNvRGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNvID0gaW50ZXJuYWxzLmlzb0RhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc28pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpc287XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy50cnVuY2F0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuJF9nZXRSdWxlKCdtYXgnKTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBydWxlLmFyZ3MubGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBsaW1pdC5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFDb21tb24ubGltaXQobGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCBsaW1pdCwgeyByZWY6IHJ1bGUuYXJncy5saW1pdCwgYXJnOiAnbGltaXQnLCByZWFzb246ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicgfSwgc3RhdGUsIHByZWZzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3RyaW5nLmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgY29uc3QgbWluID0gc2NoZW1hLiRfZ2V0UnVsZSgnbWluJyk7XG4gICAgICAgICAgICBpZiAobWluICYmXG4gICAgICAgICAgICAgICAgbWluLmFyZ3MubGltaXQgPT09IDApIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N0cmluZy5lbXB0eScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBhbHBoYW51bToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdhbHBoYW51bScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoL15bYS16QS1aMC05XSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5hbHBoYW51bScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJhc2U2NDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydwYWRkaW5nUmVxdWlyZWQnLCAndXJsU2FmZSddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IHVybFNhZmU6IGZhbHNlLCBwYWRkaW5nUmVxdWlyZWQ6IHRydWUsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSAnYm9vbGVhbicsICdwYWRkaW5nUmVxdWlyZWQgbXVzdCBiZSBib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnVybFNhZmUgPT09ICdib29sZWFuJywgJ3VybFNhZmUgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYmFzZTY0JywgYXJnczogeyBvcHRpb25zIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGludGVybmFscy5iYXNlNjRSZWdleFtvcHRpb25zLnBhZGRpbmdSZXF1aXJlZF1bb3B0aW9ucy51cmxTYWZlXTtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuYmFzZTY0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FzZToge1xuICAgICAgICAgICAgbWV0aG9kKGRpcmVjdGlvbikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnbG93ZXInLCAndXBwZXInXS5pbmNsdWRlcyhkaXJlY3Rpb24pLCAnSW52YWxpZCBjYXNlOicsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnY2FzZScsIGFyZ3M6IHsgZGlyZWN0aW9uIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgZGlyZWN0aW9uIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdsb3dlcicgJiYgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID09PSAndXBwZXInICYmIHZhbHVlID09PSB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGBzdHJpbmcuJHtkaXJlY3Rpb259Y2FzZWApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVkaXRDYXJkOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2NyZWRpdENhcmQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgbGV0IGkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IG11bCA9IDE7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXIgPSB2YWx1ZS5jaGFyQXQoaSkgKiBtdWw7XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIChjaGFyIC0gKGNoYXIgPiA5KSAqIDkpO1xuICAgICAgICAgICAgICAgICAgICBtdWwgPSBtdWwgXiAzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdW0gPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIHN1bSAlIDEwID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuY3JlZGl0Q2FyZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRhdGFVcmk6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsncGFkZGluZ1JlcXVpcmVkJ10pO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgcGFkZGluZ1JlcXVpcmVkOiB0cnVlLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gJ2Jvb2xlYW4nLCAncGFkZGluZ1JlcXVpcmVkIG11c3QgYmUgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2RhdGFVcmknLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChpbnRlcm5hbHMuZGF0YVVyaVJlZ2V4KTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMl0gIT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjRyZWdleCA9IGludGVybmFscy5iYXNlNjRSZWdleFtvcHRpb25zLnBhZGRpbmdSZXF1aXJlZF0uZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlNjRyZWdleC50ZXN0KG1hdGNoZXNbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmRhdGFVcmknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkb21haW46IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93RnVsbHlRdWFsaWZpZWQnLCAnYWxsb3dVbmljb2RlJywgJ21heERvbWFpblNlZ21lbnRzJywgJ21pbkRvbWFpblNlZ21lbnRzJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZG9tYWluJywgYXJnczogeyBvcHRpb25zIH0sIGFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHsgYWRkcmVzcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoRG9tYWluLmlzVmFsaWQodmFsdWUsIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmRvbWFpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVtYWlsOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93RnVsbHlRdWFsaWZpZWQnLCAnYWxsb3dVbmljb2RlJywgJ2lnbm9yZUxlbmd0aCcsICdtYXhEb21haW5TZWdtZW50cycsICdtaW5Eb21haW5TZWdtZW50cycsICdtdWx0aXBsZScsICdzZXBhcmF0b3InLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5tdWx0aXBsZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLm11bHRpcGxlID09PSAnYm9vbGVhbicsICdtdWx0aXBsZSBvcHRpb24gbXVzdCBiZSBhbiBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXHMqWyR7b3B0aW9ucy5zZXBhcmF0b3IgPyBFc2NhcGVSZWdleChvcHRpb25zLnNlcGFyYXRvcikgOiAnLCd9XVxcXFxzKmApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2VtYWlsJywgYXJnczogeyBvcHRpb25zIH0sIHJlZ2V4LCBhZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyByZWdleCwgYWRkcmVzcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbHMgPSBvcHRpb25zLm11bHRpcGxlID8gdmFsdWUuc3BsaXQocmVnZXgpIDogW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1haWwgb2YgZW1haWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghRW1haWwuaXNWYWxpZChlbWFpbCwgYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRzLnB1c2goZW1haWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnZhbGlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZW1haWwnLCB7IHZhbHVlLCBpbnZhbGlkcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBndWlkOiB7XG4gICAgICAgICAgICBhbGlhczogJ3V1aWQnLFxuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWyd2ZXJzaW9uJywgJ3NlcGFyYXRvciddKTtcblxuICAgICAgICAgICAgICAgIGxldCB2ZXJzaW9uTnVtYmVycyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IFtdLmNvbmNhdChvcHRpb25zLnZlcnNpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2ZXJzaW9ucy5sZW5ndGggPj0gMSwgJ3ZlcnNpb24gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmFsaWQgdmVyc2lvbiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uTnVtYmVyID0gaW50ZXJuYWxzLmd1aWRWZXJzaW9uc1t2ZXJzaW9uLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZlcnNpb25OdW1iZXIsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoaW50ZXJuYWxzLmd1aWRWZXJzaW9ucykuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXNldC5oYXModmVyc2lvbk51bWJlciksICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IG5vdCBiZSBhIGR1cGxpY2F0ZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uTnVtYmVycyArPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LmFkZCh2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChpbnRlcm5hbHMuZ3VpZFNlcGFyYXRvcnMuaGFzKG9wdGlvbnMuc2VwYXJhdG9yKSwgJ3NlcGFyYXRvciBtdXN0IGJlIG9uZSBvZiB0cnVlLCBmYWxzZSwgXCItXCIsIG9yIFwiOlwiJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucy5zZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICdbOi1dPycgOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcGFyYXRvciA9PT0gdHJ1ZSA/ICdbOi1dJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlcGFyYXRvciA9PT0gZmFsc2UgPyAnW10/JyA6IGBcXFxcJHtvcHRpb25zLnNlcGFyYXRvcn1gO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeKFtcXFxcW3tcXFxcKF0/KVswLTlBLUZdezh9KCR7c2VwYXJhdG9yfSlbMC05QS1GXXs0fVxcXFwyP1ske3ZlcnNpb25OdW1iZXJzIHx8ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1ske3ZlcnNpb25OdW1iZXJzID8gJzg5QUInIDogJzAtOUEtRid9XVswLTlBLUZdezN9XFxcXDI/WzAtOUEtRl17MTJ9KFtcXFxcXX1cXFxcKV0/KSRgLCAnaScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2d1aWQnLCBhcmdzOiB7IG9wdGlvbnMgfSwgcmVnZXggfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHsgcmVnZXggfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZ3VpZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoaW5nIGJyYWNlc1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5ndWlkQnJhY2tldHNbcmVzdWx0c1sxXV0gIT09IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmd1aWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGV4OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2J5dGVBbGlnbmVkJywgJ3ByZWZpeCddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGJ5dGVBbGlnbmVkOiBmYWxzZSwgcHJlZml4OiBmYWxzZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5ieXRlQWxpZ25lZCA9PT0gJ2Jvb2xlYW4nLCAnYnl0ZUFsaWduZWQgbXVzdCBiZSBib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gJ2Jvb2xlYW4nIHx8IG9wdGlvbnMucHJlZml4ID09PSAnb3B0aW9uYWwnLCAncHJlZml4IG11c3QgYmUgYm9vbGVhbiBvciBcIm9wdGlvbmFsXCInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdoZXgnLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlID0gb3B0aW9ucy5wcmVmaXggPT09ICdvcHRpb25hbCcgP1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaGV4UmVnZXgud2l0aE9wdGlvbmFsUHJlZml4IDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXggPT09IHRydWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmhleFJlZ2V4LndpdGhQcmVmaXggOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmhleFJlZ2V4LndpdGhvdXRQcmVmaXg7XG4gICAgICAgICAgICAgICAgaWYgKCFyZS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhleCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVBbGlnbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhleEFsaWduJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhvc3RuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2hvc3RuYW1lJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChEb21haW4uaXNWYWxpZCh2YWx1ZSwgeyBtaW5Eb21haW5TZWdtZW50czogMSB9KSB8fFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaXBSZWdleC50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhvc3RuYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaW5zZW5zaXRpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpcDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydjaWRyJywgJ3ZlcnNpb24nXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGNpZHIsIHZlcnNpb25zLCByZWdleCB9ID0gSXAucmVnZXgob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/IHZlcnNpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdpcCcsIGFyZ3M6IHsgb3B0aW9uczogeyBjaWRyLCB2ZXJzaW9uIH0gfSwgcmVnZXggfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4IH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlwVmVyc2lvbicsIHsgdmFsdWUsIGNpZHI6IG9wdGlvbnMuY2lkciwgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaXAnLCB7IHZhbHVlLCBjaWRyOiBvcHRpb25zLmNpZHIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvRGF0ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpc29EYXRlJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5pc29EYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcuaXNvRGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzb0R1cmF0aW9uOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2lzb0R1cmF0aW9uJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNvRHVyYXRpb25SZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pc29EdXJhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ2xlbmd0aCcsIGxpbWl0LCAnPScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCwgZW5jb2RpbmcgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGluZyA/IEJ1ZmZlciAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmcpIDogdmFsdWUubGVuZ3RoOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZShsZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlLCBlbmNvZGluZyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZW5jb2RpbmcnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG93ZXJjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXNlKCdsb3dlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ21heCcsIGxpbWl0LCAnPD0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydsaW1pdCcsICdlbmNvZGluZyddXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbWluJywgbGltaXQsICc+PScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2xpbWl0JywgJ2VuY29kaW5nJ11cbiAgICAgICAgfSxcblxuICAgICAgICBub3JtYWxpemU6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtID0gJ05GQycpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmluY2x1ZGVzKGZvcm0pLCAnbm9ybWFsaXphdGlvbiBmb3JtIG11c3QgYmUgb25lIG9mICcgKyBpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmpvaW4oJywgJykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ25vcm1hbGl6ZScsIGFyZ3M6IHsgZm9ybSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0sIHsgZm9ybSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZhbHVlLm5vcm1hbGl6ZShmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcubm9ybWFsaXplJywgeyB2YWx1ZSwgZm9ybSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgYWxpYXM6ICdyZWdleCcsXG4gICAgICAgICAgICBtZXRob2QocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwLCAncmVnZXggbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ3knKSwgJ3JlZ2V4IHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0geyBuYW1lOiBvcHRpb25zIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpbnZlcnQnLCAnbmFtZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IFsnc3RyaW5nLnBhdHRlcm4nLCBvcHRpb25zLmludmVydCA/ICcuaW52ZXJ0JyA6ICcnLCBvcHRpb25zLm5hbWUgPyAnLm5hbWUnIDogJy5iYXNlJ10uam9pbignJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3BhdHRlcm4nLCBhcmdzOiB7IHJlZ2V4LCBvcHRpb25zIH0sIGVycm9yQ29kZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyByZWdleCwgb3B0aW9ucyB9LCB7IGVycm9yQ29kZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSByZWdleC50ZXN0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuTWF0Y2ggXiBvcHRpb25zLmludmVydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoZXJyb3JDb2RlLCB7IG5hbWU6IG9wdGlvbnMubmFtZSwgcmVnZXgsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsncmVnZXgnLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgcmVwbGFjZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoRXNjYXBlUmVnZXgocGF0dGVybiksICdnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAsICdwYXR0ZXJuIG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnc3RyaW5nJywgJ3JlcGxhY2VtZW50IG11c3QgYmUgYSBTdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cy5wdXNoKHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCd0b2tlbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoL15cXHcrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudG9rZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmltOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3RyaW0nLCBhcmdzOiB7IGVuYWJsZWQgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBlbmFibGVkIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdmFsdWUudHJpbSgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudHJpbScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICB0cnVuY2F0ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndHJ1bmNhdGUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cHBlcmNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhc2UoJ3VwcGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXJpOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93UmVsYXRpdmUnLCAnYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzJywgJ2RvbWFpbicsICdyZWxhdGl2ZU9ubHknLCAnc2NoZW1lJywgJ2VuY29kZVVyaSddKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLmRvbWFpbiwgWydhbGxvd0Z1bGx5UXVhbGlmaWVkJywgJ2FsbG93VW5pY29kZScsICdtYXhEb21haW5TZWdtZW50cycsICdtaW5Eb21haW5TZWdtZW50cycsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVnZXgsIHNjaGVtZSB9ID0gVXJpLnJlZ2V4KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluID8gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMuZG9tYWluKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3VyaScsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgZG9tYWluLCBzY2hlbWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHJlZ2V4LCBkb21haW4sIHNjaGVtZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoWydodHRwOi8nLCAnaHR0cHM6LyddLmluY2x1ZGVzKHZhbHVlKSkgeyAgICAgICAgICAgIC8vIHNjaGVtZTovIGlzIHRlY2huaWNhbGx5IHZhbGlkIGJ1dCBtYWtlcyBubyBzZW5zZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCAmJiBoZWxwZXJzLnByZWZzLmNvbnZlcnQgJiYgb3B0aW9ucy5lbmNvZGVVcmkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZVVSSSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhlbmNvZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVuY29kZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuYWxsb3dSZWxhdGl2ZSB8fCBtYXRjaGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIURvbWFpbi5pc1ZhbGlkKG1hdGNoZWQsIGRvbWFpbikpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5kb21haW4nLCB7IHZhbHVlOiBtYXRjaGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaVJlbGF0aXZlT25seScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaUN1c3RvbVNjaGVtZScsIHsgc2NoZW1lLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBwYXR0ZXJuLCByZXBsYWNlbWVudCB9IG9mIGRlc2MucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ3N0cmluZy5hbHBoYW51bSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzdHJpbmcnLFxuICAgICAgICAnc3RyaW5nLmJhc2U2NCc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBiYXNlNjQgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5jcmVkaXRDYXJkJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIGNyZWRpdCBjYXJkJyxcbiAgICAgICAgJ3N0cmluZy5kYXRhVXJpJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGRhdGFVcmkgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5kb21haW4nOiAne3sjbGFiZWx9fSBtdXN0IGNvbnRhaW4gYSB2YWxpZCBkb21haW4gbmFtZScsXG4gICAgICAgICdzdHJpbmcuZW1haWwnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICAgICAgICAnc3RyaW5nLmVtcHR5JzogJ3t7I2xhYmVsfX0gaXMgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHknLFxuICAgICAgICAnc3RyaW5nLmd1aWQnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgR1VJRCcsXG4gICAgICAgICdzdHJpbmcuaGV4JzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcuaGV4QWxpZ24nOiAne3sjbGFiZWx9fSBoZXggZGVjb2RlZCByZXByZXNlbnRhdGlvbiBtdXN0IGJlIGJ5dGUgYWxpZ25lZCcsXG4gICAgICAgICdzdHJpbmcuaG9zdG5hbWUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgaG9zdG5hbWUnLFxuICAgICAgICAnc3RyaW5nLmlwJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgd2l0aCBhIHt7I2NpZHJ9fSBDSURSJyxcbiAgICAgICAgJ3N0cmluZy5pcFZlcnNpb24nOiAne3sjbGFiZWx9fSBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcyBvZiBvbmUgb2YgdGhlIGZvbGxvd2luZyB2ZXJzaW9ucyB7eyN2ZXJzaW9ufX0gd2l0aCBhIHt7I2NpZHJ9fSBDSURSJyxcbiAgICAgICAgJ3N0cmluZy5pc29EYXRlJzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBpbiBpc28gZm9ybWF0JyxcbiAgICAgICAgJ3N0cmluZy5pc29EdXJhdGlvbic6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCBJU08gODYwMSBkdXJhdGlvbicsXG4gICAgICAgICdzdHJpbmcubGVuZ3RoJzogJ3t7I2xhYmVsfX0gbGVuZ3RoIG11c3QgYmUge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLmxvd2VyY2FzZSc6ICd7eyNsYWJlbH19IG11c3Qgb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5tYXgnOiAne3sjbGFiZWx9fSBsZW5ndGggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLm1pbic6ICd7eyNsYWJlbH19IGxlbmd0aCBtdXN0IGJlIGF0IGxlYXN0IHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5ub3JtYWxpemUnOiAne3sjbGFiZWx9fSBtdXN0IGJlIHVuaWNvZGUgbm9ybWFsaXplZCBpbiB0aGUge3sjZm9ybX19IGZvcm0nLFxuICAgICAgICAnc3RyaW5nLnRva2VuJzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBhbmQgdW5kZXJzY29yZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmJhc2UnOiAne3sjbGFiZWx9fSB3aXRoIHZhbHVlIHs6Wy5dfSBmYWlscyB0byBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVybjoge3sjcmVnZXh9fScsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5uYW1lJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gZmFpbHMgdG8gbWF0Y2ggdGhlIHt7I25hbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmludmVydC5iYXNlJzogJ3t7I2xhYmVsfX0gd2l0aCB2YWx1ZSB7OlsuXX0gbWF0Y2hlcyB0aGUgaW52ZXJ0ZWQgcGF0dGVybjoge3sjcmVnZXh9fScsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5pbnZlcnQubmFtZSc6ICd7eyNsYWJlbH19IHdpdGggdmFsdWUgezpbLl19IG1hdGNoZXMgdGhlIGludmVydGVkIHt7I25hbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgJ3N0cmluZy50cmltJzogJ3t7I2xhYmVsfX0gbXVzdCBub3QgaGF2ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UnLFxuICAgICAgICAnc3RyaW5nLnVyaSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCB1cmknLFxuICAgICAgICAnc3RyaW5nLnVyaUN1c3RvbVNjaGVtZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSB2YWxpZCB1cmkgd2l0aCBhIHNjaGVtZSBtYXRjaGluZyB0aGUge3sjc2NoZW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcudXJpUmVsYXRpdmVPbmx5JzogJ3t7I2xhYmVsfX0gbXVzdCBiZSBhIHZhbGlkIHJlbGF0aXZlIHVyaScsXG4gICAgICAgICdzdHJpbmcudXBwZXJjYXNlJzogJ3t7I2xhYmVsfX0gbXVzdCBvbmx5IGNvbnRhaW4gdXBwZXJjYXNlIGNoYXJhY3RlcnMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMudGxkcyB8fCBvcHRpb25zOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIH1cblxuICAgIC8vIG1pbkRvbWFpblNlZ21lbnRzXG5cbiAgICBBc3NlcnQob3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMpICYmIG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgPiAwLCAnbWluRG9tYWluU2VnbWVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgIC8vIG1heERvbWFpblNlZ21lbnRzXG5cbiAgICBBc3NlcnQob3B0aW9ucy5tYXhEb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMpICYmIG9wdGlvbnMubWF4RG9tYWluU2VnbWVudHMgPiAwLCAnbWF4RG9tYWluU2VnbWVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgIC8vIHRsZHNcblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IHRydWUgfHxcbiAgICAgICAgb3B0aW9ucy50bGRzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLnRsZHMsICdCdWlsdC1pbiBUTEQgbGlzdCBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgaW50ZXJuYWxzLnRsZHMpO1xuICAgIH1cblxuICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy50bGRzID09PSAnb2JqZWN0JywgJ3RsZHMgbXVzdCBiZSB0cnVlLCBmYWxzZSwgb3IgYW4gb2JqZWN0Jyk7XG5cbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy50bGRzLmRlbnk7XG4gICAgaWYgKGRlbnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVueSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IHsgZGVueTogbmV3IFNldChkZW55KSB9IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMudGxkcy5kZW55IGluc3RhbmNlb2YgU2V0LCAndGxkcy5kZW55IG11c3QgYmUgYW4gYXJyYXksIFNldCwgb3IgYm9vbGVhbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMudGxkcy5hbGxvdywgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggdGxkcy5hbGxvdyBhbmQgdGxkcy5kZW55IGxpc3RzJyk7XG4gICAgICAgIGludGVybmFscy52YWxpZGF0ZVRsZHMob3B0aW9ucy50bGRzLmRlbnksICd0bGRzLmRlbnknKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLnRsZHMuYWxsb3c7XG4gICAgaWYgKCFhbGxvdykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoYWxsb3cgPT09IHRydWUpIHtcbiAgICAgICAgQXNzZXJ0KGludGVybmFscy50bGRzLCAnQnVpbHQtaW4gVExEIGxpc3QgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIGludGVybmFscy50bGRzKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxvdykpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxkczogeyBhbGxvdzogbmV3IFNldChhbGxvdykgfSB9KTtcbiAgICB9XG5cbiAgICBBc3NlcnQob3B0aW9ucy50bGRzLmFsbG93IGluc3RhbmNlb2YgU2V0LCAndGxkcy5hbGxvdyBtdXN0IGJlIGFuIGFycmF5LCBTZXQsIG9yIGJvb2xlYW4nKTtcbiAgICBpbnRlcm5hbHMudmFsaWRhdGVUbGRzKG9wdGlvbnMudGxkcy5hbGxvdywgJ3RsZHMuYWxsb3cnKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlVGxkcyA9IGZ1bmN0aW9uIChzZXQsIHNvdXJjZSkge1xuXG4gICAgZm9yIChjb25zdCB0bGQgb2Ygc2V0KSB7XG4gICAgICAgIEFzc2VydChEb21haW4uaXNWYWxpZCh0bGQsIHsgbWluRG9tYWluU2VnbWVudHM6IDEsIG1heERvbWFpblNlZ21lbnRzOiAxIH0pLCBgJHtzb3VyY2V9IG11c3QgY29udGFpbiB2YWxpZCB0b3AgbGV2ZWwgZG9tYWluIG5hbWVzYCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuaXNvRGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgaWYgKCFDb21tb24uaXNJc29EYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoLy4qVC4qWystXVxcZFxcZCQvLnRlc3QodmFsdWUpKSB7ICAgICAgICAgICAgIC8vIEFkZCBtaXNzaW5nIHRyYWlsaW5nIHplcm9zIHRvIHRpbWVzaGlmdFxuICAgICAgICB2YWx1ZSArPSAnMDAnO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xufTtcblxuXG5pbnRlcm5hbHMubGVuZ3RoID0gZnVuY3Rpb24gKHNjaGVtYSwgbmFtZSwgbGltaXQsIG9wZXJhdG9yLCBlbmNvZGluZykge1xuXG4gICAgQXNzZXJ0KCFlbmNvZGluZyB8fCBCdWZmZXIgJiYgQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7ICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG5cbiAgICByZXR1cm4gc2NoZW1hLiRfYWRkUnVsZSh7IG5hbWUsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQsIGVuY29kaW5nIH0sIG9wZXJhdG9yIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJBc3NlcnQiLCJyZXF1aXJlIiwiRG9tYWluIiwiRW1haWwiLCJJcCIsIkVzY2FwZVJlZ2V4IiwiVGxkcyIsIlVyaSIsIkFueSIsIkNvbW1vbiIsImludGVybmFscyIsInRsZHMiLCJTZXQiLCJhbGxvdyIsImRlbnkiLCJiYXNlNjRSZWdleCIsInRydWUiLCJmYWxzZSIsImRhdGFVcmlSZWdleCIsImhleFJlZ2V4Iiwid2l0aFByZWZpeCIsIndpdGhPcHRpb25hbFByZWZpeCIsIndpdGhvdXRQcmVmaXgiLCJpcFJlZ2V4IiwicmVnZXgiLCJjaWRyIiwiaXNvRHVyYXRpb25SZWdleCIsImd1aWRCcmFja2V0cyIsImd1aWRWZXJzaW9ucyIsInV1aWR2MSIsInV1aWR2MiIsInV1aWR2MyIsInV1aWR2NCIsInV1aWR2NSIsInV1aWR2NiIsInV1aWR2NyIsInV1aWR2OCIsImd1aWRTZXBhcmF0b3JzIiwidW5kZWZpbmVkIiwibm9ybWFsaXphdGlvbkZvcm1zIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4dGVuZCIsInR5cGUiLCJmbGFncyIsImluc2Vuc2l0aXZlIiwiZGVmYXVsdCIsInRydW5jYXRlIiwidGVybXMiLCJyZXBsYWNlbWVudHMiLCJpbml0IiwiY29lcmNlIiwiZnJvbSIsIm1ldGhvZCIsInZhbHVlIiwic2NoZW1hIiwic3RhdGUiLCJwcmVmcyIsIm5vcm1hbGl6ZSIsIiRfZ2V0UnVsZSIsImFyZ3MiLCJmb3JtIiwiY2FzaW5nIiwiZGlyZWN0aW9uIiwidG9Mb2NhbGVVcHBlckNhc2UiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsInRyaW0iLCJlbmFibGVkIiwiJF90ZXJtcyIsInJlcGxhY2VtZW50IiwicmVwbGFjZSIsInBhdHRlcm4iLCJoZXgiLCJvcHRpb25zIiwiYnl0ZUFsaWduZWQiLCJsZW5ndGgiLCJpc28iLCJpc29EYXRlIiwiX2ZsYWdzIiwicnVsZSIsImxpbWl0IiwiaXNSZXNvbHZhYmxlIiwicmVzb2x2ZSIsImVycm9ycyIsIiRfY3JlYXRlRXJyb3IiLCJyZWYiLCJhcmciLCJyZWFzb24iLCJzbGljZSIsInZhbGlkYXRlIiwiZXJyb3IiLCJtaW4iLCJydWxlcyIsImFscGhhbnVtIiwiJF9hZGRSdWxlIiwiaGVscGVycyIsInRlc3QiLCJiYXNlNjQiLCJhc3NlcnRPcHRpb25zIiwidXJsU2FmZSIsInBhZGRpbmdSZXF1aXJlZCIsIm5hbWUiLCJjYXNlIiwiaW5jbHVkZXMiLCJjb252ZXJ0IiwiY3JlZGl0Q2FyZCIsImkiLCJzdW0iLCJtdWwiLCJjaGFyIiwiY2hhckF0IiwiZGF0YVVyaSIsIm1hdGNoZXMiLCJtYXRjaCIsImJhc2U2NHJlZ2V4IiwiZG9tYWluIiwiYWRkcmVzcyIsImFkZHJlc3NPcHRpb25zIiwiaXNWYWxpZCIsImVtYWlsIiwibXVsdGlwbGUiLCJSZWdFeHAiLCJzZXBhcmF0b3IiLCJlbWFpbHMiLCJzcGxpdCIsImludmFsaWRzIiwicHVzaCIsImd1aWQiLCJhbGlhcyIsInZlcnNpb25OdW1iZXJzIiwidmVyc2lvbiIsInZlcnNpb25zIiwiY29uY2F0Iiwic2V0IiwidmVyc2lvbk51bWJlciIsInRvTG93ZXJDYXNlIiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJoYXMiLCJhZGQiLCJyZXN1bHRzIiwiZXhlYyIsInByZWZpeCIsInJlIiwiaG9zdG5hbWUiLCJtaW5Eb21haW5TZWdtZW50cyIsIiRfc2V0RmxhZyIsImlwIiwiaXNvRHVyYXRpb24iLCJlbmNvZGluZyIsIm9wZXJhdG9yIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImNvbXBhcmUiLCJhc3NlcnQiLCJtZXNzYWdlIiwibG93ZXJjYXNlIiwibWF4IiwiZXJyb3JDb2RlIiwiaW52ZXJ0IiwicGF0dGVybk1hdGNoIiwibXVsdGkiLCJvYmoiLCJjbG9uZSIsInRva2VuIiwidXBwZXJjYXNlIiwidXJpIiwic2NoZW1lIiwiZW5jb2RlVXJpIiwiZW5jb2RlZCIsImVuY29kZVVSSSIsIm1hdGNoZWQiLCJhbGxvd1JlbGF0aXZlIiwicmVsYXRpdmVPbmx5IiwibWFuaWZlc3QiLCJidWlsZCIsImRlc2MiLCJtZXNzYWdlcyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJtYXhEb21haW5TZWdtZW50cyIsImFzc2lnbiIsIkFycmF5IiwiaXNBcnJheSIsInZhbGlkYXRlVGxkcyIsInNvdXJjZSIsInRsZCIsImlzSXNvRGF0ZSIsImRhdGUiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwidG9JU09TdHJpbmciLCJpc0VuY29kaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/types/symbol.js":
/*!**********************************************!*\
  !*** ./node_modules/joi/lib/types/symbol.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Any = __webpack_require__(/*! ./any */ \"(rsc)/./node_modules/joi/lib/types/any.js\");\nconst internals = {};\ninternals.Map = class extends Map {\n    slice() {\n        return new internals.Map(this);\n    }\n};\nmodule.exports = Any.extend({\n    type: \"symbol\",\n    terms: {\n        map: {\n            init: new internals.Map()\n        }\n    },\n    coerce: {\n        method (value, { schema, error }) {\n            const lookup = schema.$_terms.map.get(value);\n            if (lookup) {\n                value = lookup;\n            }\n            if (!schema._flags.only || typeof value === \"symbol\") {\n                return {\n                    value\n                };\n            }\n            return {\n                value,\n                errors: error(\"symbol.map\", {\n                    map: schema.$_terms.map\n                })\n            };\n        }\n    },\n    validate (value, { error }) {\n        if (typeof value !== \"symbol\") {\n            return {\n                value,\n                errors: error(\"symbol.base\")\n            };\n        }\n    },\n    rules: {\n        map: {\n            method (iterable) {\n                if (iterable && !iterable[Symbol.iterator] && typeof iterable === \"object\") {\n                    iterable = Object.entries(iterable);\n                }\n                Assert(iterable && iterable[Symbol.iterator], \"Iterable must be an iterable or object\");\n                const obj = this.clone();\n                const symbols = [];\n                for (const entry of iterable){\n                    Assert(entry && entry[Symbol.iterator], \"Entry must be an iterable\");\n                    const [key, value] = entry;\n                    Assert(typeof key !== \"object\" && typeof key !== \"function\" && typeof key !== \"symbol\", \"Key must not be of type object, function, or Symbol\");\n                    Assert(typeof value === \"symbol\", \"Value must be a Symbol\");\n                    obj.$_terms.map.set(key, value);\n                    symbols.push(value);\n                }\n                return obj.valid(...symbols);\n            }\n        }\n    },\n    manifest: {\n        build (obj, desc) {\n            if (desc.map) {\n                obj = obj.map(desc.map);\n            }\n            return obj;\n        }\n    },\n    messages: {\n        \"symbol.base\": \"{{#label}} must be a symbol\",\n        \"symbol.map\": \"{{#label}} must be one of {{#map}}\"\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi90eXBlcy9zeW1ib2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUV2QixNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUdwQixNQUFNRSxZQUFZLENBQUM7QUFHbkJBLFVBQVVDLEdBQUcsR0FBRyxjQUFjQTtJQUUxQkMsUUFBUTtRQUVKLE9BQU8sSUFBSUYsVUFBVUMsR0FBRyxDQUFDLElBQUk7SUFDakM7QUFDSjtBQUdBRSxPQUFPQyxPQUFPLEdBQUdMLElBQUlNLE1BQU0sQ0FBQztJQUV4QkMsTUFBTTtJQUVOQyxPQUFPO1FBRUhDLEtBQUs7WUFBRUMsTUFBTSxJQUFJVCxVQUFVQyxHQUFHO1FBQUc7SUFDckM7SUFFQVMsUUFBUTtRQUNKQyxRQUFPQyxLQUFLLEVBQUUsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUU7WUFFM0IsTUFBTUMsU0FBU0YsT0FBT0csT0FBTyxDQUFDUixHQUFHLENBQUNTLEdBQUcsQ0FBQ0w7WUFDdEMsSUFBSUcsUUFBUTtnQkFDUkgsUUFBUUc7WUFDWjtZQUVBLElBQUksQ0FBQ0YsT0FBT0ssTUFBTSxDQUFDQyxJQUFJLElBQ25CLE9BQU9QLFVBQVUsVUFBVTtnQkFFM0IsT0FBTztvQkFBRUE7Z0JBQU07WUFDbkI7WUFFQSxPQUFPO2dCQUFFQTtnQkFBT1EsUUFBUU4sTUFBTSxjQUFjO29CQUFFTixLQUFLSyxPQUFPRyxPQUFPLENBQUNSLEdBQUc7Z0JBQUM7WUFBRztRQUM3RTtJQUNKO0lBRUFhLFVBQVNULEtBQUssRUFBRSxFQUFFRSxLQUFLLEVBQUU7UUFFckIsSUFBSSxPQUFPRixVQUFVLFVBQVU7WUFDM0IsT0FBTztnQkFBRUE7Z0JBQU9RLFFBQVFOLE1BQU07WUFBZTtRQUNqRDtJQUNKO0lBRUFRLE9BQU87UUFDSGQsS0FBSztZQUNERyxRQUFPWSxRQUFRO2dCQUVYLElBQUlBLFlBQ0EsQ0FBQ0EsUUFBUSxDQUFDQyxPQUFPQyxRQUFRLENBQUMsSUFDMUIsT0FBT0YsYUFBYSxVQUFVO29CQUU5QkEsV0FBV0csT0FBT0MsT0FBTyxDQUFDSjtnQkFDOUI7Z0JBRUExQixPQUFPMEIsWUFBWUEsUUFBUSxDQUFDQyxPQUFPQyxRQUFRLENBQUMsRUFBRTtnQkFFOUMsTUFBTUcsTUFBTSxJQUFJLENBQUNDLEtBQUs7Z0JBRXRCLE1BQU1DLFVBQVUsRUFBRTtnQkFDbEIsS0FBSyxNQUFNQyxTQUFTUixTQUFVO29CQUMxQjFCLE9BQU9rQyxTQUFTQSxLQUFLLENBQUNQLE9BQU9DLFFBQVEsQ0FBQyxFQUFFO29CQUN4QyxNQUFNLENBQUNPLEtBQUtwQixNQUFNLEdBQUdtQjtvQkFFckJsQyxPQUFPLE9BQU9tQyxRQUFRLFlBQVksT0FBT0EsUUFBUSxjQUFjLE9BQU9BLFFBQVEsVUFBVTtvQkFDeEZuQyxPQUFPLE9BQU9lLFVBQVUsVUFBVTtvQkFFbENnQixJQUFJWixPQUFPLENBQUNSLEdBQUcsQ0FBQ3lCLEdBQUcsQ0FBQ0QsS0FBS3BCO29CQUN6QmtCLFFBQVFJLElBQUksQ0FBQ3RCO2dCQUNqQjtnQkFFQSxPQUFPZ0IsSUFBSU8sS0FBSyxJQUFJTDtZQUN4QjtRQUNKO0lBQ0o7SUFFQU0sVUFBVTtRQUVOQyxPQUFNVCxHQUFHLEVBQUVVLElBQUk7WUFFWCxJQUFJQSxLQUFLOUIsR0FBRyxFQUFFO2dCQUNWb0IsTUFBTUEsSUFBSXBCLEdBQUcsQ0FBQzhCLEtBQUs5QixHQUFHO1lBQzFCO1lBRUEsT0FBT29CO1FBQ1g7SUFDSjtJQUVBVyxVQUFVO1FBQ04sZUFBZTtRQUNmLGNBQWM7SUFDbEI7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vYmlsZS1jaGF0Z3B0LWNsb25lLy4vbm9kZV9tb2R1bGVzL2pvaS9saWIvdHlwZXMvc3ltYm9sLmpzPzBlZjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuTWFwID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuXG4gICAgc2xpY2UoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuTWFwKHRoaXMpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdzeW1ib2wnLFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBtYXA6IHsgaW5pdDogbmV3IGludGVybmFscy5NYXAoKSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cCA9IHNjaGVtYS4kX3Rlcm1zLm1hcC5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbG9va3VwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3Mub25seSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzeW1ib2wubWFwJywgeyBtYXA6IHNjaGVtYS4kX3Rlcm1zLm1hcCB9KSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N5bWJvbC5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIG1ldGhvZChpdGVyYWJsZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICFpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVyYWJsZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdC5lbnRyaWVzKGl0ZXJhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSwgJ0l0ZXJhYmxlIG11c3QgYmUgYW4gaXRlcmFibGUgb3Igb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2xzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoZW50cnkgJiYgZW50cnlbU3ltYm9sLml0ZXJhdG9yXSwgJ0VudHJ5IG11c3QgYmUgYW4gaXRlcmFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gZW50cnk7XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBrZXkgIT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGtleSAhPT0gJ3N5bWJvbCcsICdLZXkgbXVzdCBub3QgYmUgb2YgdHlwZSBvYmplY3QsIGZ1bmN0aW9uLCBvciBTeW1ib2wnKTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcsICdWYWx1ZSBtdXN0IGJlIGEgU3ltYm9sJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9scy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLnZhbGlkKC4uLnN5bWJvbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm1hcCkge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5tYXAoZGVzYy5tYXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdzeW1ib2wuYmFzZSc6ICd7eyNsYWJlbH19IG11c3QgYmUgYSBzeW1ib2wnLFxuICAgICAgICAnc3ltYm9sLm1hcCc6ICd7eyNsYWJlbH19IG11c3QgYmUgb25lIG9mIHt7I21hcH19J1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbIkFzc2VydCIsInJlcXVpcmUiLCJBbnkiLCJpbnRlcm5hbHMiLCJNYXAiLCJzbGljZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJleHRlbmQiLCJ0eXBlIiwidGVybXMiLCJtYXAiLCJpbml0IiwiY29lcmNlIiwibWV0aG9kIiwidmFsdWUiLCJzY2hlbWEiLCJlcnJvciIsImxvb2t1cCIsIiRfdGVybXMiLCJnZXQiLCJfZmxhZ3MiLCJvbmx5IiwiZXJyb3JzIiwidmFsaWRhdGUiLCJydWxlcyIsIml0ZXJhYmxlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJPYmplY3QiLCJlbnRyaWVzIiwib2JqIiwiY2xvbmUiLCJzeW1ib2xzIiwiZW50cnkiLCJrZXkiLCJzZXQiLCJwdXNoIiwidmFsaWQiLCJtYW5pZmVzdCIsImJ1aWxkIiwiZGVzYyIsIm1lc3NhZ2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/types/symbol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/validator.js":
/*!*******************************************!*\
  !*** ./node_modules/joi/lib/validator.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ \"(rsc)/./node_modules/@hapi/hoek/lib/clone.js\");\nconst Ignore = __webpack_require__(/*! @hapi/hoek/lib/ignore */ \"(rsc)/./node_modules/@hapi/hoek/lib/ignore.js\");\nconst Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ \"(rsc)/./node_modules/@hapi/hoek/lib/reach.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/joi/lib/errors.js\");\nconst State = __webpack_require__(/*! ./state */ \"(rsc)/./node_modules/joi/lib/state.js\");\nconst internals = {\n    result: Symbol(\"result\")\n};\nexports.entry = function(value, schema, prefs) {\n    let settings = Common.defaults;\n    if (prefs) {\n        Assert(prefs.warnings === undefined, \"Cannot override warnings preference in synchronous validation\");\n        Assert(prefs.artifacts === undefined, \"Cannot override artifacts preference in synchronous validation\");\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n    const result = internals.entry(value, schema, settings);\n    Assert(!result.mainstay.externals.length, \"Schema with external rules must use validateAsync()\");\n    const outcome = {\n        value: result.value\n    };\n    if (result.error) {\n        outcome.error = result.error;\n    }\n    if (result.mainstay.warnings.length) {\n        outcome.warning = Errors.details(result.mainstay.warnings);\n    }\n    if (result.mainstay.debug) {\n        outcome.debug = result.mainstay.debug;\n    }\n    if (result.mainstay.artifacts) {\n        outcome.artifacts = result.mainstay.artifacts;\n    }\n    return outcome;\n};\nexports.entryAsync = async function(value, schema, prefs) {\n    let settings = Common.defaults;\n    if (prefs) {\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n    const result = internals.entry(value, schema, settings);\n    const mainstay = result.mainstay;\n    if (result.error) {\n        if (mainstay.debug) {\n            result.error.debug = mainstay.debug;\n        }\n        throw result.error;\n    }\n    if (mainstay.externals.length) {\n        let root = result.value;\n        const errors = [];\n        for (const external of mainstay.externals){\n            const path = external.state.path;\n            const linked = external.schema.type === \"link\" ? mainstay.links.get(external.schema) : null;\n            let node = root;\n            let key;\n            let parent;\n            const ancestors = path.length ? [\n                root\n            ] : [];\n            const original = path.length ? Reach(value, path) : value;\n            if (path.length) {\n                key = path[path.length - 1];\n                let current = root;\n                for (const segment of path.slice(0, -1)){\n                    current = current[segment];\n                    ancestors.unshift(current);\n                }\n                parent = ancestors[0];\n                node = parent[key];\n            }\n            try {\n                const createError = (code, local)=>(linked || external.schema).$_createError(code, node, local, external.state, settings);\n                const output = await external.method(node, {\n                    schema: external.schema,\n                    linked,\n                    state: external.state,\n                    prefs,\n                    original,\n                    error: createError,\n                    errorsArray: internals.errorsArray,\n                    warn: (code, local)=>mainstay.warnings.push((linked || external.schema).$_createError(code, node, local, external.state, settings)),\n                    message: (messages, local)=>(linked || external.schema).$_createError(\"external\", node, local, external.state, settings, {\n                            messages\n                        })\n                });\n                if (output === undefined || output === node) {\n                    continue;\n                }\n                if (output instanceof Errors.Report) {\n                    mainstay.tracer.log(external.schema, external.state, \"rule\", \"external\", \"error\");\n                    errors.push(output);\n                    if (settings.abortEarly) {\n                        break;\n                    }\n                    continue;\n                }\n                if (Array.isArray(output) && output[Common.symbols.errors]) {\n                    mainstay.tracer.log(external.schema, external.state, \"rule\", \"external\", \"error\");\n                    errors.push(...output);\n                    if (settings.abortEarly) {\n                        break;\n                    }\n                    continue;\n                }\n                if (parent) {\n                    mainstay.tracer.value(external.state, \"rule\", node, output, \"external\");\n                    parent[key] = output;\n                } else {\n                    mainstay.tracer.value(external.state, \"rule\", root, output, \"external\");\n                    root = output;\n                }\n            } catch (err) {\n                if (settings.errors.label) {\n                    err.message += ` (${external.label})`; // Change message to include path\n                }\n                throw err;\n            }\n        }\n        result.value = root;\n        if (errors.length) {\n            result.error = Errors.process(errors, value, settings);\n            if (mainstay.debug) {\n                result.error.debug = mainstay.debug;\n            }\n            throw result.error;\n        }\n    }\n    if (!settings.warnings && !settings.debug && !settings.artifacts) {\n        return result.value;\n    }\n    const outcome = {\n        value: result.value\n    };\n    if (mainstay.warnings.length) {\n        outcome.warning = Errors.details(mainstay.warnings);\n    }\n    if (mainstay.debug) {\n        outcome.debug = mainstay.debug;\n    }\n    if (mainstay.artifacts) {\n        outcome.artifacts = mainstay.artifacts;\n    }\n    return outcome;\n};\ninternals.Mainstay = class {\n    constructor(tracer, debug, links){\n        this.externals = [];\n        this.warnings = [];\n        this.tracer = tracer;\n        this.debug = debug;\n        this.links = links;\n        this.shadow = null;\n        this.artifacts = null;\n        this._snapshots = [];\n    }\n    snapshot() {\n        this._snapshots.push({\n            externals: this.externals.slice(),\n            warnings: this.warnings.slice()\n        });\n    }\n    restore() {\n        const snapshot = this._snapshots.pop();\n        this.externals = snapshot.externals;\n        this.warnings = snapshot.warnings;\n    }\n    commit() {\n        this._snapshots.pop();\n    }\n};\ninternals.entry = function(value, schema, prefs) {\n    // Prepare state\n    const { tracer, cleanup } = internals.tracer(schema, prefs);\n    const debug = prefs.debug ? [] : null;\n    const links = schema._ids._schemaChain ? new Map() : null;\n    const mainstay = new internals.Mainstay(tracer, debug, links);\n    const schemas = schema._ids._schemaChain ? [\n        {\n            schema\n        }\n    ] : null;\n    const state = new State([], [], {\n        mainstay,\n        schemas\n    });\n    // Validate value\n    const result = exports.validate(value, schema, state, prefs);\n    // Process value and errors\n    if (cleanup) {\n        schema.$_root.untrace();\n    }\n    const error = Errors.process(result.errors, value, prefs);\n    return {\n        value: result.value,\n        error,\n        mainstay\n    };\n};\ninternals.tracer = function(schema, prefs) {\n    if (schema.$_root._tracer) {\n        return {\n            tracer: schema.$_root._tracer._register(schema)\n        };\n    }\n    if (prefs.debug) {\n        Assert(schema.$_root.trace, \"Debug mode not supported\");\n        return {\n            tracer: schema.$_root.trace()._register(schema),\n            cleanup: true\n        };\n    }\n    return {\n        tracer: internals.ignore\n    };\n};\nexports.validate = function(value, schema, state, prefs, overrides = {}) {\n    if (schema.$_terms.whens) {\n        schema = schema._generate(value, state, prefs).schema;\n    }\n    // Setup state and settings\n    if (schema._preferences) {\n        prefs = internals.prefs(schema, prefs);\n    }\n    // Cache\n    if (schema._cache && prefs.cache) {\n        const result = schema._cache.get(value);\n        state.mainstay.tracer.debug(state, \"validate\", \"cached\", !!result);\n        if (result) {\n            return result;\n        }\n    }\n    // Helpers\n    const createError = (code, local, localState)=>schema.$_createError(code, value, local, localState || state, prefs);\n    const helpers = {\n        original: value,\n        prefs,\n        schema,\n        state,\n        error: createError,\n        errorsArray: internals.errorsArray,\n        warn: (code, local, localState)=>state.mainstay.warnings.push(createError(code, local, localState)),\n        message: (messages, local)=>schema.$_createError(\"custom\", value, local, state, prefs, {\n                messages\n            })\n    };\n    // Prepare\n    state.mainstay.tracer.entry(schema, state);\n    const def = schema._definition;\n    if (def.prepare && value !== undefined && prefs.convert) {\n        const prepared = def.prepare(value, helpers);\n        if (prepared) {\n            state.mainstay.tracer.value(state, \"prepare\", value, prepared.value);\n            if (prepared.errors) {\n                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers); // Prepare error always aborts early\n            }\n            value = prepared.value;\n        }\n    }\n    // Type coercion\n    if (def.coerce && value !== undefined && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {\n        const coerced = def.coerce.method(value, helpers);\n        if (coerced) {\n            state.mainstay.tracer.value(state, \"coerced\", value, coerced.value);\n            if (coerced.errors) {\n                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers); // Coerce error always aborts early\n            }\n            value = coerced.value;\n        }\n    }\n    // Empty value\n    const empty = schema._flags.empty;\n    if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {\n        state.mainstay.tracer.value(state, \"empty\", value, undefined);\n        value = undefined;\n    }\n    // Presence requirements (required, optional, forbidden)\n    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);\n    if (value === undefined) {\n        if (presence === \"forbidden\") {\n            return internals.finalize(value, null, helpers);\n        }\n        if (presence === \"required\") {\n            return internals.finalize(value, [\n                schema.$_createError(\"any.required\", value, null, state, prefs)\n            ], helpers);\n        }\n        if (presence === \"optional\") {\n            if (schema._flags.default !== Common.symbols.deepDefault) {\n                return internals.finalize(value, null, helpers);\n            }\n            state.mainstay.tracer.value(state, \"default\", value, {});\n            value = {};\n        }\n    } else if (presence === \"forbidden\") {\n        return internals.finalize(value, [\n            schema.$_createError(\"any.unknown\", value, null, state, prefs)\n        ], helpers);\n    }\n    // Allowed values\n    const errors = [];\n    if (schema._valids) {\n        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            if (prefs.convert) {\n                state.mainstay.tracer.value(state, \"valids\", value, match.value);\n                value = match.value;\n            }\n            state.mainstay.tracer.filter(schema, state, \"valid\", match);\n            return internals.finalize(value, null, helpers);\n        }\n        if (schema._flags.only) {\n            const report = schema.$_createError(\"any.only\", value, {\n                valids: schema._valids.values({\n                    display: true\n                })\n            }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [\n                    report\n                ], helpers);\n            }\n            errors.push(report);\n        }\n    }\n    // Denied values\n    if (schema._invalids) {\n        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            state.mainstay.tracer.filter(schema, state, \"invalid\", match);\n            const report = schema.$_createError(\"any.invalid\", value, {\n                invalids: schema._invalids.values({\n                    display: true\n                })\n            }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [\n                    report\n                ], helpers);\n            }\n            errors.push(report);\n        }\n    }\n    // Base type\n    if (def.validate) {\n        const base = def.validate(value, helpers);\n        if (base) {\n            state.mainstay.tracer.value(state, \"base\", value, base.value);\n            value = base.value;\n            if (base.errors) {\n                if (!Array.isArray(base.errors)) {\n                    errors.push(base.errors);\n                    return internals.finalize(value, errors, helpers); // Base error always aborts early\n                }\n                if (base.errors.length) {\n                    errors.push(...base.errors);\n                    return internals.finalize(value, errors, helpers); // Base error always aborts early\n                }\n            }\n        }\n    }\n    // Validate tests\n    if (!schema._rules.length) {\n        return internals.finalize(value, errors, helpers);\n    }\n    return internals.rules(value, errors, helpers);\n};\ninternals.rules = function(value, errors, helpers) {\n    const { schema, state, prefs } = helpers;\n    for (const rule of schema._rules){\n        const definition = schema._definition.rules[rule.method];\n        // Skip rules that are also applied in coerce step\n        if (definition.convert && prefs.convert) {\n            state.mainstay.tracer.log(schema, state, \"rule\", rule.name, \"full\");\n            continue;\n        }\n        // Resolve references\n        let ret;\n        let args = rule.args;\n        if (rule._resolve.length) {\n            args = Object.assign({}, args); // Shallow copy\n            for (const key of rule._resolve){\n                const resolver = definition.argsByName.get(key);\n                const resolved = args[key].resolve(value, state, prefs);\n                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;\n                const invalid = Common.validateArg(normalized, null, resolver);\n                if (invalid) {\n                    ret = schema.$_createError(\"any.ref\", resolved, {\n                        arg: key,\n                        ref: args[key],\n                        reason: invalid\n                    }, state, prefs);\n                    break;\n                }\n                args[key] = normalized;\n            }\n        }\n        // Test rule\n        ret = ret || definition.validate(value, helpers, args, rule); // Use ret if already set to reference error\n        const result = internals.rule(ret, rule);\n        if (result.errors) {\n            state.mainstay.tracer.log(schema, state, \"rule\", rule.name, \"error\");\n            if (rule.warn) {\n                state.mainstay.warnings.push(...result.errors);\n                continue;\n            }\n            if (prefs.abortEarly) {\n                return internals.finalize(value, result.errors, helpers);\n            }\n            errors.push(...result.errors);\n        } else {\n            state.mainstay.tracer.log(schema, state, \"rule\", rule.name, \"pass\");\n            state.mainstay.tracer.value(state, \"rule\", value, result.value, rule.name);\n            value = result.value;\n        }\n    }\n    return internals.finalize(value, errors, helpers);\n};\ninternals.rule = function(ret, rule) {\n    if (ret instanceof Errors.Report) {\n        internals.error(ret, rule);\n        return {\n            errors: [\n                ret\n            ],\n            value: null\n        };\n    }\n    if (Array.isArray(ret) && ret[Common.symbols.errors]) {\n        ret.forEach((report)=>internals.error(report, rule));\n        return {\n            errors: ret,\n            value: null\n        };\n    }\n    return {\n        errors: null,\n        value: ret\n    };\n};\ninternals.error = function(report, rule) {\n    if (rule.message) {\n        report._setTemplate(rule.message);\n    }\n    return report;\n};\ninternals.finalize = function(value, errors, helpers) {\n    errors = errors || [];\n    const { schema, state, prefs } = helpers;\n    // Failover value\n    if (errors.length) {\n        const failover = internals.default(\"failover\", undefined, errors, helpers);\n        if (failover !== undefined) {\n            state.mainstay.tracer.value(state, \"failover\", value, failover);\n            value = failover;\n            errors = [];\n        }\n    }\n    // Error override\n    if (errors.length && schema._flags.error) {\n        if (typeof schema._flags.error === \"function\") {\n            errors = schema._flags.error(errors);\n            if (!Array.isArray(errors)) {\n                errors = [\n                    errors\n                ];\n            }\n            for (const error of errors){\n                Assert(error instanceof Error || error instanceof Errors.Report, \"error() must return an Error object\");\n            }\n        } else {\n            errors = [\n                schema._flags.error\n            ];\n        }\n    }\n    // Default\n    if (value === undefined) {\n        const defaulted = internals.default(\"default\", value, errors, helpers);\n        state.mainstay.tracer.value(state, \"default\", value, defaulted);\n        value = defaulted;\n    }\n    // Cast\n    if (schema._flags.cast && value !== undefined) {\n        const caster = schema._definition.cast[schema._flags.cast];\n        if (caster.from(value)) {\n            const casted = caster.to(value, helpers);\n            state.mainstay.tracer.value(state, \"cast\", value, casted, schema._flags.cast);\n            value = casted;\n        }\n    }\n    // Externals\n    if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {\n        for (const { method } of schema.$_terms.externals){\n            state.mainstay.externals.push({\n                method,\n                schema,\n                state,\n                label: Errors.label(schema._flags, state, prefs)\n            });\n        }\n    }\n    // Result\n    const result = {\n        value,\n        errors: errors.length ? errors : null\n    };\n    if (schema._flags.result) {\n        result.value = schema._flags.result === \"strip\" ? undefined : /* raw */ helpers.original;\n        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);\n        state.shadow(value, schema._flags.result);\n    }\n    // Cache\n    if (schema._cache && prefs.cache !== false && !schema._refs.length) {\n        schema._cache.set(helpers.original, result);\n    }\n    // Artifacts\n    if (value !== undefined && !result.errors && schema._flags.artifact !== undefined) {\n        state.mainstay.artifacts = state.mainstay.artifacts || new Map();\n        if (!state.mainstay.artifacts.has(schema._flags.artifact)) {\n            state.mainstay.artifacts.set(schema._flags.artifact, []);\n        }\n        state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);\n    }\n    return result;\n};\ninternals.prefs = function(schema, prefs) {\n    const isDefaultOptions = prefs === Common.defaults;\n    if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {\n        return schema._preferences[Common.symbols.prefs];\n    }\n    prefs = Common.preferences(prefs, schema._preferences);\n    if (isDefaultOptions) {\n        schema._preferences[Common.symbols.prefs] = prefs;\n    }\n    return prefs;\n};\ninternals.default = function(flag, value, errors, helpers) {\n    const { schema, state, prefs } = helpers;\n    const source = schema._flags[flag];\n    if (prefs.noDefaults || source === undefined) {\n        return value;\n    }\n    state.mainstay.tracer.log(schema, state, \"rule\", flag, \"full\");\n    if (!source) {\n        return source;\n    }\n    if (typeof source === \"function\") {\n        const args = source.length ? [\n            Clone(state.ancestors[0]),\n            helpers\n        ] : [];\n        try {\n            return source(...args);\n        } catch (err) {\n            errors.push(schema.$_createError(`any.${flag}`, null, {\n                error: err\n            }, state, prefs));\n            return;\n        }\n    }\n    if (typeof source !== \"object\") {\n        return source;\n    }\n    if (source[Common.symbols.literal]) {\n        return source.literal;\n    }\n    if (Common.isResolvable(source)) {\n        return source.resolve(value, state, prefs);\n    }\n    return Clone(source);\n};\ninternals.trim = function(value, schema) {\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    const trim = schema.$_getRule(\"trim\");\n    if (!trim || !trim.args.enabled) {\n        return value;\n    }\n    return value.trim();\n};\ninternals.ignore = {\n    active: false,\n    debug: Ignore,\n    entry: Ignore,\n    filter: Ignore,\n    log: Ignore,\n    resolve: Ignore,\n    value: Ignore\n};\ninternals.errorsArray = function() {\n    const errors = [];\n    errors[Common.symbols.errors] = true;\n    return errors;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUN0QixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUN2QixNQUFNRyxRQUFRSCxtQkFBT0EsQ0FBQztBQUV0QixNQUFNSSxTQUFTSixtQkFBT0EsQ0FBQztBQUN2QixNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNTSxRQUFRTixtQkFBT0EsQ0FBQztBQUd0QixNQUFNTyxZQUFZO0lBQ2RDLFFBQVFDLE9BQU87QUFDbkI7QUFHQUMsYUFBYSxHQUFHLFNBQVVFLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxLQUFLO0lBRTFDLElBQUlDLFdBQVdYLE9BQU9ZLFFBQVE7SUFDOUIsSUFBSUYsT0FBTztRQUNQZixPQUFPZSxNQUFNRyxRQUFRLEtBQUtDLFdBQVc7UUFDckNuQixPQUFPZSxNQUFNSyxTQUFTLEtBQUtELFdBQVc7UUFDdENILFdBQVdYLE9BQU9nQixXQUFXLENBQUNoQixPQUFPWSxRQUFRLEVBQUVGO0lBQ25EO0lBRUEsTUFBTU4sU0FBU0QsVUFBVUksS0FBSyxDQUFDQyxPQUFPQyxRQUFRRTtJQUM5Q2hCLE9BQU8sQ0FBQ1MsT0FBT2EsUUFBUSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sRUFBRTtJQUMxQyxNQUFNQyxVQUFVO1FBQUVaLE9BQU9KLE9BQU9JLEtBQUs7SUFBQztJQUV0QyxJQUFJSixPQUFPaUIsS0FBSyxFQUFFO1FBQ2RELFFBQVFDLEtBQUssR0FBR2pCLE9BQU9pQixLQUFLO0lBQ2hDO0lBRUEsSUFBSWpCLE9BQU9hLFFBQVEsQ0FBQ0osUUFBUSxDQUFDTSxNQUFNLEVBQUU7UUFDakNDLFFBQVFFLE9BQU8sR0FBR3JCLE9BQU9zQixPQUFPLENBQUNuQixPQUFPYSxRQUFRLENBQUNKLFFBQVE7SUFDN0Q7SUFFQSxJQUFJ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RyxJQUFJO0FBQ3JCO0FBR0F6RyxVQUFVaUYsTUFBTSxHQUFHO0lBQ2ZxRixRQUFRO0lBQ1JqSixPQUFPMUI7SUFDUFMsT0FBT1Q7SUFDUHVILFFBQVF2SDtJQUNSMkQsS0FBSzNEO0lBQ0w2SSxTQUFTN0k7SUFDVFUsT0FBT1Y7QUFDWDtBQUdBSyxVQUFVK0MsV0FBVyxHQUFHO0lBRXBCLE1BQU12QixTQUFTLEVBQUU7SUFDakJBLE1BQU0sQ0FBQzNCLE9BQU82RCxPQUFPLENBQUNsQyxNQUFNLENBQUMsR0FBRztJQUNoQyxPQUFPQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9iaWxlLWNoYXRncHQtY2xvbmUvLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWxpZGF0b3IuanM/NWJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgSWdub3JlID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvaWdub3JlJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgU3RhdGUgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHJlc3VsdDogU3ltYm9sKCdyZXN1bHQnKVxufTtcblxuXG5leHBvcnRzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKHByZWZzKSB7XG4gICAgICAgIEFzc2VydChwcmVmcy53YXJuaW5ncyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIHdhcm5pbmdzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBBc3NlcnQocHJlZnMuYXJ0aWZhY3RzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgYXJ0aWZhY3RzIHByZWZlcmVuY2UgaW4gc3luY2hyb25vdXMgdmFsaWRhdGlvbicpO1xuICAgICAgICBzZXR0aW5ncyA9IENvbW1vbi5wcmVmZXJlbmNlcyhDb21tb24uZGVmYXVsdHMsIHByZWZzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuZW50cnkodmFsdWUsIHNjaGVtYSwgc2V0dGluZ3MpO1xuICAgIEFzc2VydCghcmVzdWx0Lm1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgsICdTY2hlbWEgd2l0aCBleHRlcm5hbCBydWxlcyBtdXN0IHVzZSB2YWxpZGF0ZUFzeW5jKCknKTtcbiAgICBjb25zdCBvdXRjb21lID0geyB2YWx1ZTogcmVzdWx0LnZhbHVlIH07XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIG91dGNvbWUuZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMocmVzdWx0Lm1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgIG91dGNvbWUuZGVidWcgPSByZXN1bHQubWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSByZXN1bHQubWFpbnN0YXkuYXJ0aWZhY3RzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xufTtcblxuXG5leHBvcnRzLmVudHJ5QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBDb21tb24ucHJlZmVyZW5jZXMoQ29tbW9uLmRlZmF1bHRzLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmVudHJ5KHZhbHVlLCBzY2hlbWEsIHNldHRpbmdzKTtcbiAgICBjb25zdCBtYWluc3RheSA9IHJlc3VsdC5tYWluc3RheTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV4dGVybmFsIG9mIG1haW5zdGF5LmV4dGVybmFscykge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGV4dGVybmFsLnN0YXRlLnBhdGg7XG4gICAgICAgICAgICBjb25zdCBsaW5rZWQgPSBleHRlcm5hbC5zY2hlbWEudHlwZSA9PT0gJ2xpbmsnID8gbWFpbnN0YXkubGlua3MuZ2V0KGV4dGVybmFsLnNjaGVtYSkgOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSByb290O1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IHBhdGgubGVuZ3RoID8gW3Jvb3RdIDogW107XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHBhdGgubGVuZ3RoID8gUmVhY2godmFsdWUsIHBhdGgpIDogdmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcm9vdDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aC5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbc2VnbWVudF07XG4gICAgICAgICAgICAgICAgICAgIGFuY2VzdG9ycy51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGFuY2VzdG9yc1swXTtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlRXJyb3IgPSAoY29kZSwgbG9jYWwpID0+IChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKGNvZGUsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGV4dGVybmFsLm1ldGhvZChub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZXh0ZXJuYWwuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBsaW5rZWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBleHRlcm5hbC5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZnMsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yc0FycmF5OiBpbnRlcm5hbHMuZXJyb3JzQXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHdhcm46IChjb2RlLCBsb2NhbCkgPT4gbWFpbnN0YXkud2FybmluZ3MucHVzaCgobGlua2VkIHx8IGV4dGVybmFsLnNjaGVtYSkuJF9jcmVhdGVFcnJvcihjb2RlLCBub2RlLCBsb2NhbCwgZXh0ZXJuYWwuc3RhdGUsIHNldHRpbmdzKSksXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChtZXNzYWdlcywgbG9jYWwpID0+IChsaW5rZWQgfHwgZXh0ZXJuYWwuc2NoZW1hKS4kX2NyZWF0ZUVycm9yKCdleHRlcm5hbCcsIG5vZGUsIGxvY2FsLCBleHRlcm5hbC5zdGF0ZSwgc2V0dGluZ3MsIHsgbWVzc2FnZXMgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPT09IG5vZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIubG9nKGV4dGVybmFsLnNjaGVtYSwgZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgJ2V4dGVybmFsJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0KSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIubG9nKGV4dGVybmFsLnNjaGVtYSwgZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgJ2V4dGVybmFsJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLm91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIudmFsdWUoZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgbm9kZSwgb3V0cHV0LCAnZXh0ZXJuYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYWluc3RheS50cmFjZXIudmFsdWUoZXh0ZXJuYWwuc3RhdGUsICdydWxlJywgcm9vdCwgb3V0cHV0LCAnZXh0ZXJuYWwnKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArPSBgICgkeyhleHRlcm5hbC5sYWJlbCl9KWA7ICAgICAgIC8vIENoYW5nZSBtZXNzYWdlIHRvIGluY2x1ZGUgcGF0aFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHJvb3Q7XG5cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IEVycm9ycy5wcm9jZXNzKGVycm9ycywgdmFsdWUsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgaWYgKG1haW5zdGF5LmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2V0dGluZ3Mud2FybmluZ3MgJiZcbiAgICAgICAgIXNldHRpbmdzLmRlYnVnICYmXG4gICAgICAgICFzZXR0aW5ncy5hcnRpZmFjdHMpIHtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGNvbWUgPSB7IHZhbHVlOiByZXN1bHQudmFsdWUgfTtcbiAgICBpZiAobWFpbnN0YXkud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG91dGNvbWUud2FybmluZyA9IEVycm9ycy5kZXRhaWxzKG1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAobWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgb3V0Y29tZS5kZWJ1ZyA9IG1haW5zdGF5LmRlYnVnO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5hcnRpZmFjdHMpIHtcbiAgICAgICAgb3V0Y29tZS5hcnRpZmFjdHMgPSBtYWluc3RheS5hcnRpZmFjdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG59O1xuXG5cbmludGVybmFscy5NYWluc3RheSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHRyYWNlciwgZGVidWcsIGxpbmtzKSB7XG5cbiAgICAgICAgdGhpcy5leHRlcm5hbHMgPSBbXTtcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLnRyYWNlciA9IHRyYWNlcjtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICB0aGlzLmxpbmtzID0gbGlua3M7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NuYXBzaG90cyA9IFtdO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIHRoaXMuX3NuYXBzaG90cy5wdXNoKHtcbiAgICAgICAgICAgIGV4dGVybmFsczogdGhpcy5leHRlcm5hbHMuc2xpY2UoKSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzLnNsaWNlKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcblxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuX3NuYXBzaG90cy5wb3AoKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbHMgPSBzbmFwc2hvdC5leHRlcm5hbHM7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBzbmFwc2hvdC53YXJuaW5ncztcbiAgICB9XG5cbiAgICBjb21taXQoKSB7XG5cbiAgICAgICAgdGhpcy5fc25hcHNob3RzLnBvcCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmVudHJ5ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICAvLyBQcmVwYXJlIHN0YXRlXG5cbiAgICBjb25zdCB7IHRyYWNlciwgY2xlYW51cCB9ID0gaW50ZXJuYWxzLnRyYWNlcihzY2hlbWEsIHByZWZzKTtcbiAgICBjb25zdCBkZWJ1ZyA9IHByZWZzLmRlYnVnID8gW10gOiBudWxsO1xuICAgIGNvbnN0IGxpbmtzID0gc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluID8gbmV3IE1hcCgpIDogbnVsbDtcbiAgICBjb25zdCBtYWluc3RheSA9IG5ldyBpbnRlcm5hbHMuTWFpbnN0YXkodHJhY2VyLCBkZWJ1ZywgbGlua3MpO1xuICAgIGNvbnN0IHNjaGVtYXMgPSBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4gPyBbeyBzY2hlbWEgfV0gOiBudWxsO1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKFtdLCBbXSwgeyBtYWluc3RheSwgc2NoZW1hcyB9KTtcblxuICAgIC8vIFZhbGlkYXRlIHZhbHVlXG5cbiAgICBjb25zdCByZXN1bHQgPSBleHBvcnRzLnZhbGlkYXRlKHZhbHVlLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICAvLyBQcm9jZXNzIHZhbHVlIGFuZCBlcnJvcnNcblxuICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgIHNjaGVtYS4kX3Jvb3QudW50cmFjZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gRXJyb3JzLnByb2Nlc3MocmVzdWx0LmVycm9ycywgdmFsdWUsIHByZWZzKTtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBlcnJvciwgbWFpbnN0YXkgfTtcbn07XG5cblxuaW50ZXJuYWxzLnRyYWNlciA9IGZ1bmN0aW9uIChzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC5fdHJhY2VyLl9yZWdpc3RlcihzY2hlbWEpIH07XG4gICAgfVxuXG4gICAgaWYgKHByZWZzLmRlYnVnKSB7XG4gICAgICAgIEFzc2VydChzY2hlbWEuJF9yb290LnRyYWNlLCAnRGVidWcgbW9kZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybiB7IHRyYWNlcjogc2NoZW1hLiRfcm9vdC50cmFjZSgpLl9yZWdpc3RlcihzY2hlbWEpLCBjbGVhbnVwOiB0cnVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJhY2VyOiBpbnRlcm5hbHMuaWdub3JlIH07XG59O1xuXG5cbmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMgPSB7fSkge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYS5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xuICAgIH1cblxuICAgIC8vIFNldHVwIHN0YXRlIGFuZCBzZXR0aW5nc1xuXG4gICAgaWYgKHNjaGVtYS5fcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgcHJlZnMgPSBpbnRlcm5hbHMucHJlZnMoc2NoZW1hLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGVcblxuICAgIGlmIChzY2hlbWEuX2NhY2hlICYmXG4gICAgICAgIHByZWZzLmNhY2hlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl9jYWNoZS5nZXQodmFsdWUpO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICd2YWxpZGF0ZScsICdjYWNoZWQnLCAhIXJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzXG5cbiAgICBjb25zdCBjcmVhdGVFcnJvciA9IChjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoY29kZSwgdmFsdWUsIGxvY2FsLCBsb2NhbFN0YXRlIHx8IHN0YXRlLCBwcmVmcyk7XG4gICAgY29uc3QgaGVscGVycyA9IHtcbiAgICAgICAgb3JpZ2luYWw6IHZhbHVlLFxuICAgICAgICBwcmVmcyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yLFxuICAgICAgICBlcnJvcnNBcnJheTogaW50ZXJuYWxzLmVycm9yc0FycmF5LFxuICAgICAgICB3YXJuOiAoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpID0+IHN0YXRlLm1haW5zdGF5Lndhcm5pbmdzLnB1c2goY3JlYXRlRXJyb3IoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpKSxcbiAgICAgICAgbWVzc2FnZTogKG1lc3NhZ2VzLCBsb2NhbCkgPT4gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2N1c3RvbScsIHZhbHVlLCBsb2NhbCwgc3RhdGUsIHByZWZzLCB7IG1lc3NhZ2VzIH0pXG4gICAgfTtcblxuICAgIC8vIFByZXBhcmVcblxuICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5lbnRyeShzY2hlbWEsIHN0YXRlKTtcblxuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmLnByZXBhcmUgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0KSB7XG5cbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBkZWYucHJlcGFyZSh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChwcmVwYXJlZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAncHJlcGFyZScsIHZhbHVlLCBwcmVwYXJlZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShwcmVwYXJlZC52YWx1ZSwgW10uY29uY2F0KHByZXBhcmVkLmVycm9ycyksIGhlbHBlcnMpOyAgICAgICAgIC8vIFByZXBhcmUgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHByZXBhcmVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHlwZSBjb2VyY2lvblxuXG4gICAgaWYgKGRlZi5jb2VyY2UgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcmVmcy5jb252ZXJ0ICYmXG4gICAgICAgICghZGVmLmNvZXJjZS5mcm9tIHx8IGRlZi5jb2VyY2UuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSkge1xuXG4gICAgICAgIGNvbnN0IGNvZXJjZWQgPSBkZWYuY29lcmNlLm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChjb2VyY2VkKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdjb2VyY2VkJywgdmFsdWUsIGNvZXJjZWQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZShjb2VyY2VkLnZhbHVlLCBbXS5jb25jYXQoY29lcmNlZC5lcnJvcnMpLCBoZWxwZXJzKTsgICAgICAgICAgIC8vIENvZXJjZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtcHR5IHZhbHVlXG5cbiAgICBjb25zdCBlbXB0eSA9IHNjaGVtYS5fZmxhZ3MuZW1wdHk7XG4gICAgaWYgKGVtcHR5ICYmXG4gICAgICAgIGVtcHR5LiRfbWF0Y2goaW50ZXJuYWxzLnRyaW0odmFsdWUsIHNjaGVtYSksIHN0YXRlLm5lc3QoZW1wdHkpLCBDb21tb24uZGVmYXVsdHMpKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZW1wdHknLCB2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUHJlc2VuY2UgcmVxdWlyZW1lbnRzIChyZXF1aXJlZCwgb3B0aW9uYWwsIGZvcmJpZGRlbilcblxuICAgIGNvbnN0IHByZXNlbmNlID0gb3ZlcnJpZGVzLnByZXNlbmNlIHx8IHNjaGVtYS5fZmxhZ3MucHJlc2VuY2UgfHwgKHNjaGVtYS5fZmxhZ3MuX2VuZGVkU3dpdGNoID8gbnVsbCA6IHByZWZzLnByZXNlbmNlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3NjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVxdWlyZWQnLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5kZWZhdWx0ICE9PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdkZWZhdWx0JywgdmFsdWUsIHt9KTtcbiAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnVua25vd24nLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgIH1cblxuICAgIC8vIEFsbG93ZWQgdmFsdWVzXG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5fdmFsaWRzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBzY2hlbWEuX2ZsYWdzLmluc2Vuc2l0aXZlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3ZhbGlkcycsIHZhbHVlLCBtYXRjaC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmZpbHRlcihzY2hlbWEsIHN0YXRlLCAndmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm9ubHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkub25seScsIHZhbHVlLCB7IHZhbGlkczogc2NoZW1hLl92YWxpZHMudmFsdWVzKHsgZGlzcGxheTogdHJ1ZSB9KSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbcmVwb3J0XSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZW5pZWQgdmFsdWVzXG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5faW52YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYS5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5maWx0ZXIoc2NoZW1hLCBzdGF0ZSwgJ2ludmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LmludmFsaWQnLCB2YWx1ZSwgeyBpbnZhbGlkczogc2NoZW1hLl9pbnZhbGlkcy52YWx1ZXMoeyBkaXNwbGF5OiB0cnVlIH0pIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtyZXBvcnRdLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJhc2UgdHlwZVxuXG4gICAgaWYgKGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gZGVmLnZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Jhc2UnLCB2YWx1ZSwgYmFzZS52YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2UudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChiYXNlLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXNlLmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpOyAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmJhc2UuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTsgICAgICAgICAgLy8gQmFzZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGVzdHNcblxuICAgIGlmICghc2NoZW1hLl9ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnJ1bGVzKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSBmdW5jdGlvbiAodmFsdWUsIGVycm9ycywgaGVscGVycykge1xuXG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBzY2hlbWEuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5tZXRob2RdO1xuXG4gICAgICAgIC8vIFNraXAgcnVsZXMgdGhhdCBhcmUgYWxzbyBhcHBsaWVkIGluIGNvZXJjZSBzdGVwXG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29udmVydCAmJlxuICAgICAgICAgICAgcHJlZnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAnZnVsbCcpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHJlZmVyZW5jZXNcblxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgYXJncyA9IHJ1bGUuYXJncztcbiAgICAgICAgaWYgKHJ1bGUuX3Jlc29sdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcmdzID0gT2JqZWN0LmFzc2lnbih7fSwgYXJncyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcnVsZS5fcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhcmdzW2tleV0ucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gcmVzb2x2ZXIubm9ybWFsaXplID8gcmVzb2x2ZXIubm9ybWFsaXplKHJlc29sdmVkKSA6IHJlc29sdmVkO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZCA9IENvbW1vbi52YWxpZGF0ZUFyZyhub3JtYWxpemVkLCBudWxsLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCByZXNvbHZlZCwgeyBhcmc6IGtleSwgcmVmOiBhcmdzW2tleV0sIHJlYXNvbjogaW52YWxpZCB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBydWxlXG5cbiAgICAgICAgcmV0ID0gcmV0IHx8IGRlZmluaXRpb24udmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHJ1bGUpOyAgICAgICAgICAgLy8gVXNlIHJldCBpZiBhbHJlYWR5IHNldCB0byByZWZlcmVuY2UgZXJyb3JcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMucnVsZShyZXQsIHJ1bGUpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ2Vycm9yJyk7XG5cbiAgICAgICAgICAgIGlmIChydWxlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS53YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIHJlc3VsdC5lcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdwYXNzJyk7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdydWxlJywgdmFsdWUsIHJlc3VsdC52YWx1ZSwgcnVsZS5uYW1lKTtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJ1bGUgPSBmdW5jdGlvbiAocmV0LCBydWxlKSB7XG5cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICBpbnRlcm5hbHMuZXJyb3IocmV0LCBydWxlKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBbcmV0XSwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXQpICYmXG4gICAgICAgIHJldFtDb21tb24uc3ltYm9scy5lcnJvcnNdKSB7XG5cbiAgICAgICAgcmV0LmZvckVhY2goKHJlcG9ydCkgPT4gaW50ZXJuYWxzLmVycm9yKHJlcG9ydCwgcnVsZSkpO1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IHJldCwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IG51bGwsIHZhbHVlOiByZXQgfTtcbn07XG5cblxuaW50ZXJuYWxzLmVycm9yID0gZnVuY3Rpb24gKHJlcG9ydCwgcnVsZSkge1xuXG4gICAgaWYgKHJ1bGUubWVzc2FnZSkge1xuICAgICAgICByZXBvcnQuX3NldFRlbXBsYXRlKHJ1bGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydDtcbn07XG5cblxuaW50ZXJuYWxzLmZpbmFsaXplID0gZnVuY3Rpb24gKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpIHtcblxuICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuXG4gICAgLy8gRmFpbG92ZXIgdmFsdWVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZhaWxvdmVyID0gaW50ZXJuYWxzLmRlZmF1bHQoJ2ZhaWxvdmVyJywgdW5kZWZpbmVkLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoZmFpbG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZmFpbG92ZXInLCB2YWx1ZSwgZmFpbG92ZXIpO1xuICAgICAgICAgICAgdmFsdWUgPSBmYWlsb3ZlcjtcbiAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXJyb3Igb3ZlcnJpZGVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoICYmXG4gICAgICAgIHNjaGVtYS5fZmxhZ3MuZXJyb3IpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5fZmxhZ3MuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IHNjaGVtYS5fZmxhZ3MuZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW2Vycm9yc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0LCAnZXJyb3IoKSBtdXN0IHJldHVybiBhbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IFtzY2hlbWEuX2ZsYWdzLmVycm9yXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHRcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRlZCA9IGludGVybmFscy5kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIGVycm9ycywgaGVscGVycyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2RlZmF1bHQnLCB2YWx1ZSwgZGVmYXVsdGVkKTtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0ZWQ7XG4gICAgfVxuXG4gICAgLy8gQ2FzdFxuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MuY2FzdCAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgY29uc3QgY2FzdGVyID0gc2NoZW1hLl9kZWZpbml0aW9uLmNhc3Rbc2NoZW1hLl9mbGFncy5jYXN0XTtcbiAgICAgICAgaWYgKGNhc3Rlci5mcm9tKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgY2FzdGVkID0gY2FzdGVyLnRvKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Nhc3QnLCB2YWx1ZSwgY2FzdGVkLCBzY2hlbWEuX2ZsYWdzLmNhc3QpO1xuICAgICAgICAgICAgdmFsdWUgPSBjYXN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRlcm5hbHNcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMgJiZcbiAgICAgICAgcHJlZnMuZXh0ZXJuYWxzICYmXG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlZCBmb3IgbWF0Y2hpbmdcblxuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0aG9kIH0gb2Ygc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5leHRlcm5hbHMucHVzaCh7IG1ldGhvZCwgc2NoZW1hLCBzdGF0ZSwgbGFiZWw6IEVycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzdWx0XG5cbiAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlLCBlcnJvcnM6IGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiBudWxsIH07XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5yZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgPyB1bmRlZmluZWQgOiAvKiByYXcgKi8gaGVscGVycy5vcmlnaW5hbDtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCBzY2hlbWEuX2ZsYWdzLnJlc3VsdCwgdmFsdWUsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHN0YXRlLnNoYWRvdyh2YWx1ZSwgc2NoZW1hLl9mbGFncy5yZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIENhY2hlXG5cbiAgICBpZiAoc2NoZW1hLl9jYWNoZSAmJlxuICAgICAgICBwcmVmcy5jYWNoZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgIXNjaGVtYS5fcmVmcy5sZW5ndGgpIHtcblxuICAgICAgICBzY2hlbWEuX2NhY2hlLnNldChoZWxwZXJzLm9yaWdpbmFsLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIEFydGlmYWN0c1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXJlc3VsdC5lcnJvcnMgJiZcbiAgICAgICAgc2NoZW1hLl9mbGFncy5hcnRpZmFjdCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzID0gc3RhdGUubWFpbnN0YXkuYXJ0aWZhY3RzIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuaGFzKHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5hcnRpZmFjdHMuc2V0KHNjaGVtYS5fZmxhZ3MuYXJ0aWZhY3QsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmFydGlmYWN0cy5nZXQoc2NoZW1hLl9mbGFncy5hcnRpZmFjdCkucHVzaChzdGF0ZS5wYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5pbnRlcm5hbHMucHJlZnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmcykge1xuXG4gICAgY29uc3QgaXNEZWZhdWx0T3B0aW9ucyA9IHByZWZzID09PSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMgJiZcbiAgICAgICAgc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc10pIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgfVxuXG4gICAgcHJlZnMgPSBDb21tb24ucHJlZmVyZW5jZXMocHJlZnMsIHNjaGVtYS5fcHJlZmVyZW5jZXMpO1xuICAgIGlmIChpc0RlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHNjaGVtYS5fcHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdID0gcHJlZnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZzO1xufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbGFnLCB2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuICAgIGNvbnN0IHNvdXJjZSA9IHNjaGVtYS5fZmxhZ3NbZmxhZ107XG4gICAgaWYgKHByZWZzLm5vRGVmYXVsdHMgfHxcbiAgICAgICAgc291cmNlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIGZsYWcsICdmdWxsJyk7XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzb3VyY2UubGVuZ3RoID8gW0Nsb25lKHN0YXRlLmFuY2VzdG9yc1swXSksIGhlbHBlcnNdIDogW107XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoYGFueS4ke2ZsYWd9YCwgbnVsbCwgeyBlcnJvcjogZXJyIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVtDb21tb24uc3ltYm9scy5saXRlcmFsXSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxpdGVyYWw7XG4gICAgfVxuXG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENsb25lKHNvdXJjZSk7XG59O1xuXG5cbmludGVybmFscy50cmltID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEpIHtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmltID0gc2NoZW1hLiRfZ2V0UnVsZSgndHJpbScpO1xuICAgIGlmICghdHJpbSB8fFxuICAgICAgICAhdHJpbS5hcmdzLmVuYWJsZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbn07XG5cblxuaW50ZXJuYWxzLmlnbm9yZSA9IHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRlYnVnOiBJZ25vcmUsXG4gICAgZW50cnk6IElnbm9yZSxcbiAgICBmaWx0ZXI6IElnbm9yZSxcbiAgICBsb2c6IElnbm9yZSxcbiAgICByZXNvbHZlOiBJZ25vcmUsXG4gICAgdmFsdWU6IElnbm9yZVxufTtcblxuXG5pbnRlcm5hbHMuZXJyb3JzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBlcnJvcnNbQ29tbW9uLnN5bWJvbHMuZXJyb3JzXSA9IHRydWU7XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iXSwibmFtZXMiOlsiQXNzZXJ0IiwicmVxdWlyZSIsIkNsb25lIiwiSWdub3JlIiwiUmVhY2giLCJDb21tb24iLCJFcnJvcnMiLCJTdGF0ZSIsImludGVybmFscyIsInJlc3VsdCIsIlN5bWJvbCIsImV4cG9ydHMiLCJlbnRyeSIsInZhbHVlIiwic2NoZW1hIiwicHJlZnMiLCJzZXR0aW5ncyIsImRlZmF1bHRzIiwid2FybmluZ3MiLCJ1bmRlZmluZWQiLCJhcnRpZmFjdHMiLCJwcmVmZXJlbmNlcyIsIm1haW5zdGF5IiwiZXh0ZXJuYWxzIiwibGVuZ3RoIiwib3V0Y29tZSIsImVycm9yIiwid2FybmluZyIsImRldGFpbHMiLCJkZWJ1ZyIsImVudHJ5QXN5bmMiLCJyb290IiwiZXJyb3JzIiwiZXh0ZXJuYWwiLCJwYXRoIiwic3RhdGUiLCJsaW5rZWQiLCJ0eXBlIiwibGlua3MiLCJnZXQiLCJub2RlIiwia2V5IiwicGFyZW50IiwiYW5jZXN0b3JzIiwib3JpZ2luYWwiLCJjdXJyZW50Iiwic2VnbWVudCIsInNsaWNlIiwidW5zaGlmdCIsImNyZWF0ZUVycm9yIiwiY29kZSIsImxvY2FsIiwiJF9jcmVhdGVFcnJvciIsIm91dHB1dCIsIm1ldGhvZCIsImVycm9yc0FycmF5Iiwid2FybiIsInB1c2giLCJtZXNzYWdlIiwibWVzc2FnZXMiLCJSZXBvcnQiLCJ0cmFjZXIiLCJsb2ciLCJhYm9ydEVhcmx5IiwiQXJyYXkiLCJpc0FycmF5Iiwic3ltYm9scyIsImVyciIsImxhYmVsIiwicHJvY2VzcyIsIk1haW5zdGF5IiwiY29uc3RydWN0b3IiLCJzaGFkb3ciLCJfc25hcHNob3RzIiwic25hcHNob3QiLCJyZXN0b3JlIiwicG9wIiwiY29tbWl0IiwiY2xlYW51cCIsIl9pZHMiLCJfc2NoZW1hQ2hhaW4iLCJNYXAiLCJzY2hlbWFzIiwidmFsaWRhdGUiLCIkX3Jvb3QiLCJ1bnRyYWNlIiwiX3RyYWNlciIsIl9yZWdpc3RlciIsInRyYWNlIiwiaWdub3JlIiwib3ZlcnJpZGVzIiwiJF90ZXJtcyIsIndoZW5zIiwiX2dlbmVyYXRlIiwiX3ByZWZlcmVuY2VzIiwiX2NhY2hlIiwiY2FjaGUiLCJsb2NhbFN0YXRlIiwiaGVscGVycyIsImRlZiIsIl9kZWZpbml0aW9uIiwicHJlcGFyZSIsImNvbnZlcnQiLCJwcmVwYXJlZCIsImZpbmFsaXplIiwiY29uY2F0IiwiY29lcmNlIiwiZnJvbSIsImluY2x1ZGVzIiwiY29lcmNlZCIsImVtcHR5IiwiX2ZsYWdzIiwiJF9tYXRjaCIsInRyaW0iLCJuZXN0IiwicHJlc2VuY2UiLCJfZW5kZWRTd2l0Y2giLCJkZWZhdWx0IiwiZGVlcERlZmF1bHQiLCJfdmFsaWRzIiwibWF0Y2giLCJpbnNlbnNpdGl2ZSIsImZpbHRlciIsIm9ubHkiLCJyZXBvcnQiLCJ2YWxpZHMiLCJ2YWx1ZXMiLCJkaXNwbGF5IiwiX2ludmFsaWRzIiwiaW52YWxpZHMiLCJiYXNlIiwiX3J1bGVzIiwicnVsZXMiLCJydWxlIiwiZGVmaW5pdGlvbiIsIm5hbWUiLCJyZXQiLCJhcmdzIiwiX3Jlc29sdmUiLCJPYmplY3QiLCJhc3NpZ24iLCJyZXNvbHZlciIsImFyZ3NCeU5hbWUiLCJyZXNvbHZlZCIsInJlc29sdmUiLCJub3JtYWxpemVkIiwibm9ybWFsaXplIiwiaW52YWxpZCIsInZhbGlkYXRlQXJnIiwiYXJnIiwicmVmIiwicmVhc29uIiwiZm9yRWFjaCIsIl9zZXRUZW1wbGF0ZSIsImZhaWxvdmVyIiwiRXJyb3IiLCJkZWZhdWx0ZWQiLCJjYXN0IiwiY2FzdGVyIiwiY2FzdGVkIiwidG8iLCJfZXh0ZXJuYWxzIiwiX3JlZnMiLCJzZXQiLCJhcnRpZmFjdCIsImhhcyIsImlzRGVmYXVsdE9wdGlvbnMiLCJmbGFnIiwic291cmNlIiwibm9EZWZhdWx0cyIsImxpdGVyYWwiLCJpc1Jlc29sdmFibGUiLCIkX2dldFJ1bGUiLCJlbmFibGVkIiwiYWN0aXZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/lib/values.js":
/*!****************************************!*\
  !*** ./node_modules/joi/lib/values.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ \"(rsc)/./node_modules/@hapi/hoek/lib/assert.js\");\nconst DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ \"(rsc)/./node_modules/@hapi/hoek/lib/deepEqual.js\");\nconst Common = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/joi/lib/common.js\");\nconst internals = {};\nmodule.exports = internals.Values = class {\n    constructor(values, refs){\n        this._values = new Set(values);\n        this._refs = new Set(refs);\n        this._lowercase = internals.lowercases(values);\n        this._override = false;\n    }\n    get length() {\n        return this._values.size + this._refs.size;\n    }\n    add(value, refs) {\n        // Reference\n        if (Common.isResolvable(value)) {\n            if (!this._refs.has(value)) {\n                this._refs.add(value);\n                if (refs) {\n                    refs.register(value);\n                }\n            }\n            return;\n        }\n        // Value\n        if (!this.has(value, null, null, false)) {\n            this._values.add(value);\n            if (typeof value === \"string\") {\n                this._lowercase.set(value.toLowerCase(), value);\n            }\n        }\n    }\n    static merge(target, source, remove) {\n        target = target || new internals.Values();\n        if (source) {\n            if (source._override) {\n                return source.clone();\n            }\n            for (const item of [\n                ...source._values,\n                ...source._refs\n            ]){\n                target.add(item);\n            }\n        }\n        if (remove) {\n            for (const item of [\n                ...remove._values,\n                ...remove._refs\n            ]){\n                target.remove(item);\n            }\n        }\n        return target.length ? target : null;\n    }\n    remove(value) {\n        // Reference\n        if (Common.isResolvable(value)) {\n            this._refs.delete(value);\n            return;\n        }\n        // Value\n        this._values.delete(value);\n        if (typeof value === \"string\") {\n            this._lowercase.delete(value.toLowerCase());\n        }\n    }\n    has(value, state, prefs, insensitive) {\n        return !!this.get(value, state, prefs, insensitive);\n    }\n    get(value, state, prefs, insensitive) {\n        if (!this.length) {\n            return false;\n        }\n        // Simple match\n        if (this._values.has(value)) {\n            return {\n                value\n            };\n        }\n        // Case insensitive string match\n        if (typeof value === \"string\" && value && insensitive) {\n            const found = this._lowercase.get(value.toLowerCase());\n            if (found) {\n                return {\n                    value: found\n                };\n            }\n        }\n        if (!this._refs.size && typeof value !== \"object\") {\n            return false;\n        }\n        // Objects\n        if (typeof value === \"object\") {\n            for (const item of this._values){\n                if (DeepEqual(item, value)) {\n                    return {\n                        value: item\n                    };\n                }\n            }\n        }\n        // References\n        if (state) {\n            for (const ref of this._refs){\n                const resolved = ref.resolve(value, state, prefs, null, {\n                    in: true\n                });\n                if (resolved === undefined) {\n                    continue;\n                }\n                const items = !ref.in || typeof resolved !== \"object\" ? [\n                    resolved\n                ] : Array.isArray(resolved) ? resolved : Object.keys(resolved);\n                for (const item of items){\n                    if (typeof item !== typeof value) {\n                        continue;\n                    }\n                    if (insensitive && value && typeof value === \"string\") {\n                        if (item.toLowerCase() === value.toLowerCase()) {\n                            return {\n                                value: item,\n                                ref\n                            };\n                        }\n                    } else {\n                        if (DeepEqual(item, value)) {\n                            return {\n                                value: item,\n                                ref\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    override() {\n        this._override = true;\n    }\n    values(options) {\n        if (options && options.display) {\n            const values = [];\n            for (const item of [\n                ...this._values,\n                ...this._refs\n            ]){\n                if (item !== undefined) {\n                    values.push(item);\n                }\n            }\n            return values;\n        }\n        return Array.from([\n            ...this._values,\n            ...this._refs\n        ]);\n    }\n    clone() {\n        const set = new internals.Values(this._values, this._refs);\n        set._override = this._override;\n        return set;\n    }\n    concat(source) {\n        Assert(!source._override, \"Cannot concat override set of values\");\n        const set = new internals.Values([\n            ...this._values,\n            ...source._values\n        ], [\n            ...this._refs,\n            ...source._refs\n        ]);\n        set._override = this._override;\n        return set;\n    }\n    describe() {\n        const normalized = [];\n        if (this._override) {\n            normalized.push({\n                override: true\n            });\n        }\n        for (const value of this._values.values()){\n            normalized.push(value && typeof value === \"object\" ? {\n                value\n            } : value);\n        }\n        for (const value of this._refs.values()){\n            normalized.push(value.describe());\n        }\n        return normalized;\n    }\n};\ninternals.Values.prototype[Common.symbols.values] = true;\n// Aliases\ninternals.Values.prototype.slice = internals.Values.prototype.clone;\n// Helpers\ninternals.lowercases = function(from) {\n    const map = new Map();\n    if (from) {\n        for (const value of from){\n            if (typeof value === \"string\") {\n                map.set(value.toLowerCase(), value);\n            }\n        }\n    }\n    return map;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvam9pL2xpYi92YWx1ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUUxQixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUd2QixNQUFNRyxZQUFZLENBQUM7QUFHbkJDLE9BQU9DLE9BQU8sR0FBR0YsVUFBVUcsTUFBTSxHQUFHO0lBRWhDQyxZQUFZQyxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUV0QixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQyxJQUFJSDtRQUN2QixJQUFJLENBQUNJLEtBQUssR0FBRyxJQUFJRCxJQUFJRjtRQUNyQixJQUFJLENBQUNJLFVBQVUsR0FBR1YsVUFBVVcsVUFBVSxDQUFDTjtRQUV2QyxJQUFJLENBQUNPLFNBQVMsR0FBRztJQUNyQjtJQUVBLElBQUlDLFNBQVM7UUFFVCxPQUFPLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxJQUFJLEdBQUcsSUFBSSxDQUFDTCxLQUFLLENBQUNLLElBQUk7SUFDOUM7SUFFQUMsSUFBSUMsS0FBSyxFQUFFVixJQUFJLEVBQUU7UUFFYixZQUFZO1FBRVosSUFBSVAsT0FBT2tCLFlBQVksQ0FBQ0QsUUFBUTtZQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDUCxLQUFLLENBQUNTLEdBQUcsQ0FBQ0YsUUFBUTtnQkFDeEIsSUFBSSxDQUFDUCxLQUFLLENBQUNNLEdBQUcsQ0FBQ0M7Z0JBRWYsSUFBSVYsTUFBTTtvQkFDTkEsS0FBS2EsUUFBUSxDQUFDSDtnQkFDbEI7WUFDSjtZQUVBO1FBQ0o7UUFFQSxRQUFRO1FBRVIsSUFBSSxDQUFDLElBQUksQ0FBQ0UsR0FBRyxDQUFDRixPQUFPLE1BQU0sTUFBTSxRQUFRO1lBQ3JDLElBQUksQ0FBQ1QsT0FBTyxDQUFDUSxHQUFHLENBQUNDO1lBRWpCLElBQUksT0FBT0EsVUFBVSxVQUFVO2dCQUMzQixJQUFJLENBQUNOLFVBQVUs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b3VyY2VzIjpbIndlYnBhY2s6Ly9tb2JpbGUtY2hhdGdwdC1jbG9uZS8uL25vZGVfbW9kdWxlcy9qb2kvbGliL3ZhbHVlcy5qcz80NGJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5WYWx1ZXMgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMsIHJlZnMpIHtcblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBuZXcgU2V0KHZhbHVlcyk7XG4gICAgICAgIHRoaXMuX3JlZnMgPSBuZXcgU2V0KHJlZnMpO1xuICAgICAgICB0aGlzLl9sb3dlcmNhc2UgPSBpbnRlcm5hbHMubG93ZXJjYXNlcyh2YWx1ZXMpO1xuXG4gICAgICAgIHRoaXMuX292ZXJyaWRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLnNpemUgKyB0aGlzLl9yZWZzLnNpemU7XG4gICAgfVxuXG4gICAgYWRkKHZhbHVlLCByZWZzKSB7XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlZnMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZnMuYWRkKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWZzKSB7ICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcHBlZCBpbiBhIG1lcmdlXG4gICAgICAgICAgICAgICAgICAgIHJlZnMucmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsdWVcblxuICAgICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlLCBudWxsLCBudWxsLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvd2VyY2FzZS5zZXQodmFsdWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIG1lcmdlKHRhcmdldCwgc291cmNlLCByZW1vdmUpIHtcblxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IGludGVybmFscy5WYWx1ZXMoKTtcblxuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFsuLi5zb3VyY2UuX3ZhbHVlcywgLi4uc291cmNlLl9yZWZzXSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnJlbW92ZS5fdmFsdWVzLCAuLi5yZW1vdmUuX3JlZnNdKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQubGVuZ3RoID8gdGFyZ2V0IDogbnVsbDtcbiAgICB9XG5cbiAgICByZW1vdmUodmFsdWUpIHtcblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZnMuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbHVlXG5cbiAgICAgICAgdGhpcy5fdmFsdWVzLmRlbGV0ZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvd2VyY2FzZS5kZWxldGUodmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYXModmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSk7XG4gICAgfVxuXG4gICAgZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2ltcGxlIG1hdGNoXG5cbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZSBpbnNlbnNpdGl2ZSBzdHJpbmcgbWF0Y2hcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgIGluc2Vuc2l0aXZlKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fbG93ZXJjYXNlLmdldCh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBmb3VuZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZWZzLnNpemUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2JqZWN0c1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKERlZXBFcXVhbChpdGVtLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWZlcmVuY2VzXG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiB0aGlzLl9yZWZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZWYucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IGluOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gIXJlZi5pbiB8fCB0eXBlb2YgcmVzb2x2ZWQgIT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgID8gW3Jlc29sdmVkXVxuICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkocmVzb2x2ZWQpID8gcmVzb2x2ZWQgOiBPYmplY3Qua2V5cyhyZXNvbHZlZCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2Vuc2l0aXZlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIHJlZiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKERlZXBFcXVhbChpdGVtLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgcmVmIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUoKSB7XG5cbiAgICAgICAgdGhpcy5fb3ZlcnJpZGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhbHVlcyhvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuZGlzcGxheSkge1xuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFsuLi50aGlzLl92YWx1ZXMsIC4uLnRoaXMuX3JlZnNdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShbLi4udGhpcy5fdmFsdWVzLCAuLi50aGlzLl9yZWZzXSk7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IGludGVybmFscy5WYWx1ZXModGhpcy5fdmFsdWVzLCB0aGlzLl9yZWZzKTtcbiAgICAgICAgc2V0Ll9vdmVycmlkZSA9IHRoaXMuX292ZXJyaWRlO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBBc3NlcnQoIXNvdXJjZS5fb3ZlcnJpZGUsICdDYW5ub3QgY29uY2F0IG92ZXJyaWRlIHNldCBvZiB2YWx1ZXMnKTtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgaW50ZXJuYWxzLlZhbHVlcyhbLi4udGhpcy5fdmFsdWVzLCAuLi5zb3VyY2UuX3ZhbHVlc10sIFsuLi50aGlzLl9yZWZzLCAuLi5zb3VyY2UuX3JlZnNdKTtcbiAgICAgICAgc2V0Ll9vdmVycmlkZSA9IHRoaXMuX292ZXJyaWRlO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCh7IG92ZXJyaWRlOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLl92YWx1ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8geyB2YWx1ZSB9IDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLl9yZWZzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2godmFsdWUuZGVzY3JpYmUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5WYWx1ZXMucHJvdG90eXBlW0NvbW1vbi5zeW1ib2xzLnZhbHVlc10gPSB0cnVlO1xuXG5cbi8vIEFsaWFzZXNcblxuaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGUuc2xpY2UgPSBpbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZS5jbG9uZTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5sb3dlcmNhc2VzID0gZnVuY3Rpb24gKGZyb20pIHtcblxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGlmIChmcm9tKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZnJvbSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KHZhbHVlLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG59O1xuIl0sIm5hbWVzIjpbIkFzc2VydCIsInJlcXVpcmUiLCJEZWVwRXF1YWwiLCJDb21tb24iLCJpbnRlcm5hbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiVmFsdWVzIiwiY29uc3RydWN0b3IiLCJ2YWx1ZXMiLCJyZWZzIiwiX3ZhbHVlcyIsIlNldCIsIl9yZWZzIiwiX2xvd2VyY2FzZSIsImxvd2VyY2FzZXMiLCJfb3ZlcnJpZGUiLCJsZW5ndGgiLCJzaXplIiwiYWRkIiwidmFsdWUiLCJpc1Jlc29sdmFibGUiLCJoYXMiLCJyZWdpc3RlciIsInNldCIsInRvTG93ZXJDYXNlIiwibWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJyZW1vdmUiLCJjbG9uZSIsIml0ZW0iLCJkZWxldGUiLCJzdGF0ZSIsInByZWZzIiwiaW5zZW5zaXRpdmUiLCJnZXQiLCJmb3VuZCIsInJlZiIsInJlc29sdmVkIiwicmVzb2x2ZSIsImluIiwidW5kZWZpbmVkIiwiaXRlbXMiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwib3ZlcnJpZGUiLCJvcHRpb25zIiwiZGlzcGxheSIsInB1c2giLCJmcm9tIiwiY29uY2F0IiwiZGVzY3JpYmUiLCJub3JtYWxpemVkIiwicHJvdG90eXBlIiwic3ltYm9scyIsInNsaWNlIiwibWFwIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/joi/lib/values.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/joi/package.json":
/*!***************************************!*\
  !*** ./node_modules/joi/package.json ***!
  \***************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"joi","description":"Object schema validation","version":"17.13.3","repository":"git://github.com/hapijs/joi","main":"lib/index.js","types":"lib/index.d.ts","browser":"dist/joi-browser.min.js","files":["lib/**/*","dist/*"],"keywords":["schema","validation"],"dependencies":{"@hapi/hoek":"^9.3.0","@hapi/topo":"^5.1.0","@sideway/address":"^4.1.5","@sideway/formula":"^3.0.1","@sideway/pinpoint":"^2.0.0"},"devDependencies":{"@hapi/bourne":"2.x.x","@hapi/code":"8.x.x","@hapi/joi-legacy-test":"npm:@hapi/joi@15.x.x","@hapi/lab":"^25.1.3","@types/node":"^14.18.63","typescript":"4.3.x"},"scripts":{"prepublishOnly":"cd browser && npm install && npm run build","test":"lab -t 100 -a @hapi/code -L -Y","test-cov-html":"lab -r html -o coverage.html -a @hapi/code"},"license":"BSD-3-Clause"}');

/***/ })

};
;